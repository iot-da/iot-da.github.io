{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Internet of Things and Data Analytics Welcome to the Master Propio on IoT and Data Analytics. Lectures are starting the 19th October. We will be using Zoom and you can find the links in the schedule shown below. Looking forward to meet you all! 1st term - 19th Oct. till 13th Jan. 2022 Until 31st October, Spanish time is UTC+2, so the FIRST TWO WEEKS courses will be starting at 18:00h in China Standard Time. Starting November, Spanish time will be UTC+1, so courses will be starting at 19:00h in China Standard Time. Hours (Spanish time) Tuesday Wednesday Thursday Zoom Link 12:00-13:55 MDM IOTNA MDM Zoom link Meeting number: 885 4236 5522. Passcode: 641877 14:05-16:00 SID SID IOTNA Zoom link Meeting number: 892 8466 4167 Passcode: 477109 MDM : Massive Data Management . SID : Smart Infrastructures Design . IOTNA : IoT Node Architecture . Subjects MDM : Massive Data Management . SID : Smart Infrastructures Design . IOTNA : IoT Node Architecture . NP1 : Networks and Protocols I . NP2 : Networks and Protocols II . IA : Artificial Intelligence . EDGE : Edge Computing . SEC : Security . Professors and staff Subject Professor Mail Other IOTNA Jos\u00e9 Ignacio G\u00f3mez jigomez@ucm.es Director MDM Rafael Caballero rafa@sip.ucm.es - SID Iv\u00e1n Garc\u00eda igarciam@ucm.es - NP1 Christian Tenllado tenllado@ucm.es - NP2 Francisco Igual figual@ucm.es - AI H\u00e9ctor Garc\u00eda hgarciad@ucm.es - SEC Joaqu\u00edn Recas recas@ucm.es - SEC Guillermo Botella gbotella@ucm.es - EDGE Carlos Garc\u00eda garsanca@ucm.es - EDGE Luis Pi\u00f1uel lpinuel@ucm.es -","title":"Home"},{"location":"#internet-of-things-and-data-analytics","text":"Welcome to the Master Propio on IoT and Data Analytics. Lectures are starting the 19th October. We will be using Zoom and you can find the links in the schedule shown below. Looking forward to meet you all!","title":"Internet of Things and Data Analytics"},{"location":"#1st-term-19th-oct-till-13th-jan-2022","text":"Until 31st October, Spanish time is UTC+2, so the FIRST TWO WEEKS courses will be starting at 18:00h in China Standard Time. Starting November, Spanish time will be UTC+1, so courses will be starting at 19:00h in China Standard Time. Hours (Spanish time) Tuesday Wednesday Thursday Zoom Link 12:00-13:55 MDM IOTNA MDM Zoom link Meeting number: 885 4236 5522. Passcode: 641877 14:05-16:00 SID SID IOTNA Zoom link Meeting number: 892 8466 4167 Passcode: 477109 MDM : Massive Data Management . SID : Smart Infrastructures Design . IOTNA : IoT Node Architecture .","title":"1st term - 19th Oct. till 13th Jan. 2022"},{"location":"#subjects","text":"MDM : Massive Data Management . SID : Smart Infrastructures Design . IOTNA : IoT Node Architecture . NP1 : Networks and Protocols I . NP2 : Networks and Protocols II . IA : Artificial Intelligence . EDGE : Edge Computing . SEC : Security .","title":"Subjects"},{"location":"#professors-and-staff","text":"Subject Professor Mail Other IOTNA Jos\u00e9 Ignacio G\u00f3mez jigomez@ucm.es Director MDM Rafael Caballero rafa@sip.ucm.es - SID Iv\u00e1n Garc\u00eda igarciam@ucm.es - NP1 Christian Tenllado tenllado@ucm.es - NP2 Francisco Igual figual@ucm.es - AI H\u00e9ctor Garc\u00eda hgarciad@ucm.es - SEC Joaqu\u00edn Recas recas@ucm.es - SEC Guillermo Botella gbotella@ucm.es - EDGE Carlos Garc\u00eda garsanca@ucm.es - EDGE Luis Pi\u00f1uel lpinuel@ucm.es -","title":"Professors and staff"},{"location":"Contact/","text":"Contact information Director: XX Administrative staff: XX","title":"Contact"},{"location":"Contact/#contact-information","text":"Director: XX Administrative staff: XX","title":"Contact information"},{"location":"General/","text":"General information 1st term - 19th Oct. 2021 till 13th Jan 2022 Until 31st October, Spanish time is UTC+2, so the FIRST TWO WEEKS courses will be starting at 18:00h in China Standard Time. Starting November, Spanish time will be UTC+1, so courses will be starting at 19:00h in China Standard Time. Hours (Spanish time) Tuesday Wednesday Thursday 12:00-13:55 MDM IOTNA MDM 14:05-16:00 SID SID IOTNA MDM : Massive Data Management . SID : Smart Infrastructures Design . IOTNA : IoT Node Architecture . 2nd term - 18th Jan. 2022 till 7th Apr. 2022 From 28th March, Spanish time will become UTC+2 again. Most of the courses of this term will take place at 19:00h in China Standard Time. But, the LAST WEEK will be starting at 18:00h in China Standard Time. Hours (Spanish time) Tuesday Wednesday Thursday 12:00-13:55 NP2 IA NP1 14:05-16:00 IA NP1 NP2 NP1 : Networks and Protocols I . NP2 : Networks and Protocols II . IA : Artificial Intelligence . 3rd term - 19 Apr. till 3 Jun. All courses will be starting at 19:00h in China Standard Time Hours (UTC+2) Tuesday Wednesday Thursday 13:00-14:55 EDGE EDGE EDGE 15:05-17:00 SEC SEC SEC EDGE : Edge Computing . SEC : Security .","title":"General info."},{"location":"General/#general-information","text":"","title":"General information"},{"location":"General/#1st-term-19th-oct-2021-till-13th-jan-2022","text":"Until 31st October, Spanish time is UTC+2, so the FIRST TWO WEEKS courses will be starting at 18:00h in China Standard Time. Starting November, Spanish time will be UTC+1, so courses will be starting at 19:00h in China Standard Time. Hours (Spanish time) Tuesday Wednesday Thursday 12:00-13:55 MDM IOTNA MDM 14:05-16:00 SID SID IOTNA MDM : Massive Data Management . SID : Smart Infrastructures Design . IOTNA : IoT Node Architecture .","title":"1st term - 19th Oct. 2021  till  13th Jan 2022"},{"location":"General/#2nd-term-18th-jan-2022-till-7th-apr-2022","text":"From 28th March, Spanish time will become UTC+2 again. Most of the courses of this term will take place at 19:00h in China Standard Time. But, the LAST WEEK will be starting at 18:00h in China Standard Time. Hours (Spanish time) Tuesday Wednesday Thursday 12:00-13:55 NP2 IA NP1 14:05-16:00 IA NP1 NP2 NP1 : Networks and Protocols I . NP2 : Networks and Protocols II . IA : Artificial Intelligence .","title":"2nd term  - 18th Jan. 2022 till 7th Apr. 2022"},{"location":"General/#3rd-term-19-apr-till-3-jun","text":"All courses will be starting at 19:00h in China Standard Time Hours (UTC+2) Tuesday Wednesday Thursday 13:00-14:55 EDGE EDGE EDGE 15:05-17:00 SEC SEC SEC EDGE : Edge Computing . SEC : Security .","title":"3rd term - 19 Apr. till 3 Jun."},{"location":"News/","text":"News and announcements Test announcement - Jan 1st This is a test announcement. Test alert - Jan 1st This is a test alert.","title":"News"},{"location":"News/#news-and-announcements","text":"Test announcement - Jan 1st This is a test announcement. Test alert - Jan 1st This is a test alert.","title":"News and announcements"},{"location":"Subjects/EDGE/","text":"EDGE","title":"EDGE"},{"location":"Subjects/IA/","text":"IA","title":"IA"},{"location":"Subjects/IOTNA/","text":"IoT Node Architecture General information This subject will cover several topics regarding embedded system programmings. Specifically, we will learn to develop IoT projects using ESP-IDF , a framework built onto FreeRTOS . Some specific goals if this subject are: Get a global view of a safe application development cycle. Meet the main components of an IoT device Learn basic components of Real Time Operating Systems (RTOS) Work with sensors and learn the most common interfaces Subject program and evaluation methodology Program and evaluation Professors Jose Ignacio Gomez (jigomez@ucm.es) and Katzalin Olcoz (katzalin@ucm.es ) Work groups Here you can find the current work groups Schedule Day Topic Lab instructions Deliverable 20/10 Introduction: boards, SoC C Exercises 21/10 ESP-IDF environment Online DEMO 27/10 ESP-IDF 1. Starting ESP-IDF 28/10 ESP32 Memory map 1. Starting ESP-IDF 03/11 ESP-IDF Tasks Scheduler 2. Tasks: matrix multiply 04/11 ESP-IDF Tasks Scheduler 2. Tasks: matrix multiply 10/11 Events and task notifications 2. Tasks: matrix multiply 11/11 Input/Output - Polling/Interrupts - GPIO 3. Chronometer 17/11 Timers 3. Chronometer 18/11 Event based programming 3. Chronometer Lab 2 deadline 24/11 Event based programming. NAND/NOR Flash 3. Chronometer 25/11 File system. System Log 4. Log in flash 01/12 Whatchdog and debugging 4. Log in flash Lab 3 deadline 02/12 Sensors. Serial buses: I2C 5. Built-in sensors 08/12 NO LECTURE (non working day) Spain National Holiday 09/12 Serial buses: SPI, UART 5. Built-in sensors 15/12 ADC /DAC reading 5. Built-in sensors Lab4 deadline 16/12 Energy consumption 6. Energy modes 22/12 Powering the system 6. Energy modes 23/12 Firmware update Personal Project definition. Labs 5 and 6 deadline 12/01 Personal project 7. Final Project 13/01 Personal project 7. Final Project The final, personal project, will be due before 20th Jan. 2022","title":"IOTNA"},{"location":"Subjects/IOTNA/#iot-node-architecture","text":"","title":"IoT Node Architecture"},{"location":"Subjects/IOTNA/#general-information","text":"This subject will cover several topics regarding embedded system programmings. Specifically, we will learn to develop IoT projects using ESP-IDF , a framework built onto FreeRTOS . Some specific goals if this subject are: Get a global view of a safe application development cycle. Meet the main components of an IoT device Learn basic components of Real Time Operating Systems (RTOS) Work with sensors and learn the most common interfaces","title":"General information"},{"location":"Subjects/IOTNA/#subject-program-and-evaluation-methodology","text":"Program and evaluation","title":"Subject program and evaluation methodology"},{"location":"Subjects/IOTNA/#professors","text":"Jose Ignacio Gomez (jigomez@ucm.es) and Katzalin Olcoz (katzalin@ucm.es )","title":"Professors"},{"location":"Subjects/IOTNA/#work-groups","text":"Here you can find the current work groups","title":"Work groups"},{"location":"Subjects/IOTNA/#schedule","text":"Day Topic Lab instructions Deliverable 20/10 Introduction: boards, SoC C Exercises 21/10 ESP-IDF environment Online DEMO 27/10 ESP-IDF 1. Starting ESP-IDF 28/10 ESP32 Memory map 1. Starting ESP-IDF 03/11 ESP-IDF Tasks Scheduler 2. Tasks: matrix multiply 04/11 ESP-IDF Tasks Scheduler 2. Tasks: matrix multiply 10/11 Events and task notifications 2. Tasks: matrix multiply 11/11 Input/Output - Polling/Interrupts - GPIO 3. Chronometer 17/11 Timers 3. Chronometer 18/11 Event based programming 3. Chronometer Lab 2 deadline 24/11 Event based programming. NAND/NOR Flash 3. Chronometer 25/11 File system. System Log 4. Log in flash 01/12 Whatchdog and debugging 4. Log in flash Lab 3 deadline 02/12 Sensors. Serial buses: I2C 5. Built-in sensors 08/12 NO LECTURE (non working day) Spain National Holiday 09/12 Serial buses: SPI, UART 5. Built-in sensors 15/12 ADC /DAC reading 5. Built-in sensors Lab4 deadline 16/12 Energy consumption 6. Energy modes 22/12 Powering the system 6. Energy modes 23/12 Firmware update Personal Project definition. Labs 5 and 6 deadline 12/01 Personal project 7. Final Project 13/01 Personal project 7. Final Project The final, personal project, will be due before 20th Jan. 2022","title":"Schedule"},{"location":"Subjects/IOTNA/groups/","text":"Groups for lecture assignments As explained during last lectures, we will be forming stable groups to work during lectures (and after class). Group 1 Rol Full name Speaker Ayiqiqieke Kaisaier Speaker (2) Youran Tian Recorder Jun Shou Auditor TangRenJie Contributor Yang Chu Contributor Shuishi Zhou Group 2 This group is randomly assigned, since I had no notice from any of the integrants. Rol Full name Speaker BIN ZHANG Recorder FENGFENG GU Auditor GONGLU ZOU Contributor HONGBIAO CAO Contributor WENYAN LIAO Group 3 Rol Full name Speaker Duan Zhen Recorder Hu Haho Auditor Liu Jinhua Contributor Weilin Zhang Contributor Huang Yujuan Group 4 Rol Full name Speaker GuanJIE Xiao Speaker (2) DongYang Xu Recorder ShaYuan Shuang Auditor Junyan Guo Contributor Zhijun Hao Contributor Xueqing Zhao Contributor Jiali Gao Group 5 This group is randomly assigned, since I had no notice from any of the integrants. Rol Full name Speaker JIEPING YOU Recorder QINGHONG YU Auditor SUIZHI LIU Contributor TIANFENG LI Contributor WEI REN Contributor XIAZU HU Group 6 Rol Full name Speaker ZHOU Ping Speaker (2) LIAO Yinghua Recorder ZHAO Yan Auditor HE Yongtao Contributor PAN Jiayun Contributor Zhao Hu Contributor ZHANG Yi Group 7 This group is canceled. Previous members have been distributed in other groups. Group 8 Rol Full name Speaker Xiaolan Li Recorder Qiuji Chen Auditor Xionglan Luo Contributor Jianchuang Zhang","title":"Groups for lecture assignments"},{"location":"Subjects/IOTNA/groups/#groups-for-lecture-assignments","text":"As explained during last lectures, we will be forming stable groups to work during lectures (and after class).","title":"Groups for lecture assignments"},{"location":"Subjects/IOTNA/groups/#group-1","text":"Rol Full name Speaker Ayiqiqieke Kaisaier Speaker (2) Youran Tian Recorder Jun Shou Auditor TangRenJie Contributor Yang Chu Contributor Shuishi Zhou","title":"Group 1"},{"location":"Subjects/IOTNA/groups/#group-2","text":"This group is randomly assigned, since I had no notice from any of the integrants. Rol Full name Speaker BIN ZHANG Recorder FENGFENG GU Auditor GONGLU ZOU Contributor HONGBIAO CAO Contributor WENYAN LIAO","title":"Group 2"},{"location":"Subjects/IOTNA/groups/#group-3","text":"Rol Full name Speaker Duan Zhen Recorder Hu Haho Auditor Liu Jinhua Contributor Weilin Zhang Contributor Huang Yujuan","title":"Group 3"},{"location":"Subjects/IOTNA/groups/#group-4","text":"Rol Full name Speaker GuanJIE Xiao Speaker (2) DongYang Xu Recorder ShaYuan Shuang Auditor Junyan Guo Contributor Zhijun Hao Contributor Xueqing Zhao Contributor Jiali Gao","title":"Group 4"},{"location":"Subjects/IOTNA/groups/#group-5","text":"This group is randomly assigned, since I had no notice from any of the integrants. Rol Full name Speaker JIEPING YOU Recorder QINGHONG YU Auditor SUIZHI LIU Contributor TIANFENG LI Contributor WEI REN Contributor XIAZU HU","title":"Group 5"},{"location":"Subjects/IOTNA/groups/#group-6","text":"Rol Full name Speaker ZHOU Ping Speaker (2) LIAO Yinghua Recorder ZHAO Yan Auditor HE Yongtao Contributor PAN Jiayun Contributor Zhao Hu Contributor ZHANG Yi","title":"Group 6"},{"location":"Subjects/IOTNA/groups/#group-7","text":"This group is canceled. Previous members have been distributed in other groups.","title":"Group 7"},{"location":"Subjects/IOTNA/groups/#group-8","text":"Rol Full name Speaker Xiaolan Li Recorder Qiuji Chen Auditor Xionglan Luo Contributor Jianchuang Zhang","title":"Group 8"},{"location":"Subjects/IOTNA/P1/","text":"Introduction to ESP-IDF and Platform IO. First project Goals Build your first project using PlatformIO Connect your ESP32 meshkit-sense board to the computer and upload a simple application Monitor your application using the serial port Create a PlatformIO project Whenever you want to create a new project, you can add it using the PlatformIO interface. First, click the PlatformIo Home icon: From the \"PIO Home\" tab, select \"New Project\" and the Project Wizard window will show up: In that window: Write your project name (do not use white spaces) Select Espressif ESP32 Dev Module as Board Select Espressif IoT Development framework as Framework If you want to choose an ad-hoc location for your project, unselect Use default location Press Finish You are done! Your first ESP-IDF project in PlatformIO is already created. Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know. Project configuration Before proceeding with the application coding, you should configure the project so the framework knows where to find the device and how to communicate with it. There are two main options that we need to specify in the project configuration. Follow the next steps to do it; Double click the file platformio.ini to open it in the editor. By default it has three options included: platform , board , framework . We are going to include two more below those three: monitor_speed = 115200 upload_port = /tty/USB1 Note that the upload_port specified above is the one used by default in the Virtual Machine provided. If you are not using it, make sure you write the correct port name. Including source code The new project will automatically create a src folder, including a default main.c file with the following content: void app_main() { } We are going to write a very simple Hello World application. Write the following code in main.c file: #include <stdio.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" void app_main(void) { while (1) { printf(\"Hello world!\\n\"); vTaskDelay(1000 / portTICK_PERIOD_MS); } vTaskDelete(NULL); } Once you have written the source code, you can proceed to build the project. To do so, you can display the Project Tasks ( View->Command Palette ) and execute PlatformIO: Build . You could also press the Build button ( check button in the bottom pane). If the building process works ok (it may take a few minutes the first time) you should see a message similar to: Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know. Flashing the project Once we have our application built (note that our source code is linked with the whole ESP-IDF environment, including FreeRTOS ), we are ready to upload it to our ESP32 device (this operation is commonly known as flash because we will be writing the binary file in flash memory). First, plug the ESP32 MeshKit to the ESP-Prog board with the provided connection. Then, connect the microUSB wire to the corresponding ESP-Prog port and plug the USB end of the wire to your computes USB port. If you are using a virtual machine, you will need to claim the device from the virtual machine, as the host will very likely keep the device by default. Once you are done physically connecting the devices, you can proceed with the uploading. You can use the PlatformIO: Upload task from Project Tasks or click in the corresponding button of the bottom pane: Monitoring the project Finally, you can open a serial connection from your computer to the device to monitor the progress. You can select PlatformIO: Monitor from the Project Tasks or click the plug button in the bottom pane: Once done, you should see the message *Hello World\" in your screen once every second. Congrats! You have uploaded your first ESP32 project! Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know. Tasks / Homework (28/10/2021) Task Keep a snapshot of your screen at the end of every section (i.e. whenever a Stop and Sync message appears in these instructions) and paste them in a PDF file including the information of your group (names of each of the members of the group). Send the PDF file to the instructor (jigomez@ucm.es) by the end of this session (just one file per group). Homework Modify the Hello World project so that it prints 10 messages, then it waits for 5 seconds and finally restarts the system. You can find which function you could use for the reset in the official ESP-IDF documentation . Send the modified source code (only the file main.c ) to the instructor before the start of next session (just one file per group). Extra (OPTIONAL): Memory Map Our ESP32 has several memory types (details can be found in this link and with more details in the Technical Reference Manuel (Chapter 1) Most of the code will be placed in the external, flash based memory (SPI flash). But we can also used some other modules. The most relevant are: Data RAM . Global variables (non-constant) are assigned to this SRAM (Static RAM) memory. Remaining space in this region is used for the runtime heap. This space is mapped to the Internal SRAM 2 (200KB) starting at address 0x3FFA_E000 and could also use Internal SRAM 1 (128KB) starting at 0x3FFE_0000. Note that SRAM1 could be also used as instruction memory. DROM (data stored in Flash). By default, constant data is placed by the linker into a region mapped to the MMU flash cache. Instruction RAM ESP-IDF allocates part of Internal SRAM0 region for instruction RAM. It allows us to use the range 0x4008_0000 to 0x400A_0000 to store parts of the application which need to run from RAM instead of Flash (for example, interrupt handlers are good candidates since they need to run as fast as possible). In order to place code in IRAM we may use the IRAM_ATTR macro: #include \"esp_attr.h\" void IRAM_ATTR gpio_isr_handler(void* arg) { // ... } Heap memory allocation Since FreeRTOS is mult-threaded, each RTOS task has its own stack. By default, each of these stacks is allocated from the heap when the task is created. Since there are multiple types of RAM, there are also several heaps with different capabilities. Most of the time, you can rely in the standard libc calls ( malloc() , free() ....). But you may explicitly ask for certain capabilities when allocating memory using heap_caps_malloc() . Please check the documentation in this link for more details Homework (Optional) Create a new project to explore the addresses of different variables. Declare different variables: g lobal variables with initial value, global variables without initial value, global const variables, local variables (stack), allocate memory in the heap using both malloc() and heap_caps_malloc() and try to allocate some function in IRAM. Then print the address of all these symbols (variables, functions...) and check in which memories they are actually allocated.","title":"Introduction to ESP-IDF and Platform IO. First project"},{"location":"Subjects/IOTNA/P1/#introduction-to-esp-idf-and-platform-io-first-project","text":"","title":"Introduction to ESP-IDF and Platform IO. First project"},{"location":"Subjects/IOTNA/P1/#goals","text":"Build your first project using PlatformIO Connect your ESP32 meshkit-sense board to the computer and upload a simple application Monitor your application using the serial port","title":"Goals"},{"location":"Subjects/IOTNA/P1/#create-a-platformio-project","text":"Whenever you want to create a new project, you can add it using the PlatformIO interface. First, click the PlatformIo Home icon: From the \"PIO Home\" tab, select \"New Project\" and the Project Wizard window will show up: In that window: Write your project name (do not use white spaces) Select Espressif ESP32 Dev Module as Board Select Espressif IoT Development framework as Framework If you want to choose an ad-hoc location for your project, unselect Use default location Press Finish You are done! Your first ESP-IDF project in PlatformIO is already created. Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know.","title":"Create a PlatformIO project"},{"location":"Subjects/IOTNA/P1/#project-configuration","text":"Before proceeding with the application coding, you should configure the project so the framework knows where to find the device and how to communicate with it. There are two main options that we need to specify in the project configuration. Follow the next steps to do it; Double click the file platformio.ini to open it in the editor. By default it has three options included: platform , board , framework . We are going to include two more below those three: monitor_speed = 115200 upload_port = /tty/USB1 Note that the upload_port specified above is the one used by default in the Virtual Machine provided. If you are not using it, make sure you write the correct port name.","title":"Project configuration"},{"location":"Subjects/IOTNA/P1/#including-source-code","text":"The new project will automatically create a src folder, including a default main.c file with the following content: void app_main() { } We are going to write a very simple Hello World application. Write the following code in main.c file: #include <stdio.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" void app_main(void) { while (1) { printf(\"Hello world!\\n\"); vTaskDelay(1000 / portTICK_PERIOD_MS); } vTaskDelete(NULL); } Once you have written the source code, you can proceed to build the project. To do so, you can display the Project Tasks ( View->Command Palette ) and execute PlatformIO: Build . You could also press the Build button ( check button in the bottom pane). If the building process works ok (it may take a few minutes the first time) you should see a message similar to: Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know.","title":"Including source code"},{"location":"Subjects/IOTNA/P1/#flashing-the-project","text":"Once we have our application built (note that our source code is linked with the whole ESP-IDF environment, including FreeRTOS ), we are ready to upload it to our ESP32 device (this operation is commonly known as flash because we will be writing the binary file in flash memory). First, plug the ESP32 MeshKit to the ESP-Prog board with the provided connection. Then, connect the microUSB wire to the corresponding ESP-Prog port and plug the USB end of the wire to your computes USB port. If you are using a virtual machine, you will need to claim the device from the virtual machine, as the host will very likely keep the device by default. Once you are done physically connecting the devices, you can proceed with the uploading. You can use the PlatformIO: Upload task from Project Tasks or click in the corresponding button of the bottom pane:","title":"Flashing the project"},{"location":"Subjects/IOTNA/P1/#monitoring-the-project","text":"Finally, you can open a serial connection from your computer to the device to monitor the progress. You can select PlatformIO: Monitor from the Project Tasks or click the plug button in the bottom pane: Once done, you should see the message *Hello World\" in your screen once every second. Congrats! You have uploaded your first ESP32 project! Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know.","title":"Monitoring the project"},{"location":"Subjects/IOTNA/P1/#tasks-homework-28102021","text":"Task Keep a snapshot of your screen at the end of every section (i.e. whenever a Stop and Sync message appears in these instructions) and paste them in a PDF file including the information of your group (names of each of the members of the group). Send the PDF file to the instructor (jigomez@ucm.es) by the end of this session (just one file per group). Homework Modify the Hello World project so that it prints 10 messages, then it waits for 5 seconds and finally restarts the system. You can find which function you could use for the reset in the official ESP-IDF documentation . Send the modified source code (only the file main.c ) to the instructor before the start of next session (just one file per group).","title":"Tasks / Homework (28/10/2021)"},{"location":"Subjects/IOTNA/P1/#extra-optional-memory-map","text":"Our ESP32 has several memory types (details can be found in this link and with more details in the Technical Reference Manuel (Chapter 1) Most of the code will be placed in the external, flash based memory (SPI flash). But we can also used some other modules. The most relevant are: Data RAM . Global variables (non-constant) are assigned to this SRAM (Static RAM) memory. Remaining space in this region is used for the runtime heap. This space is mapped to the Internal SRAM 2 (200KB) starting at address 0x3FFA_E000 and could also use Internal SRAM 1 (128KB) starting at 0x3FFE_0000. Note that SRAM1 could be also used as instruction memory. DROM (data stored in Flash). By default, constant data is placed by the linker into a region mapped to the MMU flash cache. Instruction RAM ESP-IDF allocates part of Internal SRAM0 region for instruction RAM. It allows us to use the range 0x4008_0000 to 0x400A_0000 to store parts of the application which need to run from RAM instead of Flash (for example, interrupt handlers are good candidates since they need to run as fast as possible). In order to place code in IRAM we may use the IRAM_ATTR macro: #include \"esp_attr.h\" void IRAM_ATTR gpio_isr_handler(void* arg) { // ... }","title":"Extra (OPTIONAL): Memory Map"},{"location":"Subjects/IOTNA/P1/#heap-memory-allocation","text":"Since FreeRTOS is mult-threaded, each RTOS task has its own stack. By default, each of these stacks is allocated from the heap when the task is created. Since there are multiple types of RAM, there are also several heaps with different capabilities. Most of the time, you can rely in the standard libc calls ( malloc() , free() ....). But you may explicitly ask for certain capabilities when allocating memory using heap_caps_malloc() . Please check the documentation in this link for more details Homework (Optional) Create a new project to explore the addresses of different variables. Declare different variables: g lobal variables with initial value, global variables without initial value, global const variables, local variables (stack), allocate memory in the heap using both malloc() and heap_caps_malloc() and try to allocate some function in IRAM. Then print the address of all these symbols (variables, functions...) and check in which memories they are actually allocated.","title":"Heap memory allocation"},{"location":"Subjects/IOTNA/P2/","text":"Task management in FreeRTOS (ESP-IDF) Goals Learn the task related API offered by ESP-IDF Create multi-tasked applications where tasks effectively cooperate to a common goal. Matrix multiplication Matrix multiplication is a key kernel in many applications (for example, in Neural Network training and inference). It is an example of a massively parallel computation, where all the elements of the output matrix ( C in the image below) can be computed in parallel. The most basic pseudo-code of the matrix multiplication is shown below: for i = 0 to N for j = 0 to M C[i][j] = 0 for k=0 to K C[i][j] += A[i][k]*B[k][j] where loops i and j are fully parallel. Assignment 1 Create a new project and write a function that will multiply two matrix (received as input arguments) and write the result in a third matrix (also provided as argument). You can choose N=8, M= 8, K =8 and uint32_t as element type. To make it easier to check the output, you can initialize B matrix as the identity matrix. Please send a message to the professor as soon as you finished Simple parallelisation In this exercise you will create two tasks. The first task will process the even rows of A ( i=0,2,4,6... ) and the second task will take care of the even rows. The main task (the one executing app_main() ) will simply create both task and then destroy itself. Assignment 2 Create a new project and implement the simple parallelization. Check the result with your previous sequential version. Please send a message to the professor as soon as you finished Work dispatching In this last (optional) exercise, you will implement a different parallelisation strategy: a Controller task ) will write pairs in a queue (from 0 to N-1). A set of Worker tasks will read from that queue, obtain one pair and multiply row i of matrix A by column j of matrix B, and write the result as element [i,j] of matrix C. The Controller task will insert all the pairs in the queue and then wait in a semaphore for the Worker tasks to complete. Homework (Optional) Create a new project and implement this alternative. Try creating a different number of Worker tasks (from 1 to 4, for example) and measure the execution time. You may use esp_timer_get_time() to compute the total time.","title":"Task management in FreeRTOS (ESP-IDF)"},{"location":"Subjects/IOTNA/P2/#task-management-in-freertos-esp-idf","text":"","title":"Task management in FreeRTOS (ESP-IDF)"},{"location":"Subjects/IOTNA/P2/#goals","text":"Learn the task related API offered by ESP-IDF Create multi-tasked applications where tasks effectively cooperate to a common goal.","title":"Goals"},{"location":"Subjects/IOTNA/P2/#matrix-multiplication","text":"Matrix multiplication is a key kernel in many applications (for example, in Neural Network training and inference). It is an example of a massively parallel computation, where all the elements of the output matrix ( C in the image below) can be computed in parallel. The most basic pseudo-code of the matrix multiplication is shown below: for i = 0 to N for j = 0 to M C[i][j] = 0 for k=0 to K C[i][j] += A[i][k]*B[k][j] where loops i and j are fully parallel. Assignment 1 Create a new project and write a function that will multiply two matrix (received as input arguments) and write the result in a third matrix (also provided as argument). You can choose N=8, M= 8, K =8 and uint32_t as element type. To make it easier to check the output, you can initialize B matrix as the identity matrix. Please send a message to the professor as soon as you finished","title":"Matrix multiplication"},{"location":"Subjects/IOTNA/P2/#simple-parallelisation","text":"In this exercise you will create two tasks. The first task will process the even rows of A ( i=0,2,4,6... ) and the second task will take care of the even rows. The main task (the one executing app_main() ) will simply create both task and then destroy itself. Assignment 2 Create a new project and implement the simple parallelization. Check the result with your previous sequential version. Please send a message to the professor as soon as you finished","title":"Simple parallelisation"},{"location":"Subjects/IOTNA/P2/#work-dispatching","text":"In this last (optional) exercise, you will implement a different parallelisation strategy: a Controller task ) will write pairs in a queue (from 0 to N-1). A set of Worker tasks will read from that queue, obtain one pair and multiply row i of matrix A by column j of matrix B, and write the result as element [i,j] of matrix C. The Controller task will insert all the pairs in the queue and then wait in a semaphore for the Worker tasks to complete. Homework (Optional) Create a new project and implement this alternative. Try creating a different number of Worker tasks (from 1 to 4, for example) and measure the execution time. You may use esp_timer_get_time() to compute the total time.","title":"Work dispatching"},{"location":"Subjects/IOTNA/P3/","text":"Basic Input/output in ESP-IDF Goals Learn the basics of input/output, using polling and interrupts Configuring and use GPIO pins as input/output Program timers to schedule periodic events Documentation To complete this assignment, you may need to check the slides discuss in the lectures and the official API documentation: GPIO * Timers Using GPIO Checking connections The first step when using external peripherals connected to our SoC (ESP32) is to learn how are they connected. The module exposes a series of pines from the core and the operating system (ESP-IDF) assigns them a number. We need then to find out which pin number correspond to every relevant connection to us. In this fist step, you must find out the GPIO number for the button and LED. The information is usually included in the documentation of the SoC and the board: we need to check both, the SoC and the board. In our case, part of the information may be found in the brief online documentation . If you don't find all the information there, try to look it up carefully in the board itself. Sometimes, this information is printed on the PCB... Simple GPIO polling: button The next step will be to set up the button to use it as an input for our system. First, you will need to configure the GPIO pin: Configure the pin as INPUT. Disable interrupts. Enable pull-ip mode. Check the slides and documentation to learn how to do this configuration in ESP-IDF. Remember that you need to declare a variable of type gpio_config_t , assign the relevant fields of such variable and finally call gpio_config( ) to complete the configuration. Once the configuration of the GPIO is done, you can write a simple sampling loop. Write and endless while loop where you poll the status of the button, print a message if the button is pressed and wait for 250ms before polling again. A pseudo-code for such loop could be the following: while (1) { int status = gpio_get_level(GPIO_BUTTON_PIN); if (status == BUTTON_PRESSED) printf(\"Button pressed!!\\n\"); delay(250); } GPIO input and output: button + LED In the next step, you will configure a GPIO pin as an output in order to control the LEDs. Similar to the button configuration, the first step is to configure the respective pins (there are two LEDs available): Configure the pin(s) as OUTPUT. Disable interrupts. Disable pull-up and pull-down modes. Remember to use a variable of type gpio_config_t and complete the configuration with a call to gpio_config( ) . Once both the three pins (one input, two outputs) are correctly configured, you will develop a very simple program that will switch one of the LEDs (on/off) every time the button is pressed. The pseudo-code may be similar to: while (1) { int status = gpio_get_level(GPIO_BUTTON_PIN); if (status == BUTTON_PRESSED) { if LED_IS_ON gpio_set_level(GPIO_LED_PIN, OFF); else gpio_set_level(GPIO_LED_PIN, ON); } delay(250); } Stop and sync Please send a message in Zoom chat to the professor as soon as you finished GPIO interrupts In this subsection you will change the polling mechanism and use interrupts instead. Starting from the configuration you already have for the button GPIO pin, you need to do certain modifications: Enable interrupts (for example, POSEDGE ). You may change the edge/level later using gpio_set_intr_type() . Register the ISR that will be executed when the interrupt rises. You will need to call gpio_install_isr_service() and gpio_isr_handler_add . Once the new configuration is done, you need to write the ISR for the button interrupts. Remember to use the correct protoype: static void IRAM_ATTR gpio_isr_handler(void* arg) (you may change the name of the ISR itself, but not its prototype). Finally, adapt the previous code (LED switching) to work with the new code. How are you going to notify you main loop about a new interrupt? Extending button functionality Just to play a bit longer with interrupts, let's extend the functionality of our application. Adapt your code so you can identify if the button was pressed normally or if it was hold at least for 4 seconds: If the button was just pressed (less than 4 seconds) you will switch the green LED. If the button was pressed and hold for more than 4 seconds, you will switch the red LED. Note that, if both LEDs are on, you will see a yellow light. Stop and sync Please send a message (using Zoom) to the professor as soon as you finished. Timers Now we will include timers in our design. Read again the slides and API documentation to remember how to declare and configure a timer in ESP-IDF. LED blink Then, create a timer that will blink the red LED every second (i.e. the red LED will be on for one second, then off for another second and so on). The green LED will still be controlled with the button (but keep your code detecting when the button was pressed for more than 4 seconds; you will use it later). Controlling blinking frequency We will define several blinking periods: 500ms, 1s or 2s. When your program starts, the red LED will be blinking every 500ms. Then, your code must do the following: When the button is pressed, the period will increase, first to 1 second, then to 2 seconds. If the button is pressed when the period is already 2 seconds, nothing changes. When the button is held pressed for more than 4 seconds, the period will decrease (from 2s to 1s and then to 500ms). If the button is held pressed for more than 4 seconds when the period is 500ms, nothing changes. Stop and sync All previous exercises must be finished DURING the lecture (not afterwards) and shown to the teacher during the Zoom meeting. AFTER they are shown to be working during the lecture, the Recorder of the group will send an email with the source code of the last section ( Controlling blinking frequency ). Remind that plagiarism is strictly prohibited: the code of each group must be solely developed by members of that group. Chronometer (optional) This assignment is optional, but required if you want to obtain more than 6 / 10 in this assignment. You will need to implement a simple chronometer with the following functionality: The chronometer counts minutes and seconds. Pressing the button starts/stops counting. Holding pressed the button for more than 4 seconds resets the count to 0. Every second, the actual count (in a format MM:SS) will be shown in the terminal (using printf() ). Homework (Optional) Implement the chronometer using, at least, one timer . Once finished, the Speaker will contact me to explain (orally) the code developed","title":"Basic Input/output in ESP-IDF"},{"location":"Subjects/IOTNA/P3/#basic-inputoutput-in-esp-idf","text":"","title":"Basic Input/output in ESP-IDF"},{"location":"Subjects/IOTNA/P3/#goals","text":"Learn the basics of input/output, using polling and interrupts Configuring and use GPIO pins as input/output Program timers to schedule periodic events","title":"Goals"},{"location":"Subjects/IOTNA/P3/#documentation","text":"To complete this assignment, you may need to check the slides discuss in the lectures and the official API documentation: GPIO * Timers","title":"Documentation"},{"location":"Subjects/IOTNA/P3/#using-gpio","text":"","title":"Using GPIO"},{"location":"Subjects/IOTNA/P3/#checking-connections","text":"The first step when using external peripherals connected to our SoC (ESP32) is to learn how are they connected. The module exposes a series of pines from the core and the operating system (ESP-IDF) assigns them a number. We need then to find out which pin number correspond to every relevant connection to us. In this fist step, you must find out the GPIO number for the button and LED. The information is usually included in the documentation of the SoC and the board: we need to check both, the SoC and the board. In our case, part of the information may be found in the brief online documentation . If you don't find all the information there, try to look it up carefully in the board itself. Sometimes, this information is printed on the PCB...","title":"Checking connections"},{"location":"Subjects/IOTNA/P3/#simple-gpio-polling-button","text":"The next step will be to set up the button to use it as an input for our system. First, you will need to configure the GPIO pin: Configure the pin as INPUT. Disable interrupts. Enable pull-ip mode. Check the slides and documentation to learn how to do this configuration in ESP-IDF. Remember that you need to declare a variable of type gpio_config_t , assign the relevant fields of such variable and finally call gpio_config( ) to complete the configuration. Once the configuration of the GPIO is done, you can write a simple sampling loop. Write and endless while loop where you poll the status of the button, print a message if the button is pressed and wait for 250ms before polling again. A pseudo-code for such loop could be the following: while (1) { int status = gpio_get_level(GPIO_BUTTON_PIN); if (status == BUTTON_PRESSED) printf(\"Button pressed!!\\n\"); delay(250); }","title":"Simple GPIO polling: button"},{"location":"Subjects/IOTNA/P3/#gpio-input-and-output-button-led","text":"In the next step, you will configure a GPIO pin as an output in order to control the LEDs. Similar to the button configuration, the first step is to configure the respective pins (there are two LEDs available): Configure the pin(s) as OUTPUT. Disable interrupts. Disable pull-up and pull-down modes. Remember to use a variable of type gpio_config_t and complete the configuration with a call to gpio_config( ) . Once both the three pins (one input, two outputs) are correctly configured, you will develop a very simple program that will switch one of the LEDs (on/off) every time the button is pressed. The pseudo-code may be similar to: while (1) { int status = gpio_get_level(GPIO_BUTTON_PIN); if (status == BUTTON_PRESSED) { if LED_IS_ON gpio_set_level(GPIO_LED_PIN, OFF); else gpio_set_level(GPIO_LED_PIN, ON); } delay(250); } Stop and sync Please send a message in Zoom chat to the professor as soon as you finished","title":"GPIO input and output: button + LED"},{"location":"Subjects/IOTNA/P3/#gpio-interrupts","text":"In this subsection you will change the polling mechanism and use interrupts instead. Starting from the configuration you already have for the button GPIO pin, you need to do certain modifications: Enable interrupts (for example, POSEDGE ). You may change the edge/level later using gpio_set_intr_type() . Register the ISR that will be executed when the interrupt rises. You will need to call gpio_install_isr_service() and gpio_isr_handler_add . Once the new configuration is done, you need to write the ISR for the button interrupts. Remember to use the correct protoype: static void IRAM_ATTR gpio_isr_handler(void* arg) (you may change the name of the ISR itself, but not its prototype). Finally, adapt the previous code (LED switching) to work with the new code. How are you going to notify you main loop about a new interrupt?","title":"GPIO interrupts"},{"location":"Subjects/IOTNA/P3/#extending-button-functionality","text":"Just to play a bit longer with interrupts, let's extend the functionality of our application. Adapt your code so you can identify if the button was pressed normally or if it was hold at least for 4 seconds: If the button was just pressed (less than 4 seconds) you will switch the green LED. If the button was pressed and hold for more than 4 seconds, you will switch the red LED. Note that, if both LEDs are on, you will see a yellow light. Stop and sync Please send a message (using Zoom) to the professor as soon as you finished.","title":"Extending button functionality"},{"location":"Subjects/IOTNA/P3/#timers","text":"Now we will include timers in our design. Read again the slides and API documentation to remember how to declare and configure a timer in ESP-IDF.","title":"Timers"},{"location":"Subjects/IOTNA/P3/#led-blink","text":"Then, create a timer that will blink the red LED every second (i.e. the red LED will be on for one second, then off for another second and so on). The green LED will still be controlled with the button (but keep your code detecting when the button was pressed for more than 4 seconds; you will use it later).","title":"LED blink"},{"location":"Subjects/IOTNA/P3/#controlling-blinking-frequency","text":"We will define several blinking periods: 500ms, 1s or 2s. When your program starts, the red LED will be blinking every 500ms. Then, your code must do the following: When the button is pressed, the period will increase, first to 1 second, then to 2 seconds. If the button is pressed when the period is already 2 seconds, nothing changes. When the button is held pressed for more than 4 seconds, the period will decrease (from 2s to 1s and then to 500ms). If the button is held pressed for more than 4 seconds when the period is 500ms, nothing changes. Stop and sync All previous exercises must be finished DURING the lecture (not afterwards) and shown to the teacher during the Zoom meeting. AFTER they are shown to be working during the lecture, the Recorder of the group will send an email with the source code of the last section ( Controlling blinking frequency ). Remind that plagiarism is strictly prohibited: the code of each group must be solely developed by members of that group.","title":"Controlling blinking frequency"},{"location":"Subjects/IOTNA/P3/#chronometer-optional","text":"This assignment is optional, but required if you want to obtain more than 6 / 10 in this assignment. You will need to implement a simple chronometer with the following functionality: The chronometer counts minutes and seconds. Pressing the button starts/stops counting. Holding pressed the button for more than 4 seconds resets the count to 0. Every second, the actual count (in a format MM:SS) will be shown in the terminal (using printf() ). Homework (Optional) Implement the chronometer using, at least, one timer . Once finished, the Speaker will contact me to explain (orally) the code developed","title":"Chronometer (optional)"},{"location":"Subjects/IOTNA/P4/","text":"Logging and flash filesystem Goals Learn the logging mechanisms provided by ESP-IDF Create your own partitions in SPI FLASH memory Mount a filesystem in FLASH memory Documentation To complete this assignment, you may need to check the slides discuss in the lectures and the official API documentation: Log SPI Flash and partitions FAT filesystem Wear levelling API Logging to UART Basic logging Start from your basic (single-task) matrix multiply code (Lab 2). Insert ESP_LOG calls at least at 3 levels: ERROR, INFO and VERBOSE. Modify logging level via menuconfig Use menuconfig to select INFO as the minimum log level. Check that the VERBOSE messages are not shown Multimodule Create a new .c file in your project. Include there a couple of functions from your code. Remind to declare. a new TAG there. Include LOG macros in both files. Modify logging level at runtime Use esp_log_level_set() to set WARNING as the log level for the main file and VERBOSE for the other file. Check that the log output is correct. Stop and sync All previous exercises must be finished DURING the lecture (not afterwards) and shown to the teacher during the Zoom meeting. AFTER they are shown to be working during the lecture, the Recorder of the group will send an email with the source code of the last section ( Modify logging level at runtime ). Remind that plagiarism is strictly prohibited: the code of each group must be solely developed by members of that group. Mounting FAT filesystem In this step you will mount a FAT filesystem in a new partition created in the SPI FLASH existing in the board. Follow the example Wear Levelling ( [wear levelling example])https://github.com/espressif/esp-idf/tree/master/examples/storage/wear_levelling) ) and create a PlatformIO project to run it in your board: Create the PlatformIO project and copy the source code from the Wear Levelling example. Copy the file partitions_example.csv in the root folder of your project. Rename it as partitions.csv Modify the file platformio.ini to include: monitor_port = /dev/ttyUSB1 upload_port = /dev/ttyUSB1 board_build.partitions = partitions.csv Run menuconfig (type pio run -t menuconfig in a PlatformIO terminal) Partition Table --> PartitionTable --> Custom partition table CSV Check that the name of the Custom parition CSV file in menuconfig is partitions.csv Save the new configuration (press S ) and quit (press Q ) Build, upload and execute. Monitor the output and check that the messages are the ones expected. Questions Once you finished the code, try to answer the following questions. Include them in the report of this assignment. What is the name of the file you are creating in this example? What is the path of the file? Why? When was that folder created? What is the difference between printf() and fprintf() Why there are two calls to `fopen()? What is the difference between them? What is fgets() doing? Write a code that creates a new file called timestamp.txt whose content is a timestamp (time elapsed since boot). How can we later modify its content? Try to open a file after the call \u00e8sp_vfs_fat_spiflash_umount()*. What happens? Redirecting the log to FLASH (optional) To be done.","title":"Logging and flash filesystem"},{"location":"Subjects/IOTNA/P4/#logging-and-flash-filesystem","text":"","title":"Logging and flash filesystem"},{"location":"Subjects/IOTNA/P4/#goals","text":"Learn the logging mechanisms provided by ESP-IDF Create your own partitions in SPI FLASH memory Mount a filesystem in FLASH memory","title":"Goals"},{"location":"Subjects/IOTNA/P4/#documentation","text":"To complete this assignment, you may need to check the slides discuss in the lectures and the official API documentation: Log SPI Flash and partitions FAT filesystem Wear levelling API","title":"Documentation"},{"location":"Subjects/IOTNA/P4/#logging-to-uart","text":"","title":"Logging to UART"},{"location":"Subjects/IOTNA/P4/#basic-logging","text":"Start from your basic (single-task) matrix multiply code (Lab 2). Insert ESP_LOG calls at least at 3 levels: ERROR, INFO and VERBOSE.","title":"Basic logging"},{"location":"Subjects/IOTNA/P4/#modify-logging-level-via-menuconfig","text":"Use menuconfig to select INFO as the minimum log level. Check that the VERBOSE messages are not shown","title":"Modify logging level via menuconfig"},{"location":"Subjects/IOTNA/P4/#multimodule","text":"Create a new .c file in your project. Include there a couple of functions from your code. Remind to declare. a new TAG there. Include LOG macros in both files.","title":"Multimodule"},{"location":"Subjects/IOTNA/P4/#modify-logging-level-at-runtime","text":"Use esp_log_level_set() to set WARNING as the log level for the main file and VERBOSE for the other file. Check that the log output is correct. Stop and sync All previous exercises must be finished DURING the lecture (not afterwards) and shown to the teacher during the Zoom meeting. AFTER they are shown to be working during the lecture, the Recorder of the group will send an email with the source code of the last section ( Modify logging level at runtime ). Remind that plagiarism is strictly prohibited: the code of each group must be solely developed by members of that group.","title":"Modify logging level at runtime"},{"location":"Subjects/IOTNA/P4/#mounting-fat-filesystem","text":"In this step you will mount a FAT filesystem in a new partition created in the SPI FLASH existing in the board. Follow the example Wear Levelling ( [wear levelling example])https://github.com/espressif/esp-idf/tree/master/examples/storage/wear_levelling) ) and create a PlatformIO project to run it in your board: Create the PlatformIO project and copy the source code from the Wear Levelling example. Copy the file partitions_example.csv in the root folder of your project. Rename it as partitions.csv Modify the file platformio.ini to include: monitor_port = /dev/ttyUSB1 upload_port = /dev/ttyUSB1 board_build.partitions = partitions.csv Run menuconfig (type pio run -t menuconfig in a PlatformIO terminal) Partition Table --> PartitionTable --> Custom partition table CSV Check that the name of the Custom parition CSV file in menuconfig is partitions.csv Save the new configuration (press S ) and quit (press Q ) Build, upload and execute. Monitor the output and check that the messages are the ones expected. Questions Once you finished the code, try to answer the following questions. Include them in the report of this assignment. What is the name of the file you are creating in this example? What is the path of the file? Why? When was that folder created? What is the difference between printf() and fprintf() Why there are two calls to `fopen()? What is the difference between them? What is fgets() doing? Write a code that creates a new file called timestamp.txt whose content is a timestamp (time elapsed since boot). How can we later modify its content? Try to open a file after the call \u00e8sp_vfs_fat_spiflash_umount()*. What happens?","title":"Mounting FAT filesystem"},{"location":"Subjects/IOTNA/P4/#redirecting-the-log-to-flash-optional","text":"To be done.","title":"Redirecting the log to FLASH (optional)"},{"location":"Subjects/IOTNA/P5/","text":"Lab 5.Using built-in sensors Goals Under construction","title":"Lab 5.Using built-in sensors"},{"location":"Subjects/IOTNA/P5/#lab-5using-built-in-sensors","text":"","title":"Lab 5.Using built-in sensors"},{"location":"Subjects/IOTNA/P5/#goals","text":"Under construction","title":"Goals"},{"location":"Subjects/IOTNA/P6/","text":"Lab 6. Energy saving modes Goals Under construction","title":"Lab 6. Energy saving modes"},{"location":"Subjects/IOTNA/P6/#lab-6-energy-saving-modes","text":"","title":"Lab 6. Energy saving modes"},{"location":"Subjects/IOTNA/P6/#goals","text":"Under construction","title":"Goals"},{"location":"Subjects/IOTNA/P7/","text":"Final Project Under construction","title":"Final Project"},{"location":"Subjects/IOTNA/P7/#final-project","text":"Under construction","title":"Final Project"},{"location":"Subjects/IOTNA/ctutorial/","text":"C programming. Exercises There are many good C/C++ tutorials online. You can find one in this link . Next, there are several examples that we will use during the lectures to talk about different aspects of C language. You can download a ZIP with the examples here Compilation (headers, macros...) #include <stdio.h> /******** QUESTIONS/TASKS ***** * 1. Compile and execute the code * 2. Later, apply only the preprocessor (-E flag) and redirect the output * to a file called hello.i * 3. What happened to the call min()? * 4. What did the directive #include <stdio.h> produced? *****************/ #define N 5 #define min(x,y) ( (x<y)?x:y ) int a = 7; int b = 9; int main() { char* cad = \"Hello world\"; int i; for (i=0;i<N;i++) { printf(\"%s \\t a= %d b= %d\\n\",cad,a,b); a++; a = min(a,b); } return 0; } Data types. Sizes #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the first \"printf\" prints different values for the same variable 'a'? * 2. How large is a 'char' variable? * 3. Why the value of 'a' changes that much when adding 1? * 4. If \"long\" and \"double\" have the same size, what's the difference? *****/ char a = 127; int b = 41; int main() { printf(\"a = %d a = %c \\n\", a,a); a++; printf(\"a = %d a = %c b=%d b=%c\\n\", a,a,b,b); printf(\"Size of int: %lu\\n\",sizeof(int ) ); printf(\"Size of char: %lu\\n\",sizeof( char) ); printf(\"Size of float: %lu\\n\",sizeof(float ) ); printf(\"Size of double: %lu\\n\",sizeof( double) ); printf(\"Size of long: %lu\\n\",sizeof(long ) ); printf(\"Size of short: %lu\\n\",sizeof( short) ); printf(\"Size of void*: %lu\\n\",sizeof( void*) ); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Is there a compilation problem or a execution problem? * 2. Why is it complaining? Fix it and compila again. * 3. a,b,c, y x are declared one after the other. Are their addresses consecutive in memory? * 4. What does the modifier \"%lu\" means in printf()? * 5. Which address is \"pc\" pointed to? Is the address of any other variable? Are those two the same size? * 6. Does the size of \"array1\" matches the number of elements? Why? * 7. Do \"cadena1\" and \"cadena2 \"point to the same address? * 8. Why sizes (according to sizeof()) of cadena1 and cadena2 are different? *************/ #define ARRAY_SIZE 10 int a = 7; unsigned long b = 8; short c; char x; char* pc; int array1[ARRAY_SIZE]; int array2[a]; char* cadena1 = \"CADENA DE CARACTERES\"; char cadena2[] = \"CADENA DE CARACTERES\"; int main() { pc =&x; a = 16; printf(\"Adress of a: %p Tam: %lu \\n\",&a,sizeof(a)); printf(\"Adress of b: %p Tam: %lu \\n\",&b,sizeof(b)); printf(\"Adress of c: %p Tam: %lu \\n\",&c,sizeof(c)); printf(\"Adress of x: %p Tam: %lu \\n\",&x,sizeof(x)); printf(\"Adress of pc: %p Adress pointed by pc: %p Tam: %lu \\n\",&pc,pc,sizeof(pc)); printf(\"Adress of array: %p Adress of elem 0: %p Tam de array: %lu \\n\",array1, &array1[0], sizeof(array1)); printf(\"Adress of cadena1: %p Adress pointed by: %p Tam: %lu \\n\",&cadena1,cadena1,sizeof(cadena1)); printf(\"Adress of cadena2: %p DAdress pointed by: %p Tam: %lu \\n\",&cadena2,cadena2,sizeof(cadena2)); return 0; } Using Arrays. #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Should we use \"&list\" to get the address of the array? * 2. What is actually stored in the address of \"list\"? * 3. Why are we including the lentgh of the array as parameter to \"init_array\"? * 4. Why the sizeof() output is different for the array in \"init_array\" and the one in main()? * 5. Why aren't we including a second parameter in init_array2? * 6. Do sizeof() outuput now match with the array in init_array2()? ***************/ #define N 5 void init_array(int array[], int size) ; void init_array2(int array[N]); int main(void) { int i,list[N]; printf(\"Dir de list %p Dir de list[0]: %p Dir de list[1]: %p. Sizeof list %lu \\n\",list,&list[0],&list[1],sizeof(list)); init_array(list, N); for (i = 0; i < N; i++) printf(\"next: %d \", list[i]); printf(\"\\n-------------------------\\n\"); init_array2(list); for (i = 0; i < N; i++) printf(\"next: %d \", list[i]); printf(\"\\n-------------------------\\n\"); } void init_array(int array[], int size) { int i; printf(\"Direccion de array: %p Sizeof array %lu \\n\", array, sizeof(array)); for (i = 0; i < size; i++) array[i] = i; printf(\"Array initialized\\n\\n\"); } void init_array2(int array[N]) { int i; printf(\"Direccion de array: %p Sizeof array %lu \\n\", array, sizeof(array)); for (i = 0; i < N; i++) array[i] = i*2; printf(\"Array initialized\\n\\n\"); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Does the copy of the array works? Why? * 2. Fix it. * 3. Uncommnet the call to function \"tom\". Compile again and execute. * 4. The problem that arises, is it in compilation or execution time? Why? * 5. Find a value for MAXVALID (greater than 4) when the problem does not happen. Why does it work? *******************/ #define N 10 #define MAXELEM 5000 #define MAXVALID 100 void printArray(int v[],int size) { int i; printf(\"-------------------\\n\"); for (i=0;i<size;i++) printf(\"%d \",v[i]); printf(\"\\n\\n\"); } void copyArray(int src[],int dst[],int size) { dst = src; } void tmo() { int x = -1; int a[4] = {0,1,2,3}; int b = 10000; int c = -1; int i; for (i=4;i<MAXVALID;i++) a[i]=i; printf(\"x %d b %d c %d\\n\", x,b,c); } int main() { int A[N] = {4,3,8,5,6,9,0,1,7,2}; int B[N]; //tmo(); copyArray(A,B,N); printArray(B,N); } Pointers #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Which operand should we use to declae a variable as a ponter? * 2. How do we obtain the address of a variable? * 3. How do we read/write into the address pointed by a pointer? * 4. There \u00a1s a bug in the code. Is it a compile-time or executiontime errror? Why does it happen? ***********/ int c = 7; int main(void) { int *ptr; printf(\"Address of ptr %p. ptr apunta a %p. Address of c: %p Valor of c %d\\n\",&ptr,ptr,&c,c); ptr = &c; printf(\"Address of ptr %p,. ptr apunta a %p. Address of c: %p Value of c %d\\n\",&ptr,ptr,&c,c); *ptr=4; printf(\"ptr apunta a %p. Content of address of ptr: %d Address of c: %p Value of c %d\\n\",ptr,*ptr,&c,c); ptr = (int*) 0x600a48; printf(\"Address of ptr %p. Value of c %d\\n\",ptr,c); *ptr =13; printf(\"Address of ptr %p. Value of c %d\\n\",ptr,c); return 0; } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. How many bytes are allocated in memory with the malloc() call? * 2. Which are the addresses of the first and last bytes of the allocated area? * 3. Why the content of the address pointed by \"ptr\" is 7 and not 5 in the first printf()? * 4. Why the content of ptrg[1] is modified after the sentence *ptr2=15 ? * 5. Suggest two different ways of writting the value 13 in the address of ptr[100] * 6. There is a bug in the code. Even if nothing goes wrong,the bug is there. Where? * ***********/ int nelem; int main(void) { int *ptr; int * ptr2; nelem = 127; ptr = (int*) malloc(nelem*sizeof(int)); *ptr = 5; ptr[0] = 7; ptr2 = ptr; printf(\"Address pointed by ptr %p. Content of that address: %d \\n\",ptr,*ptr); ptr[1] = 10; printf(\"Address pointed by ptr[1] %p. Content of that address: %d \\n\",&ptr[1],ptr[1]); ptr2++; *ptr2 = 15; printf(\"Address pointed by ptr[1] %p. Content of that address: %d \\n\",&ptr[1],ptr[1]); free(ptr); *ptr = 3; printf(\"Address pointed by ptr %p. Content of that address: %d \\n\",ptr,*ptr); } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the value of ptr[13] is changed after the sentence ptr = &c; * 2. This code has (at least) one bug. Compile or run-timer error? Why? * 3. What happens with the memory allocated by malloc() after the assignment ptr=&c? * How can we reach that memory again? How can we free it? * ***********/ int nelem; int c; int main(void) { int *ptr; int i; c = 37; nelem = 127; ptr = (int*) malloc(nelem*sizeof(int)); for (i=0; i<nelem; i++) ptr[i] = i; printf(\"ptr[0]= %d ptr[13]=%d \\n\",ptr[0],ptr[13]); ptr = &c; printf(\"ptr[0]= %d ptr[13]=%d \\n\",ptr[0],ptr[13]); free(ptr); } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the second printf() prints a different value for 'd'? * 2. What is 'f'? A variable? A function? * 3. Use the function 'opera()' to perform the first addition. Then, use it again to perform a substraction. * 4. Using typedef, build a type called ptrToFunc with the same prototype thatn 'f' * 5. Creat a function 'choose()' that will return, alternatively, a pointer to \"add()\" and \"sub()\" * every time it is called * ***********/ int add (int x, int y); int sub(int x, int y); int (*f)(int a, int b); int add(int x, int y) { return x+y; } int sub(int x, int y) { return x-y; } int opera(int x, int y, int (*g)(int, int)) { return g(x,y); } int main(void) { int a = 12; int b = 8; int c,d; f = add; c = add(a,b); d = f(a,b); printf(\"c = %d d= %d \\n\",c,d); f = sub; d = f(a,b); printf(\"c = %d d= %d \\n\",c,d); } Arguments #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the value of 'xc' is not changed after the call to sumC()? * Where do the write operations happen? * 2. Comment the two forwarded declarations of sum() and sumC(). Compile again. What happens? *******************/ /* Struct type */ struct _complex_ { float re; float im; }; /* Forward declarations */ int sum(int a, int b); struct _complex_ sumC( struct _complex_ a, struct _complex_ b); int main(void){ int x = 4,y = 5; struct _complex_ xc = {.re = 1.0, .im = 2.0}; struct _complex_ yc = {.re = 3.0, .im = 1.0}; struct _complex_ zc; zc = sumC(xc,yc); int total = sum(x,y); printf(\"Suma de complejos. (%f,%f i) + (%f,%f i) =(%f,%f i)\\n\",xc.re,xc.im,yc.re,yc.im,zc.re,zc.im); printf(\"Suma de enteros: x +y = %d + %d = %d \\n\",x,y, total); return 0; } int sum(int x, int y) { int c; c = x +y; x = 7; y =3; return c; } struct _complex_ sumC( struct _complex_ a, struct _complex_ b) { struct _complex_ r; r.re = a.re + b.re; r.im = a.im + b.im; // Try to change the first parameter a.re = 12.5; a.im = 13.4; return r; } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why does the value of 'y' changes after the call to sum()? * 2. Why sometimes we use operator '.' and other times '->'? * 3. Why the vauue of 'zc' gets wrong without further using it in the code? * 4. Fix the code to avoid the bug in 'zc' shown in previous point *******************/ struct _complex_ { float re; float im; }; int sum(int *pa, int *pb); struct _complex_ * sumC( struct _complex_ *a, struct _complex_ *b); int main(void){ int x = 4,y = 5; int* ptr = &y; struct _complex_ xc = {.re = 1.0, .im = 2.0}; struct _complex_ yc = {.re = 3.0, .im = 1.0}; struct _complex_ *zc; printf(\"Complex addition (%f,%f i) + (%f,%f i) = \", xc.re,xc.im,yc.re,yc.im); zc = sumC(&xc,&yc); printf(\"(%f,%f i)\\n\",zc->re,zc->im); int total = sum(&x,ptr); printf(\"Complex addition: x +y = %d + %d = %d \\n\",x,y, total); printf(\"xc = (%f,%f i) yc = (%f,%f i) zc = (%f,%f i)\\n\",xc.re,xc.im,yc.re,yc.im,zc->re,zc->im); return 0; } int sum(int *pa, int *pb) { /* args passed by reference */ int c = *pa + *pb; int buf[256] = {0}; *pa = 7; *pb = 8; return c; /* return by value */ } struct _complex_ * sumC( struct _complex_* a, struct _complex_* b) { struct _complex_ r; r.re = a->re + b->re; r.im = a->im + b->im; a->re = 12.5; a->im = 13.4; return &r; } Strings #include <stdio.h> #include <string.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. The code has a bug. Compile or run-time? Why? * Fix the bug commenting the line(s) that produce it. Compile and execute again. * 2. Which is the address of letter 'B' in the chain \"Bonjour\"? And letter 'j'? * 3. After the assignment p=msg2; how can we get back the address of \"Bonjour\"? * 4. Why the length of strings 'p' and 'msg2' are 2 after the third assignment? * 3 bytes are assigned to 'p', but then the length is only 2 !! * 5. Why strlen() returns a different value than sizeof()? * 6. Why the string stored in 'msg' in line 36 is bad-printed in the last printf()? ************** */ int main() { char msg[10]; /* array of 10 chars */ char *p; /* pointer to a char */ char msg2[28]=\"Hello\"; /* msg2 = 'H' 'e' 'l' 'l' 'o' '\\0' */ p = \"Bonjour\"; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"dir de msg: %p, dir de p: %p, dir de msg2: %p\\n\",msg,p,msg2); p = msg2; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"dir de msg: %p, dir de p: %p, dir de msg2: %p\\n\",msg,p,msg2); p[0] = 'H', p[1] = 'i',p[2]='\\0'; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"msg len: %lu p len %lu msg2 len %lu\\n\", strlen(msg),strlen(p),strlen(msg2)); printf(\"msg size: %lu p size %lu msg2 size %lu\\n\", sizeof(msg),sizeof(p),sizeof(msg2)); msg[0] = 'B', msg[1] = 'y'; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); msg = \"Goodbye\"; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); } #include <stdio.h> #include <string.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. The code of fcuntion 'copy' does not work. Why? * 2. Use now 'copy2()'. Does the copy actually work? * 3. Suggest a valid implementation for a copy * 4. What does function \"mod\" do? * 5. Uncomment last line of code (call to mod()). Compile and execute. Why is there an error now? ************** */ void copy2(char* org, char** dst) { *dst = org; } void copy(char* org, char* dst) { dst = org; } void mod(char* org, char* dst) { int i; for (i=0;i<strlen(org);i++) dst[i] = org[i] - 32; } int main() { char* cad1 = \"original\"; char* cad2 = \"other\"; char cad3[32]; copy(cad1,cad2); //copy2(cad1,&cad2); printf(\"cad1 %s cad2 %s\\n\", cad1,cad2); mod(cad1,cad3); printf(\"cad1 %s cad3 %s\\n\", cad1,cad3); //mod(cad1,cad1); } Bitwaise operations #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * Study the syntax of the different bit-level operators * and make sure you understand the result of every operation ************** */ int a,b,c; int main() { a = 7; b = 9; c = a & b; printf(\"%x AND %x = %x\\n\",a,b,c); c= a | b; printf(\"%x OR %x = %x\\n\",a,b,c); c = a ^ b; printf(\"%x XOR %x = %x\\n\",a,b,c); c = ~a; printf(\"NOT %x = %x\\n\",a,c); c = a << 2; printf(\" %x << 2 = %x\\n\",a,c); c = a >> 1; printf(\" %x >> 1 = %x\\n\",a,c); c = a & 0xFB; printf(\" %x bit 2 to 0 -> %x\\n\",a,c); c = a | 0x40; printf(\" %x bit 6 to 1 -> %x\\n\",a,c); c = (a & 0x1C) >> 2; printf(\"bits 4-3-2 of %x: %x\\n\",a,c); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the assignment using pointer 'p' does not overwrite completely 'a'? * 2. How is modified the address pointed by 'p' after the assignment p=p+1 * 3. How would it be different if 'p' is declared as 'short *' * ************** */ int a = 3; int b; char * p; int c; int main() { printf(\"a = %x Address of a: %p \\n\",a,&a); p = (char*) &a; p=p+1; *p= 0x1f; printf(\"a = %x. Address pointed by p:%p \\n\",a,p); a = 3; b = 0x00001f00; a= a | b; printf(\"a = %x. Address pointed by p:%p \\n\",a,p); }","title":"C programming. Exercises"},{"location":"Subjects/IOTNA/ctutorial/#c-programming-exercises","text":"There are many good C/C++ tutorials online. You can find one in this link . Next, there are several examples that we will use during the lectures to talk about different aspects of C language. You can download a ZIP with the examples here","title":"C programming. Exercises"},{"location":"Subjects/IOTNA/ctutorial/#compilation-headers-macros","text":"#include <stdio.h> /******** QUESTIONS/TASKS ***** * 1. Compile and execute the code * 2. Later, apply only the preprocessor (-E flag) and redirect the output * to a file called hello.i * 3. What happened to the call min()? * 4. What did the directive #include <stdio.h> produced? *****************/ #define N 5 #define min(x,y) ( (x<y)?x:y ) int a = 7; int b = 9; int main() { char* cad = \"Hello world\"; int i; for (i=0;i<N;i++) { printf(\"%s \\t a= %d b= %d\\n\",cad,a,b); a++; a = min(a,b); } return 0; }","title":"Compilation (headers, macros...)"},{"location":"Subjects/IOTNA/ctutorial/#data-types-sizes","text":"#include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the first \"printf\" prints different values for the same variable 'a'? * 2. How large is a 'char' variable? * 3. Why the value of 'a' changes that much when adding 1? * 4. If \"long\" and \"double\" have the same size, what's the difference? *****/ char a = 127; int b = 41; int main() { printf(\"a = %d a = %c \\n\", a,a); a++; printf(\"a = %d a = %c b=%d b=%c\\n\", a,a,b,b); printf(\"Size of int: %lu\\n\",sizeof(int ) ); printf(\"Size of char: %lu\\n\",sizeof( char) ); printf(\"Size of float: %lu\\n\",sizeof(float ) ); printf(\"Size of double: %lu\\n\",sizeof( double) ); printf(\"Size of long: %lu\\n\",sizeof(long ) ); printf(\"Size of short: %lu\\n\",sizeof( short) ); printf(\"Size of void*: %lu\\n\",sizeof( void*) ); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Is there a compilation problem or a execution problem? * 2. Why is it complaining? Fix it and compila again. * 3. a,b,c, y x are declared one after the other. Are their addresses consecutive in memory? * 4. What does the modifier \"%lu\" means in printf()? * 5. Which address is \"pc\" pointed to? Is the address of any other variable? Are those two the same size? * 6. Does the size of \"array1\" matches the number of elements? Why? * 7. Do \"cadena1\" and \"cadena2 \"point to the same address? * 8. Why sizes (according to sizeof()) of cadena1 and cadena2 are different? *************/ #define ARRAY_SIZE 10 int a = 7; unsigned long b = 8; short c; char x; char* pc; int array1[ARRAY_SIZE]; int array2[a]; char* cadena1 = \"CADENA DE CARACTERES\"; char cadena2[] = \"CADENA DE CARACTERES\"; int main() { pc =&x; a = 16; printf(\"Adress of a: %p Tam: %lu \\n\",&a,sizeof(a)); printf(\"Adress of b: %p Tam: %lu \\n\",&b,sizeof(b)); printf(\"Adress of c: %p Tam: %lu \\n\",&c,sizeof(c)); printf(\"Adress of x: %p Tam: %lu \\n\",&x,sizeof(x)); printf(\"Adress of pc: %p Adress pointed by pc: %p Tam: %lu \\n\",&pc,pc,sizeof(pc)); printf(\"Adress of array: %p Adress of elem 0: %p Tam de array: %lu \\n\",array1, &array1[0], sizeof(array1)); printf(\"Adress of cadena1: %p Adress pointed by: %p Tam: %lu \\n\",&cadena1,cadena1,sizeof(cadena1)); printf(\"Adress of cadena2: %p DAdress pointed by: %p Tam: %lu \\n\",&cadena2,cadena2,sizeof(cadena2)); return 0; }","title":"Data types. Sizes"},{"location":"Subjects/IOTNA/ctutorial/#using-arrays","text":"#include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Should we use \"&list\" to get the address of the array? * 2. What is actually stored in the address of \"list\"? * 3. Why are we including the lentgh of the array as parameter to \"init_array\"? * 4. Why the sizeof() output is different for the array in \"init_array\" and the one in main()? * 5. Why aren't we including a second parameter in init_array2? * 6. Do sizeof() outuput now match with the array in init_array2()? ***************/ #define N 5 void init_array(int array[], int size) ; void init_array2(int array[N]); int main(void) { int i,list[N]; printf(\"Dir de list %p Dir de list[0]: %p Dir de list[1]: %p. Sizeof list %lu \\n\",list,&list[0],&list[1],sizeof(list)); init_array(list, N); for (i = 0; i < N; i++) printf(\"next: %d \", list[i]); printf(\"\\n-------------------------\\n\"); init_array2(list); for (i = 0; i < N; i++) printf(\"next: %d \", list[i]); printf(\"\\n-------------------------\\n\"); } void init_array(int array[], int size) { int i; printf(\"Direccion de array: %p Sizeof array %lu \\n\", array, sizeof(array)); for (i = 0; i < size; i++) array[i] = i; printf(\"Array initialized\\n\\n\"); } void init_array2(int array[N]) { int i; printf(\"Direccion de array: %p Sizeof array %lu \\n\", array, sizeof(array)); for (i = 0; i < N; i++) array[i] = i*2; printf(\"Array initialized\\n\\n\"); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Does the copy of the array works? Why? * 2. Fix it. * 3. Uncommnet the call to function \"tom\". Compile again and execute. * 4. The problem that arises, is it in compilation or execution time? Why? * 5. Find a value for MAXVALID (greater than 4) when the problem does not happen. Why does it work? *******************/ #define N 10 #define MAXELEM 5000 #define MAXVALID 100 void printArray(int v[],int size) { int i; printf(\"-------------------\\n\"); for (i=0;i<size;i++) printf(\"%d \",v[i]); printf(\"\\n\\n\"); } void copyArray(int src[],int dst[],int size) { dst = src; } void tmo() { int x = -1; int a[4] = {0,1,2,3}; int b = 10000; int c = -1; int i; for (i=4;i<MAXVALID;i++) a[i]=i; printf(\"x %d b %d c %d\\n\", x,b,c); } int main() { int A[N] = {4,3,8,5,6,9,0,1,7,2}; int B[N]; //tmo(); copyArray(A,B,N); printArray(B,N); }","title":"Using Arrays."},{"location":"Subjects/IOTNA/ctutorial/#pointers","text":"#include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Which operand should we use to declae a variable as a ponter? * 2. How do we obtain the address of a variable? * 3. How do we read/write into the address pointed by a pointer? * 4. There \u00a1s a bug in the code. Is it a compile-time or executiontime errror? Why does it happen? ***********/ int c = 7; int main(void) { int *ptr; printf(\"Address of ptr %p. ptr apunta a %p. Address of c: %p Valor of c %d\\n\",&ptr,ptr,&c,c); ptr = &c; printf(\"Address of ptr %p,. ptr apunta a %p. Address of c: %p Value of c %d\\n\",&ptr,ptr,&c,c); *ptr=4; printf(\"ptr apunta a %p. Content of address of ptr: %d Address of c: %p Value of c %d\\n\",ptr,*ptr,&c,c); ptr = (int*) 0x600a48; printf(\"Address of ptr %p. Value of c %d\\n\",ptr,c); *ptr =13; printf(\"Address of ptr %p. Value of c %d\\n\",ptr,c); return 0; } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. How many bytes are allocated in memory with the malloc() call? * 2. Which are the addresses of the first and last bytes of the allocated area? * 3. Why the content of the address pointed by \"ptr\" is 7 and not 5 in the first printf()? * 4. Why the content of ptrg[1] is modified after the sentence *ptr2=15 ? * 5. Suggest two different ways of writting the value 13 in the address of ptr[100] * 6. There is a bug in the code. Even if nothing goes wrong,the bug is there. Where? * ***********/ int nelem; int main(void) { int *ptr; int * ptr2; nelem = 127; ptr = (int*) malloc(nelem*sizeof(int)); *ptr = 5; ptr[0] = 7; ptr2 = ptr; printf(\"Address pointed by ptr %p. Content of that address: %d \\n\",ptr,*ptr); ptr[1] = 10; printf(\"Address pointed by ptr[1] %p. Content of that address: %d \\n\",&ptr[1],ptr[1]); ptr2++; *ptr2 = 15; printf(\"Address pointed by ptr[1] %p. Content of that address: %d \\n\",&ptr[1],ptr[1]); free(ptr); *ptr = 3; printf(\"Address pointed by ptr %p. Content of that address: %d \\n\",ptr,*ptr); } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the value of ptr[13] is changed after the sentence ptr = &c; * 2. This code has (at least) one bug. Compile or run-timer error? Why? * 3. What happens with the memory allocated by malloc() after the assignment ptr=&c? * How can we reach that memory again? How can we free it? * ***********/ int nelem; int c; int main(void) { int *ptr; int i; c = 37; nelem = 127; ptr = (int*) malloc(nelem*sizeof(int)); for (i=0; i<nelem; i++) ptr[i] = i; printf(\"ptr[0]= %d ptr[13]=%d \\n\",ptr[0],ptr[13]); ptr = &c; printf(\"ptr[0]= %d ptr[13]=%d \\n\",ptr[0],ptr[13]); free(ptr); } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the second printf() prints a different value for 'd'? * 2. What is 'f'? A variable? A function? * 3. Use the function 'opera()' to perform the first addition. Then, use it again to perform a substraction. * 4. Using typedef, build a type called ptrToFunc with the same prototype thatn 'f' * 5. Creat a function 'choose()' that will return, alternatively, a pointer to \"add()\" and \"sub()\" * every time it is called * ***********/ int add (int x, int y); int sub(int x, int y); int (*f)(int a, int b); int add(int x, int y) { return x+y; } int sub(int x, int y) { return x-y; } int opera(int x, int y, int (*g)(int, int)) { return g(x,y); } int main(void) { int a = 12; int b = 8; int c,d; f = add; c = add(a,b); d = f(a,b); printf(\"c = %d d= %d \\n\",c,d); f = sub; d = f(a,b); printf(\"c = %d d= %d \\n\",c,d); }","title":"Pointers"},{"location":"Subjects/IOTNA/ctutorial/#arguments","text":"#include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the value of 'xc' is not changed after the call to sumC()? * Where do the write operations happen? * 2. Comment the two forwarded declarations of sum() and sumC(). Compile again. What happens? *******************/ /* Struct type */ struct _complex_ { float re; float im; }; /* Forward declarations */ int sum(int a, int b); struct _complex_ sumC( struct _complex_ a, struct _complex_ b); int main(void){ int x = 4,y = 5; struct _complex_ xc = {.re = 1.0, .im = 2.0}; struct _complex_ yc = {.re = 3.0, .im = 1.0}; struct _complex_ zc; zc = sumC(xc,yc); int total = sum(x,y); printf(\"Suma de complejos. (%f,%f i) + (%f,%f i) =(%f,%f i)\\n\",xc.re,xc.im,yc.re,yc.im,zc.re,zc.im); printf(\"Suma de enteros: x +y = %d + %d = %d \\n\",x,y, total); return 0; } int sum(int x, int y) { int c; c = x +y; x = 7; y =3; return c; } struct _complex_ sumC( struct _complex_ a, struct _complex_ b) { struct _complex_ r; r.re = a.re + b.re; r.im = a.im + b.im; // Try to change the first parameter a.re = 12.5; a.im = 13.4; return r; } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why does the value of 'y' changes after the call to sum()? * 2. Why sometimes we use operator '.' and other times '->'? * 3. Why the vauue of 'zc' gets wrong without further using it in the code? * 4. Fix the code to avoid the bug in 'zc' shown in previous point *******************/ struct _complex_ { float re; float im; }; int sum(int *pa, int *pb); struct _complex_ * sumC( struct _complex_ *a, struct _complex_ *b); int main(void){ int x = 4,y = 5; int* ptr = &y; struct _complex_ xc = {.re = 1.0, .im = 2.0}; struct _complex_ yc = {.re = 3.0, .im = 1.0}; struct _complex_ *zc; printf(\"Complex addition (%f,%f i) + (%f,%f i) = \", xc.re,xc.im,yc.re,yc.im); zc = sumC(&xc,&yc); printf(\"(%f,%f i)\\n\",zc->re,zc->im); int total = sum(&x,ptr); printf(\"Complex addition: x +y = %d + %d = %d \\n\",x,y, total); printf(\"xc = (%f,%f i) yc = (%f,%f i) zc = (%f,%f i)\\n\",xc.re,xc.im,yc.re,yc.im,zc->re,zc->im); return 0; } int sum(int *pa, int *pb) { /* args passed by reference */ int c = *pa + *pb; int buf[256] = {0}; *pa = 7; *pb = 8; return c; /* return by value */ } struct _complex_ * sumC( struct _complex_* a, struct _complex_* b) { struct _complex_ r; r.re = a->re + b->re; r.im = a->im + b->im; a->re = 12.5; a->im = 13.4; return &r; }","title":"Arguments"},{"location":"Subjects/IOTNA/ctutorial/#strings","text":"#include <stdio.h> #include <string.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. The code has a bug. Compile or run-time? Why? * Fix the bug commenting the line(s) that produce it. Compile and execute again. * 2. Which is the address of letter 'B' in the chain \"Bonjour\"? And letter 'j'? * 3. After the assignment p=msg2; how can we get back the address of \"Bonjour\"? * 4. Why the length of strings 'p' and 'msg2' are 2 after the third assignment? * 3 bytes are assigned to 'p', but then the length is only 2 !! * 5. Why strlen() returns a different value than sizeof()? * 6. Why the string stored in 'msg' in line 36 is bad-printed in the last printf()? ************** */ int main() { char msg[10]; /* array of 10 chars */ char *p; /* pointer to a char */ char msg2[28]=\"Hello\"; /* msg2 = 'H' 'e' 'l' 'l' 'o' '\\0' */ p = \"Bonjour\"; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"dir de msg: %p, dir de p: %p, dir de msg2: %p\\n\",msg,p,msg2); p = msg2; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"dir de msg: %p, dir de p: %p, dir de msg2: %p\\n\",msg,p,msg2); p[0] = 'H', p[1] = 'i',p[2]='\\0'; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"msg len: %lu p len %lu msg2 len %lu\\n\", strlen(msg),strlen(p),strlen(msg2)); printf(\"msg size: %lu p size %lu msg2 size %lu\\n\", sizeof(msg),sizeof(p),sizeof(msg2)); msg[0] = 'B', msg[1] = 'y'; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); msg = \"Goodbye\"; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); } #include <stdio.h> #include <string.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. The code of fcuntion 'copy' does not work. Why? * 2. Use now 'copy2()'. Does the copy actually work? * 3. Suggest a valid implementation for a copy * 4. What does function \"mod\" do? * 5. Uncomment last line of code (call to mod()). Compile and execute. Why is there an error now? ************** */ void copy2(char* org, char** dst) { *dst = org; } void copy(char* org, char* dst) { dst = org; } void mod(char* org, char* dst) { int i; for (i=0;i<strlen(org);i++) dst[i] = org[i] - 32; } int main() { char* cad1 = \"original\"; char* cad2 = \"other\"; char cad3[32]; copy(cad1,cad2); //copy2(cad1,&cad2); printf(\"cad1 %s cad2 %s\\n\", cad1,cad2); mod(cad1,cad3); printf(\"cad1 %s cad3 %s\\n\", cad1,cad3); //mod(cad1,cad1); }","title":"Strings"},{"location":"Subjects/IOTNA/ctutorial/#bitwaise-operations","text":"#include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * Study the syntax of the different bit-level operators * and make sure you understand the result of every operation ************** */ int a,b,c; int main() { a = 7; b = 9; c = a & b; printf(\"%x AND %x = %x\\n\",a,b,c); c= a | b; printf(\"%x OR %x = %x\\n\",a,b,c); c = a ^ b; printf(\"%x XOR %x = %x\\n\",a,b,c); c = ~a; printf(\"NOT %x = %x\\n\",a,c); c = a << 2; printf(\" %x << 2 = %x\\n\",a,c); c = a >> 1; printf(\" %x >> 1 = %x\\n\",a,c); c = a & 0xFB; printf(\" %x bit 2 to 0 -> %x\\n\",a,c); c = a | 0x40; printf(\" %x bit 6 to 1 -> %x\\n\",a,c); c = (a & 0x1C) >> 2; printf(\"bits 4-3-2 of %x: %x\\n\",a,c); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the assignment using pointer 'p' does not overwrite completely 'a'? * 2. How is modified the address pointed by 'p' after the assignment p=p+1 * 3. How would it be different if 'p' is declared as 'short *' * ************** */ int a = 3; int b; char * p; int c; int main() { printf(\"a = %x Address of a: %p \\n\",a,&a); p = (char*) &a; p=p+1; *p= 0x1f; printf(\"a = %x. Address pointed by p:%p \\n\",a,p); a = 3; b = 0x00001f00; a= a | b; printf(\"a = %x. Address pointed by p:%p \\n\",a,p); }","title":"Bitwaise operations"},{"location":"Subjects/IOTNA/demo/","text":"Introduction to ESP-IDF and Platform IO (demo) Goals Meet the IDE we will be using during the Master: native ESP-IDF and the tool PlatformIO Learn how to run the virtual machine and install the environments Learn how to connect our ESP32 board to the computer and upload a binary Using the Virtual Machine We have provided a virtual machine with some of the tools we will be using already installed. Note that you can install everything natively in your system, and I will run faster. We provide the virtual machine just in case you prefer not to install new software in your own computer. You can download the OVA file from Google Drive or Baidu Netdisk (with code 7spz). An OVA file contains a OVF (Open Virtualizaion Format) file so it can be opened in any virtualization framework. During the course, we will be using Oracle VM Virtualbox which is a free and open-source hosted hypervisor for x86 virtualization. In order to run the virtual machine just follow the steps: Download Virtual Box from this link . Install Virtual Box in your machine. Download the OVA file provided. Import the OVA file from Virtual Box (Use \"Import\" or \"Import Appliance\" from the File menu. Do not just drag the OVA file in the Virtual Box window) After importing the virtual machine is imported it should be listed in Virtual Box screen (the one named MIOT_VM_2022_CN ) Now, you can run the virtual machine. We have installed a recent version of Ubuntu operating system (Ubuntu 20.04.1 LTS). There is a sinlge user (named Ubuntu) whose password is ubuntu (small-caps). Launching Visual Studio Code and PlatformIO During this online demo, I will show you how to use Visual Studio Code and the PlatformIO plugin to create a new project, compile it and upload it to our board. You can install this environment in your own machine, which is recommended since virtualization introduces some overheads. You can download Visual Studio Code from this link . Once installed, you can easily install the PlatformIO plugin from the Extensions: Marketplace in the same Visual Studio Code window: Installing the native ESP-IDF environment There is an alternative to PlatformIO: installing the native Espressif environment for ESP-IDF. You have all the steps to install and setup their environment in this link Just a summary of the information there provided (please check the website, because it could be updated), we include here the most relevant steps for the environment installation in the Ubuntu terminal machine. Open a Terminal and make sure your package system is up to date: sudo apt update sudo apt upgrade Run the following command to install the pre-requisites (note that you will be using sudo to run it with superuser privileges. The user Ubuntu has sudo privileges, so just use the same password as before when required: ubuntu ). sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util If you are installing the environment in your own Linux machine, make sure your user is also in the dilaout group. Install Python 3 and make it the default distribution: sudo apt-get install python3 python3-pip python3-setuptools sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 Obtain ESP-IDF sources. We will install it under a folder called esp mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git pull git submodule update --init --recursive Now you can proceed to install the environment by using the provided script in esp-idf folder. This should be done only once. sh install.sh Every time you are to use the environment after opening a new Terminal, you should export some environment variables by running the export script provided in the esp-idf folder: . ./export.sh You are now ready to use the environment. idf.py is the front-end tool for everything: compiling, flashing , monitoring... You can now check the installed version by running: $ idf.py --version ESP-IDF v4.xxxxx","title":"Introduction to ESP-IDF and Platform IO (demo)"},{"location":"Subjects/IOTNA/demo/#introduction-to-esp-idf-and-platform-io-demo","text":"","title":"Introduction to ESP-IDF and Platform IO (demo)"},{"location":"Subjects/IOTNA/demo/#goals","text":"Meet the IDE we will be using during the Master: native ESP-IDF and the tool PlatformIO Learn how to run the virtual machine and install the environments Learn how to connect our ESP32 board to the computer and upload a binary","title":"Goals"},{"location":"Subjects/IOTNA/demo/#using-the-virtual-machine","text":"We have provided a virtual machine with some of the tools we will be using already installed. Note that you can install everything natively in your system, and I will run faster. We provide the virtual machine just in case you prefer not to install new software in your own computer. You can download the OVA file from Google Drive or Baidu Netdisk (with code 7spz). An OVA file contains a OVF (Open Virtualizaion Format) file so it can be opened in any virtualization framework. During the course, we will be using Oracle VM Virtualbox which is a free and open-source hosted hypervisor for x86 virtualization. In order to run the virtual machine just follow the steps: Download Virtual Box from this link . Install Virtual Box in your machine. Download the OVA file provided. Import the OVA file from Virtual Box (Use \"Import\" or \"Import Appliance\" from the File menu. Do not just drag the OVA file in the Virtual Box window) After importing the virtual machine is imported it should be listed in Virtual Box screen (the one named MIOT_VM_2022_CN ) Now, you can run the virtual machine. We have installed a recent version of Ubuntu operating system (Ubuntu 20.04.1 LTS). There is a sinlge user (named Ubuntu) whose password is ubuntu (small-caps).","title":"Using the Virtual Machine"},{"location":"Subjects/IOTNA/demo/#launching-visual-studio-code-and-platformio","text":"During this online demo, I will show you how to use Visual Studio Code and the PlatformIO plugin to create a new project, compile it and upload it to our board. You can install this environment in your own machine, which is recommended since virtualization introduces some overheads. You can download Visual Studio Code from this link . Once installed, you can easily install the PlatformIO plugin from the Extensions: Marketplace in the same Visual Studio Code window:","title":"Launching Visual Studio Code and PlatformIO"},{"location":"Subjects/IOTNA/demo/#installing-the-native-esp-idf-environment","text":"There is an alternative to PlatformIO: installing the native Espressif environment for ESP-IDF. You have all the steps to install and setup their environment in this link Just a summary of the information there provided (please check the website, because it could be updated), we include here the most relevant steps for the environment installation in the Ubuntu terminal machine. Open a Terminal and make sure your package system is up to date: sudo apt update sudo apt upgrade Run the following command to install the pre-requisites (note that you will be using sudo to run it with superuser privileges. The user Ubuntu has sudo privileges, so just use the same password as before when required: ubuntu ). sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util If you are installing the environment in your own Linux machine, make sure your user is also in the dilaout group. Install Python 3 and make it the default distribution: sudo apt-get install python3 python3-pip python3-setuptools sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 Obtain ESP-IDF sources. We will install it under a folder called esp mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git pull git submodule update --init --recursive Now you can proceed to install the environment by using the provided script in esp-idf folder. This should be done only once. sh install.sh Every time you are to use the environment after opening a new Terminal, you should export some environment variables by running the export script provided in the esp-idf folder: . ./export.sh You are now ready to use the environment. idf.py is the front-end tool for everything: compiling, flashing , monitoring... You can now check the installed version by running: $ idf.py --version ESP-IDF v4.xxxxx","title":"Installing the native ESP-IDF environment"},{"location":"Subjects/MDM/","text":"Massive Data Management All the information and documentation about Massive Data Management (MDM) can be found in this link","title":"MDM"},{"location":"Subjects/MDM/#massive-data-management","text":"All the information and documentation about Massive Data Management (MDM) can be found in this link","title":"Massive Data Management"},{"location":"Subjects/NP1/","text":"NP1","title":"NP1"},{"location":"Subjects/NP2/","text":"Networks and Protocols 2 General information This subject will cover different topics about application-level communication APIs, standard and interfaces, with special emphasis on Internet of Things inter-communication. Specifically, we will cover both Linux and ESP-IDF programming on the ESP32, to fulfill the following specific goals: Get a global overview of the necessities and particularities of IoT from the application communication perspective. Advocate for open standards for IoT communication. Introduce the concept of Smart Object, and study how it can be ported to different APIs and languages. Introduce different techniques for information representation. Study a number of IoT frameworks and stream processing platforms. Professors Francisco Igual (figual@ucm.es) Schedule Lab Day Topic 1 XX/XX TCP/UDP Sockets (Linux) 2 XX/XX TCP/UDP Sockets (ESP32) 3 XX/XX TLS and DTLS 4 XX/XX Websockets 5 XX/XX REST servers and information representation (JSON and CBOR) 6 XX/XX MQTT (I) 6 XX/XX MQTT (II) 7 XX/XX CoAP 8 XX/XX LWM2M (I) 8 XX/XX LWM2M (II) 9 XX/XX Node-RED 10 XX/XX Cloud environments/IoT Frameworks","title":"NP2"},{"location":"Subjects/NP2/#networks-and-protocols-2","text":"","title":"Networks and Protocols 2"},{"location":"Subjects/NP2/#general-information","text":"This subject will cover different topics about application-level communication APIs, standard and interfaces, with special emphasis on Internet of Things inter-communication. Specifically, we will cover both Linux and ESP-IDF programming on the ESP32, to fulfill the following specific goals: Get a global overview of the necessities and particularities of IoT from the application communication perspective. Advocate for open standards for IoT communication. Introduce the concept of Smart Object, and study how it can be ported to different APIs and languages. Introduce different techniques for information representation. Study a number of IoT frameworks and stream processing platforms.","title":"General information"},{"location":"Subjects/NP2/#professors","text":"Francisco Igual (figual@ucm.es)","title":"Professors"},{"location":"Subjects/NP2/#schedule","text":"Lab Day Topic 1 XX/XX TCP/UDP Sockets (Linux) 2 XX/XX TCP/UDP Sockets (ESP32) 3 XX/XX TLS and DTLS 4 XX/XX Websockets 5 XX/XX REST servers and information representation (JSON and CBOR) 6 XX/XX MQTT (I) 6 XX/XX MQTT (II) 7 XX/XX CoAP 8 XX/XX LWM2M (I) 8 XX/XX LWM2M (II) 9 XX/XX Node-RED 10 XX/XX Cloud environments/IoT Frameworks","title":"Schedule"},{"location":"Subjects/NP2/P1/","text":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python Objetivos Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Implementar servidores multi-hilo en Python. Introducci\u00f3n La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT. La API de sockets en Python El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase . Sockets TCP En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo. Cliente/servidor echo TCP Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente. Servidor echo #!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with . Cliente echo Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla. Ejecuci\u00f3n del cliente y servidor echo A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor-echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente-echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor-echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n. Herramientas para observar el estado del socket Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida. Capturas de tr\u00e1fico v\u00eda Wireshark Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s. Sockets UDP La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado. Env\u00edo de datos binarios a trav\u00e9s de sockets Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias. Tarea entregable Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte. Ejemplo de sistema cliente/servidor multi-hilo Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su dise\u00f1o de una caracter\u00edstica esencial: el servidor deja de atender peticiones entrantes mientras trata cada nuevo env\u00edo por parte del cliente. Los siguientes ejemplos muestran implementaciones sencillas con soporte multi-hilo para un sistema cliente/servidor escrito en Python. # Servidor TCP concurrente import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"Nueva conexion anyadida: \", clientAddress) def run(self): print (\"Conexion desde: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"Desde el cliente\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Cliente \", clientAddress , \" desconectado...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Servidor arrancado...\") print(\"Esperando petici\u00f3n de clientes...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # Cliente TCP. El env\u00edo de la cadena bye indica petici\u00f3n de desconexi\u00f3n. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hola, soy un cliente!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"Desde el servidor :\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Tarea Estudia el c\u00f3digo del servidor concurrente y observa c\u00f3mo gestiona la creaci\u00f3n de hilos para atender cada petici\u00f3n entrante. Conecta simult\u00e1neamente m\u00faltiples clientes y observa el estado de los sockets mediante las herramientas correspondientes. Tarea entregable opcional Tarea entregable opcional Modifica tu primer entregable para considerar una implementaci\u00f3n multihilo del servidor TCP, siguiendo las directrices de los c\u00f3digos de ejemplo anteriormente proporcionados. Tarea entregable opcional Tarea entregable opcional Modifica el protocolo de env\u00edo para que tu aplicaci\u00f3n cliente/servidor UDP garantice en la medida de lo posible la recepci\u00f3n de los paquetes enviados desde el cliente, as\u00ed como su recepci\u00f3n en orden. Vuelve a analizar el tr\u00e1fico necesario en este caso comparado con una comunicaci\u00f3n b\u00e1sica basada en TCP (donde s\u00ed se garantizan, a nivel de transporte, dichas caracter\u00edsticas).","title":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python"},{"location":"Subjects/NP2/P1/#practica-1-programacion-con-sockets-en-python","text":"","title":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python"},{"location":"Subjects/NP2/P1/#objetivos","text":"Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Implementar servidores multi-hilo en Python.","title":"Objetivos"},{"location":"Subjects/NP2/P1/#introduccion","text":"La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT.","title":"Introducci\u00f3n"},{"location":"Subjects/NP2/P1/#la-api-de-sockets-en-python","text":"El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase .","title":"La API de sockets en Python"},{"location":"Subjects/NP2/P1/#sockets-tcp","text":"En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo.","title":"Sockets TCP"},{"location":"Subjects/NP2/P1/#clienteservidor-echo-tcp","text":"Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente.","title":"Cliente/servidor echo TCP"},{"location":"Subjects/NP2/P1/#servidor-echo","text":"#!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with .","title":"Servidor echo"},{"location":"Subjects/NP2/P1/#cliente-echo","text":"Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla.","title":"Cliente echo"},{"location":"Subjects/NP2/P1/#ejecucion-del-cliente-y-servidor-echo","text":"A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor-echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente-echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor-echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n.","title":"Ejecuci\u00f3n del cliente y servidor echo"},{"location":"Subjects/NP2/P1/#herramientas-para-observar-el-estado-del-socket","text":"Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida.","title":"Herramientas para observar el estado del socket"},{"location":"Subjects/NP2/P1/#capturas-de-trafico-via-wireshark","text":"Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s.","title":"Capturas de tr\u00e1fico v\u00eda Wireshark"},{"location":"Subjects/NP2/P1/#sockets-udp","text":"La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado.","title":"Sockets UDP"},{"location":"Subjects/NP2/P1/#envio-de-datos-binarios-a-traves-de-sockets","text":"Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias.","title":"Env\u00edo de datos binarios a trav\u00e9s de sockets"},{"location":"Subjects/NP2/P1/#tarea-entregable","text":"Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte.","title":"Tarea entregable"},{"location":"Subjects/NP2/P1/#ejemplo-de-sistema-clienteservidor-multi-hilo","text":"Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su dise\u00f1o de una caracter\u00edstica esencial: el servidor deja de atender peticiones entrantes mientras trata cada nuevo env\u00edo por parte del cliente. Los siguientes ejemplos muestran implementaciones sencillas con soporte multi-hilo para un sistema cliente/servidor escrito en Python. # Servidor TCP concurrente import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"Nueva conexion anyadida: \", clientAddress) def run(self): print (\"Conexion desde: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"Desde el cliente\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Cliente \", clientAddress , \" desconectado...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Servidor arrancado...\") print(\"Esperando petici\u00f3n de clientes...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # Cliente TCP. El env\u00edo de la cadena bye indica petici\u00f3n de desconexi\u00f3n. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hola, soy un cliente!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"Desde el servidor :\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Tarea Estudia el c\u00f3digo del servidor concurrente y observa c\u00f3mo gestiona la creaci\u00f3n de hilos para atender cada petici\u00f3n entrante. Conecta simult\u00e1neamente m\u00faltiples clientes y observa el estado de los sockets mediante las herramientas correspondientes.","title":"Ejemplo de sistema cliente/servidor multi-hilo"},{"location":"Subjects/NP2/P1/#tarea-entregable-opcional","text":"Tarea entregable opcional Modifica tu primer entregable para considerar una implementaci\u00f3n multihilo del servidor TCP, siguiendo las directrices de los c\u00f3digos de ejemplo anteriormente proporcionados.","title":"Tarea entregable opcional"},{"location":"Subjects/NP2/P1/#tarea-entregable-opcional_1","text":"Tarea entregable opcional Modifica el protocolo de env\u00edo para que tu aplicaci\u00f3n cliente/servidor UDP garantice en la medida de lo posible la recepci\u00f3n de los paquetes enviados desde el cliente, as\u00ed como su recepci\u00f3n en orden. Vuelve a analizar el tr\u00e1fico necesario en este caso comparado con una comunicaci\u00f3n b\u00e1sica basada en TCP (donde s\u00ed se garantizan, a nivel de transporte, dichas caracter\u00edsticas).","title":"Tarea entregable opcional"},{"location":"Subjects/NP2/P10/","text":"Pr\u00e1ctica 10. Frameworks IoT y Cloud Objetivos La pr\u00e1ctica presenta los pasos esenciales que permiten hacer interactuar un dispositivo (ESP32) con una infraestructura IoT en la nube. Aunque en este caso utilizaremos Microsoft Azure, los pasos tanto en configuraci\u00f3n remota como a nivel de nodo son muy similares a los que deber\u00edas seguir para otras infraestructuras (Amazon AWS, Google IoT Core, Aliyun IoT, Tencent Iot o cualquier otro). La documentaci\u00f3n de IDF proporciona ejemplos detallados para cada uno. El objetivo de la pr\u00e1ctica es desplegar un sistema de monitorizaci\u00f3n remota en Microsoft Power BI, que permita visualizar datos de telemetr\u00eda emitidos v\u00eda MQTT por el dispositivo a trav\u00e9s de un gateway en la nube (llamado en el caso de Azure IoT Hub ). Introducci\u00f3n El SDK ESP Azure IoT es una infraestructura basada en el SDK de Azure par IoT con soporte para C ( azure-iot-sdk-c ) portado sobre ESP-IDF para dar soporte al ESP32. Adem\u00e1s, proporciona un conjunto de ejemplos que permiten observar y simplificar el proceso de configuraci\u00f3n y conexi\u00f3n al framework Azure IoT Hub. Preparaci\u00f3n del firmware en el ESP32 En la presente pr\u00e1ctica utilizar\u00e1s una placa ESP32 que actuar\u00e1 como cliente ESP32, con un firmware personalizado que implementa la l\u00f3gica de conexi\u00f3n e interacci\u00f3n con Azure. En primer lugar: Configura una instalaci\u00f3n de ESP IDF tal y como has hecho en pr\u00e1cticas anteriores. Si ya la has configurado y es funcional, no es necesario ninguna reinstalaci\u00f3n ni reconfiguraci\u00f3n. En un directorio independiente, clona el repositorio de ESP Azure (f\u00edjate en la opci\u00f3n --recursive , que es imprescindible): git clone --recursive https://github.com/espressif/esp-azure.git Configuraci\u00f3n de Microsoft Azure Los siguientes pasos requieren el uso de una cuenta creada con Microsoft Azure. Los estudiantes UCM pueden adherirse al programa acad\u00e9mico, que otorga suficiente cr\u00e9dito para realizar este tipo de pr\u00e1cticas. Aseg\u00farate de acceder al portal de MS Azure y utilizar tu usuario y credenciales UCM para ello. Creaci\u00f3n de un Centro de IoT ( IoT Hub ) En la p\u00e1gina principal de Azure, selecciona la opci\u00f3n \"Crear un Recurso\" (en el men\u00fa de la parte superior izquierda de la pantalla) y a continuaici\u00f3n selecciona IoT Hub en cuadro \"Buscar en Marketplace\". Selecciona Iot Hub en los resultados de la b\u00fasqueda, y a continuaci\u00f3n \"Crear\". En la pesta\u00f1a Aspectos B\u00e1sicos , completa los campos de la siguiente forma: Suscripci\u00f3n : selecciona la suscripci\u00f3n que desees usar (por defecto, deber\u00eda aparecer Azure para estudiantes ). Grupo de recursos : crea un nuevo grupo de recursos seleccionando la opci\u00f3n Crear nuevo , y ot\u00f3rgale el nombre que desees, por ejemplo MIOTGROUP . Regi\u00f3n : selecciona la regi\u00f3n m\u00e1s cercana a ti (por ejemplo, Oeste de Europa ). Nombre : por \u00faltimo, da un nombre al hub , por ejemplo MIOTHUB . Deja los par\u00e1metros por defecto en la pesta\u00f1a Redes , y elige como Nivel de precios F1 en la pesta\u00f1a Administraci\u00f3n . Asigna las etiquetas que desees y finalmente confirma la creaci\u00f3n del Centro de IoT . Si todo ha ido bien, ver\u00e1s un resumen del recurso creado y podr\u00e1s acceder a \u00e9l pinchando en \"Ir al recurso\" . Ver\u00e1s una pantalla similar a la siguiente: En la secci\u00f3n de Configuraci\u00f3n , elige Directivas de acceso compartido y crea una nueva directiva llamada, por ejemplo MIOTPOLICY , con permisos de lectura y escritura en Registro, y conexi\u00f3n de servicios y dispositivos. Las pol\u00edticas de lectura y escritura en registro otorgan derechos de acceso al registro de indentidades de Azure. Estos permisos ser\u00e1n utilizados por servicios de back-end para gestionar las identidades de dispositivos, por ejemplo. La pol\u00edtica de conexi\u00f3n de servicio otorga permisos para acceder a endpoints de servicio. Los servicios de back-end podr\u00e1n enviar y recibir mensajes de dispositivos. La pol\u00edtica de conexi\u00f3n de dispositivo otorga permisos para enviar y recibir mensajes usando el IoT Hub . Una vez creada, selecci\u00f3nala y copia la Cadena de conexi\u00f3n principal (clave principal) que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el Hub . Registro de un nuevo dispositivo A continuaci\u00f3n, crearemos una nueva identidad de dispositivo en el Registro de Identidades del hub IoT que acabas de crear. Para ello: En el men\u00fa de navegaci\u00f3n, abre la opci\u00f3n \"Dispositivos de IoT\" y selecciona Nuevo para crear un nuevo dispositivo. Dale el nombre que quieras (por ejemplo MIOTDEVICE), pero recu\u00e9rdalo, y selecciona Guardar . Una vez creado, selecci\u00f3nalo y copia la Cadena de conexi\u00f3n principal que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el dispositivo . Instalaci\u00f3n de el cliente Azure Para instalar el cliente Azure en Linux, usa la orden: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash Tienes m\u00e1s opciones de instalaci\u00f3n en la p\u00e1gina . Una vez instalado, desde tu terminal, ejecuta el comando az para comprobar que la instalaci\u00f3n fue correcta. Deber\u00edas ver una salida similar a esta: az Welcome to Azure CLI! --------------------- Use `az -h` to see available commands or go to https://aka.ms/cli. ... Instala la extensi\u00f3n del cliente para Azure IoT: az extension add --name azure-cli-iot-ext Ingresa en el sistema ejecutando (se te pedir\u00e1 autenticaci\u00f3n en navegador, introduce tus credenciales): az login Para usar el cliente como m\u00e9todo de creaci\u00f3n de un dispositivo, puedes utilizar la siguiente orden: az iot hub device-identity create -n [IoTHub Name] -d [Device ID] Tarea Crea un nuevo dispositivo, distinto al que creaste anteriormente, en tu hub. Despu\u00e9s, obt\u00e9n su cadena de conexi\u00f3n usando la orden az iot hub device-identity show-connection-string -n [IoTHub Name] -d [Device ID] . Comprueba que, efectivamente, la creaci\u00f3n del dispositivo es visible en la plataforma web. Monitorizaci\u00f3n de valores de telemetr\u00eda del dispositivo y eventos Para observar los datos intercambiados entre el dispositivo y el hub IoT desde l\u00ednea de ocmandos, puedes usar la orden: az iot hub monitor-events -n [IoTHub Name] --login 'cadena de conexion' (Ten en cuenta que las comillas simples deben estar presentes). Despliegue de un cliente MQTT en el ESP32 Dir\u00edgete al ejemplo situado en el directorio examples/iothub_client_sample_mqtt . En \u00e9l, vamos a trabajar con cualquiera de los dos dispositivos que has creado en tu Hub . En cualquier caso, muestra su cadena de conexi\u00f3n principal . Deber\u00e1s ver un valor de devoluci\u00f3n de tipo: { \"connectionString\": \"HostName=<azure-iot-hub-name>.azure-devices.net;DeviceId=<azure-iot-device-id>;SharedAccessKey=<base64-encoded-shared-access-key>\" } Deber\u00e1s apuntar (copiar) \u00fanicamente la parte que comienza por HostName=... , hasta el final de la cadena. No incluyas las comillas dobles. Ejecuta make menuconfig . En el men\u00fa Example Configuration , configura las credenciales de acceso a tu red WiFi, as\u00ed como la cadena de conexi\u00f3n que copiaste en la opci\u00f3n IOT Hub Device Connection String . A continuaci\u00f3n, ejecuta la orden de compilaci\u00f3n, flasheado y monitorizaci\u00f3n: make flash monitor En una ventana separada, puedes monitorizar los eventos IoT en tu hub usando su cadena de conexi\u00f3n: az iot hub monitor-events -n [IoTHub Name] --login 'Cadena de conexi\u00f3n primaria' Una vez arrancado y conectado a Internet el dispositivo comenzar\u00e1 a publicar mensajes MQTT. El monitor que has lanzado los mostrar\u00e1 como: { \"event\": { \"origin\": \"<azure-iot-device-id>\", \"payload\": \"{\\\"deviceId\\\":\\\"MIOTDEVICE\\\",\\\"windSpeed\\\":13.00,\\\"temperature\\\":22.00,\\\"humidity\\\":67.00}\" } } Observa que incluye tres valores: velocidad del viento, temperatura y humedad. Tarea Analiza el c\u00f3digo y observa, en la tarea principal, el uso que hace de la API de Azure SDK C, as\u00ed como el punto en el que genera el mensaje MQTT (y sus valores). Tambi\u00e9n es posible enviar mensajes al dispositivo directamente desde l\u00ednea de comandos (observa que estos mensajes se env\u00edan v\u00eda red, no v\u00eda puerto serie, a trav\u00e9s del Hub ). Por tanto, puedes hacerlo desde cualquier punto, no obligatoriamente desde tu PC: az iot device c2d-message send -d [Device Id] -n [IoTHub Name] --data [Data_to_Send] Nota Si todo ha ido bien, en este punto deber\u00edas estar observando cada uno de los mensajes enviados por tu ESP32 al hub desde el monitor. Visualizaci\u00f3n de datos en Microsoft PowerBI En esta parte, el objetivo es visualizar los datos enviados por tu sensor (temperatura, humedad y velocidad del viento, en la herramienta de visualizaci\u00f3n PowerBI de Microsoft. Aunque PowerBI suele utilizarse en entornos de inteligencia de negocio, resulta tambi\u00e9n \u00fatil para reportar datos de cualquier elemento de Azure, incluido el IoT Hub . Nota Necesitar\u00e1s una cuenta de acceso gratuita a PowerBI, que puedes crear con tus credenciales de usuario UCM directamente en la p\u00e1gina del producto . Adici\u00f3n de un grupo de consumidores Los grupos de consumidores proporcionan vistas independientes en la secuencia de eventos que permiten a las aplicaciones y a los servicios de Azure consumir datos de forma independiente desde el mismo punto de conexi\u00f3n del centro de eventos. Vamos a agregar un grupo de consumidores al punto de conexi\u00f3n integrado de tu instancia de IoT Hub que se usar\u00e1 posteriormente para extraer datos del punto de conexi\u00f3n. Para agregar un grupo de consumidores a su centro de IoT, sigue estos pasos: En el portal de Azure, abre tu IoT Hub . En el panel izquierdo, selecciona Puntos de Conexi\u00f3n Integrados , luego Eventos en el panel superior derecho, y escribe un nombre en Grupos de consumidores (por ejemplo, MIOTGROUP ). A continuaci\u00f3n, selecciona Guardar . Creaci\u00f3n, configuraci\u00f3n y ejecuci\u00f3n de un trabajo de Stream Analytics Comencemos creando un trabajo de Stream Analytics . Despu\u00e9s de crear el trabajo, definiremos las entradas, las salidas y la consulta que se usar\u00e1 para recuperar los datos. Creaci\u00f3n de un trabajo de Stream Analytics En el portal de Azure, selecciona Crear un recurso -> Internet de las Cosas -> Stream Analytics Job . Escribe la siguiente informaci\u00f3n para el trabajo: Nombre del trabajo : Nombre que se asigna al trabajo; debe ser \u00fanico (por ejemplo, MIOTJOB ). Grupo de recursos : Usa el mismo grupo de recursos que definiste para el centro de IoT (por ejemplo, MIOTGROUP ). Ubicaci\u00f3n : Usa la misma que para el grupo de recursos. Selecciona Crear . Adici\u00f3n de una entrada al trabajo de Stream Analytics Abre el trabajo de Stream Analytics . En Topolog\u00eda de trabajo , selecciona Entradas . En el panel Entradas , selecciona Agregar entrada de flujo , y a continuaci\u00f3n, selecciona IoT Hub en la lista desplegable. En el panel de la nueva entrada, escribe la siguiente informaci\u00f3n: Alias de entrada : Un alias \u00fanico para la entrada (por ejemplo, MIOTINPUT ). Seleccionar centro de IoT de entre las suscripciones : Selecciona esta opci\u00f3n. Suscripci\u00f3n : Usa la suscripci\u00f3n que has utilizado en el resto de la pr\u00e1ctica. IoT Hub : Selecciona la instancia de tu Hub IoT tal y como has hecho en el resto de la pr\u00e1ctica. Punto de Conexi\u00f3n : Selecciona Mensajer\u00eda . Nombre de la directiva de acceso compartido : Selecciona el nombre de la directiva de acceso compartido que quieras que utilice el trabajo de Stream Analytics para tu centro de IoT. Para esta pr\u00e1ctica, puedes seleccionar service . La directiva service se crea de forma predeterminada en los centros de IoT nuevos y concede permiso de env\u00edo y recepci\u00f3n para los puntos de conexi\u00f3n de la nube que expone el centro de IoT. Clave de directiva de acceso compartido : Se rellena autom\u00e1ticamente en funci\u00f3n del nombre de directiva de acceso compartido. Grupo de consumidores : Selecciona el gruop de consumidores que se cre\u00f3 anteriormente. El resto de campos pueden dejarse en sus valores predeterminados. Finalmente, selecciona Guardar . Adici\u00f3n de una salida al trabajo de Stream Analytics En Topolog\u00eda de trabajo, selecciona Salidas . En el panel Salidas , selecciona Agregar y Power BI . En el panel Power BI: Nueva salida panel , selecciona Autorizar y sigue las indicaciones para iniciar sesi\u00f3n en tu cuenta de Power BI. Una vez que hayas iniciado sesi\u00f3n en Power BI, escribe la siguiente informaci\u00f3n: Alias de salida : alias \u00fanico para la salida, por ejemplo MIOTOUTPUT . \u00c1rea de trabajo de grupo : selecciona el \u00e1rea de trabajo de grupo de destino. Nombre del conjunto de datos : escribe un nombre para el conjunto de datos, por ejemplo MIOTDATASET . Nombre de la tabla : Escribe un nombre de tabla, por ejemplo MIOTTABLE . Modo de autenticaci\u00f3n : Deja la opci\u00f3n predeterminada. Configuraci\u00f3n de la consulta del trabajo de Stream Analytics En Topolog\u00eda de trabajo , selecciona Consulta . Reemplaza [YourInputAlias] por el alias de entrada del trabajo. Reemplaza [YourOutputAlias] por el alias de salida del trabajo. Selecciona Guardar consulta . Ejecuci\u00f3n del trabajo de Stream Analytics En el trabajo de Stream Analytics , selecciona Informaci\u00f3n general y, a continuaci\u00f3n, elige Iniciar->Ahora->Iniciar . Una vez que el trabajo se inicia correctamente, su estado cambia de Detenido a En ejecuci\u00f3n . Creaci\u00f3n y publicaci\u00f3n de un informe de Power BI para visualizar los datos En los pasos siguientes se muestra c\u00f3mo crear y publicar un informe mediante el servicio Power BI: Aseg\u00farate de que la aplicaci\u00f3n (tu ESP32) est\u00e1 ejecut\u00e1ndose. Inicia sesi\u00f3n en Power BI. Selecciona tu \u00e1rea de trabajo ( workspace ). Selecciona Conjunto de datos usando el conjunto de datos que creaste en pasos anteriores (corresponde al que creaste en el momento de crear la salida para el trabajo de Stream Analytics . Para dicho conjunto de datos, selecciona Agregar Informe (el primer icono a la derecha del nombre del conjunto de datos. Crea un gr\u00e1fico de l\u00edneas para mostrar la temperatura en tiempo real en un per\u00edodo determinado. Para ello: En el panel Visualizaciones de la p\u00e1gina de creaci\u00f3n de informes, selecciona el icono de gr\u00e1fico de l\u00edneas para agregar un gr\u00e1fico de l\u00edneas. En el panel Campos , expande la tabla que especific\u00f3 en el momento de crear la salida para el trabajo de Stream Analytics . Arrastra EventEnqueuedUtcTime (Hora UTC de evento en cola) al Eje en el panel Visualizaciones. Arrastra temperature (temperatura) a Valores . Se ha creado un gr\u00e1fico de l\u00edneas. El eje X muestra la fecha y hora en la zona horaria UTC. El eje Y muestra la temperatura del sensor: Tarea A\u00f1ade ahora informaci\u00f3n sobre humedad y velocidad del viento y refresca (actualiza) la visualizaci\u00f3n. Tarea entregable En esta pr\u00e1ctica, simplemente se pide que entregues alguna evidencia (por ejemplo, una captura de pantalla con tu ESP32 femitiendo eventos y una captura simult\u00e1nea de PowerBI mostr\u00e1ndolos) del correcto funcionamiento de los pasos listados. Opcionalmente, se puede a\u00f1adir, como informaci\u00f3n emitida desde el ESP32, valores reales de temperatura obtenidos desde un sensor en el ESP32.","title":"Pr\u00e1ctica 10. Frameworks IoT y Cloud"},{"location":"Subjects/NP2/P10/#practica-10-frameworks-iot-y-cloud","text":"","title":"Pr\u00e1ctica 10. Frameworks IoT y Cloud"},{"location":"Subjects/NP2/P10/#objetivos","text":"La pr\u00e1ctica presenta los pasos esenciales que permiten hacer interactuar un dispositivo (ESP32) con una infraestructura IoT en la nube. Aunque en este caso utilizaremos Microsoft Azure, los pasos tanto en configuraci\u00f3n remota como a nivel de nodo son muy similares a los que deber\u00edas seguir para otras infraestructuras (Amazon AWS, Google IoT Core, Aliyun IoT, Tencent Iot o cualquier otro). La documentaci\u00f3n de IDF proporciona ejemplos detallados para cada uno. El objetivo de la pr\u00e1ctica es desplegar un sistema de monitorizaci\u00f3n remota en Microsoft Power BI, que permita visualizar datos de telemetr\u00eda emitidos v\u00eda MQTT por el dispositivo a trav\u00e9s de un gateway en la nube (llamado en el caso de Azure IoT Hub ).","title":"Objetivos"},{"location":"Subjects/NP2/P10/#introduccion","text":"El SDK ESP Azure IoT es una infraestructura basada en el SDK de Azure par IoT con soporte para C ( azure-iot-sdk-c ) portado sobre ESP-IDF para dar soporte al ESP32. Adem\u00e1s, proporciona un conjunto de ejemplos que permiten observar y simplificar el proceso de configuraci\u00f3n y conexi\u00f3n al framework Azure IoT Hub.","title":"Introducci\u00f3n"},{"location":"Subjects/NP2/P10/#preparacion-del-firmware-en-el-esp32","text":"En la presente pr\u00e1ctica utilizar\u00e1s una placa ESP32 que actuar\u00e1 como cliente ESP32, con un firmware personalizado que implementa la l\u00f3gica de conexi\u00f3n e interacci\u00f3n con Azure. En primer lugar: Configura una instalaci\u00f3n de ESP IDF tal y como has hecho en pr\u00e1cticas anteriores. Si ya la has configurado y es funcional, no es necesario ninguna reinstalaci\u00f3n ni reconfiguraci\u00f3n. En un directorio independiente, clona el repositorio de ESP Azure (f\u00edjate en la opci\u00f3n --recursive , que es imprescindible): git clone --recursive https://github.com/espressif/esp-azure.git","title":"Preparaci\u00f3n del firmware en el ESP32"},{"location":"Subjects/NP2/P10/#configuracion-de-microsoft-azure","text":"Los siguientes pasos requieren el uso de una cuenta creada con Microsoft Azure. Los estudiantes UCM pueden adherirse al programa acad\u00e9mico, que otorga suficiente cr\u00e9dito para realizar este tipo de pr\u00e1cticas. Aseg\u00farate de acceder al portal de MS Azure y utilizar tu usuario y credenciales UCM para ello.","title":"Configuraci\u00f3n de Microsoft Azure"},{"location":"Subjects/NP2/P10/#creacion-de-un-centro-de-iot-iot-hub","text":"En la p\u00e1gina principal de Azure, selecciona la opci\u00f3n \"Crear un Recurso\" (en el men\u00fa de la parte superior izquierda de la pantalla) y a continuaici\u00f3n selecciona IoT Hub en cuadro \"Buscar en Marketplace\". Selecciona Iot Hub en los resultados de la b\u00fasqueda, y a continuaci\u00f3n \"Crear\". En la pesta\u00f1a Aspectos B\u00e1sicos , completa los campos de la siguiente forma: Suscripci\u00f3n : selecciona la suscripci\u00f3n que desees usar (por defecto, deber\u00eda aparecer Azure para estudiantes ). Grupo de recursos : crea un nuevo grupo de recursos seleccionando la opci\u00f3n Crear nuevo , y ot\u00f3rgale el nombre que desees, por ejemplo MIOTGROUP . Regi\u00f3n : selecciona la regi\u00f3n m\u00e1s cercana a ti (por ejemplo, Oeste de Europa ). Nombre : por \u00faltimo, da un nombre al hub , por ejemplo MIOTHUB . Deja los par\u00e1metros por defecto en la pesta\u00f1a Redes , y elige como Nivel de precios F1 en la pesta\u00f1a Administraci\u00f3n . Asigna las etiquetas que desees y finalmente confirma la creaci\u00f3n del Centro de IoT . Si todo ha ido bien, ver\u00e1s un resumen del recurso creado y podr\u00e1s acceder a \u00e9l pinchando en \"Ir al recurso\" . Ver\u00e1s una pantalla similar a la siguiente: En la secci\u00f3n de Configuraci\u00f3n , elige Directivas de acceso compartido y crea una nueva directiva llamada, por ejemplo MIOTPOLICY , con permisos de lectura y escritura en Registro, y conexi\u00f3n de servicios y dispositivos. Las pol\u00edticas de lectura y escritura en registro otorgan derechos de acceso al registro de indentidades de Azure. Estos permisos ser\u00e1n utilizados por servicios de back-end para gestionar las identidades de dispositivos, por ejemplo. La pol\u00edtica de conexi\u00f3n de servicio otorga permisos para acceder a endpoints de servicio. Los servicios de back-end podr\u00e1n enviar y recibir mensajes de dispositivos. La pol\u00edtica de conexi\u00f3n de dispositivo otorga permisos para enviar y recibir mensajes usando el IoT Hub . Una vez creada, selecci\u00f3nala y copia la Cadena de conexi\u00f3n principal (clave principal) que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el Hub .","title":"Creaci\u00f3n de un Centro de IoT (IoT Hub)"},{"location":"Subjects/NP2/P10/#registro-de-un-nuevo-dispositivo","text":"A continuaci\u00f3n, crearemos una nueva identidad de dispositivo en el Registro de Identidades del hub IoT que acabas de crear. Para ello: En el men\u00fa de navegaci\u00f3n, abre la opci\u00f3n \"Dispositivos de IoT\" y selecciona Nuevo para crear un nuevo dispositivo. Dale el nombre que quieras (por ejemplo MIOTDEVICE), pero recu\u00e9rdalo, y selecciona Guardar . Una vez creado, selecci\u00f3nalo y copia la Cadena de conexi\u00f3n principal que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el dispositivo .","title":"Registro de un nuevo dispositivo"},{"location":"Subjects/NP2/P10/#instalacion-de-el-cliente-azure","text":"Para instalar el cliente Azure en Linux, usa la orden: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash Tienes m\u00e1s opciones de instalaci\u00f3n en la p\u00e1gina . Una vez instalado, desde tu terminal, ejecuta el comando az para comprobar que la instalaci\u00f3n fue correcta. Deber\u00edas ver una salida similar a esta: az Welcome to Azure CLI! --------------------- Use `az -h` to see available commands or go to https://aka.ms/cli. ... Instala la extensi\u00f3n del cliente para Azure IoT: az extension add --name azure-cli-iot-ext Ingresa en el sistema ejecutando (se te pedir\u00e1 autenticaci\u00f3n en navegador, introduce tus credenciales): az login Para usar el cliente como m\u00e9todo de creaci\u00f3n de un dispositivo, puedes utilizar la siguiente orden: az iot hub device-identity create -n [IoTHub Name] -d [Device ID] Tarea Crea un nuevo dispositivo, distinto al que creaste anteriormente, en tu hub. Despu\u00e9s, obt\u00e9n su cadena de conexi\u00f3n usando la orden az iot hub device-identity show-connection-string -n [IoTHub Name] -d [Device ID] . Comprueba que, efectivamente, la creaci\u00f3n del dispositivo es visible en la plataforma web.","title":"Instalaci\u00f3n de el cliente Azure"},{"location":"Subjects/NP2/P10/#monitorizacion-de-valores-de-telemetria-del-dispositivo-y-eventos","text":"Para observar los datos intercambiados entre el dispositivo y el hub IoT desde l\u00ednea de ocmandos, puedes usar la orden: az iot hub monitor-events -n [IoTHub Name] --login 'cadena de conexion' (Ten en cuenta que las comillas simples deben estar presentes).","title":"Monitorizaci\u00f3n de valores de telemetr\u00eda del dispositivo y eventos"},{"location":"Subjects/NP2/P10/#despliegue-de-un-cliente-mqtt-en-el-esp32","text":"Dir\u00edgete al ejemplo situado en el directorio examples/iothub_client_sample_mqtt . En \u00e9l, vamos a trabajar con cualquiera de los dos dispositivos que has creado en tu Hub . En cualquier caso, muestra su cadena de conexi\u00f3n principal . Deber\u00e1s ver un valor de devoluci\u00f3n de tipo: { \"connectionString\": \"HostName=<azure-iot-hub-name>.azure-devices.net;DeviceId=<azure-iot-device-id>;SharedAccessKey=<base64-encoded-shared-access-key>\" } Deber\u00e1s apuntar (copiar) \u00fanicamente la parte que comienza por HostName=... , hasta el final de la cadena. No incluyas las comillas dobles. Ejecuta make menuconfig . En el men\u00fa Example Configuration , configura las credenciales de acceso a tu red WiFi, as\u00ed como la cadena de conexi\u00f3n que copiaste en la opci\u00f3n IOT Hub Device Connection String . A continuaci\u00f3n, ejecuta la orden de compilaci\u00f3n, flasheado y monitorizaci\u00f3n: make flash monitor En una ventana separada, puedes monitorizar los eventos IoT en tu hub usando su cadena de conexi\u00f3n: az iot hub monitor-events -n [IoTHub Name] --login 'Cadena de conexi\u00f3n primaria' Una vez arrancado y conectado a Internet el dispositivo comenzar\u00e1 a publicar mensajes MQTT. El monitor que has lanzado los mostrar\u00e1 como: { \"event\": { \"origin\": \"<azure-iot-device-id>\", \"payload\": \"{\\\"deviceId\\\":\\\"MIOTDEVICE\\\",\\\"windSpeed\\\":13.00,\\\"temperature\\\":22.00,\\\"humidity\\\":67.00}\" } } Observa que incluye tres valores: velocidad del viento, temperatura y humedad. Tarea Analiza el c\u00f3digo y observa, en la tarea principal, el uso que hace de la API de Azure SDK C, as\u00ed como el punto en el que genera el mensaje MQTT (y sus valores). Tambi\u00e9n es posible enviar mensajes al dispositivo directamente desde l\u00ednea de comandos (observa que estos mensajes se env\u00edan v\u00eda red, no v\u00eda puerto serie, a trav\u00e9s del Hub ). Por tanto, puedes hacerlo desde cualquier punto, no obligatoriamente desde tu PC: az iot device c2d-message send -d [Device Id] -n [IoTHub Name] --data [Data_to_Send] Nota Si todo ha ido bien, en este punto deber\u00edas estar observando cada uno de los mensajes enviados por tu ESP32 al hub desde el monitor.","title":"Despliegue de un cliente MQTT en el ESP32"},{"location":"Subjects/NP2/P10/#visualizacion-de-datos-en-microsoft-powerbi","text":"En esta parte, el objetivo es visualizar los datos enviados por tu sensor (temperatura, humedad y velocidad del viento, en la herramienta de visualizaci\u00f3n PowerBI de Microsoft. Aunque PowerBI suele utilizarse en entornos de inteligencia de negocio, resulta tambi\u00e9n \u00fatil para reportar datos de cualquier elemento de Azure, incluido el IoT Hub . Nota Necesitar\u00e1s una cuenta de acceso gratuita a PowerBI, que puedes crear con tus credenciales de usuario UCM directamente en la p\u00e1gina del producto .","title":"Visualizaci\u00f3n de datos en Microsoft PowerBI"},{"location":"Subjects/NP2/P10/#adicion-de-un-grupo-de-consumidores","text":"Los grupos de consumidores proporcionan vistas independientes en la secuencia de eventos que permiten a las aplicaciones y a los servicios de Azure consumir datos de forma independiente desde el mismo punto de conexi\u00f3n del centro de eventos. Vamos a agregar un grupo de consumidores al punto de conexi\u00f3n integrado de tu instancia de IoT Hub que se usar\u00e1 posteriormente para extraer datos del punto de conexi\u00f3n. Para agregar un grupo de consumidores a su centro de IoT, sigue estos pasos: En el portal de Azure, abre tu IoT Hub . En el panel izquierdo, selecciona Puntos de Conexi\u00f3n Integrados , luego Eventos en el panel superior derecho, y escribe un nombre en Grupos de consumidores (por ejemplo, MIOTGROUP ). A continuaci\u00f3n, selecciona Guardar .","title":"Adici\u00f3n de un grupo de consumidores"},{"location":"Subjects/NP2/P10/#creacion-configuracion-y-ejecucion-de-un-trabajo-de-stream-analytics","text":"Comencemos creando un trabajo de Stream Analytics . Despu\u00e9s de crear el trabajo, definiremos las entradas, las salidas y la consulta que se usar\u00e1 para recuperar los datos.","title":"Creaci\u00f3n, configuraci\u00f3n y ejecuci\u00f3n de un trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#creacion-de-un-trabajo-de-stream-analytics","text":"En el portal de Azure, selecciona Crear un recurso -> Internet de las Cosas -> Stream Analytics Job . Escribe la siguiente informaci\u00f3n para el trabajo: Nombre del trabajo : Nombre que se asigna al trabajo; debe ser \u00fanico (por ejemplo, MIOTJOB ). Grupo de recursos : Usa el mismo grupo de recursos que definiste para el centro de IoT (por ejemplo, MIOTGROUP ). Ubicaci\u00f3n : Usa la misma que para el grupo de recursos. Selecciona Crear .","title":"Creaci\u00f3n de un trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#adicion-de-una-entrada-al-trabajo-de-stream-analytics","text":"Abre el trabajo de Stream Analytics . En Topolog\u00eda de trabajo , selecciona Entradas . En el panel Entradas , selecciona Agregar entrada de flujo , y a continuaci\u00f3n, selecciona IoT Hub en la lista desplegable. En el panel de la nueva entrada, escribe la siguiente informaci\u00f3n: Alias de entrada : Un alias \u00fanico para la entrada (por ejemplo, MIOTINPUT ). Seleccionar centro de IoT de entre las suscripciones : Selecciona esta opci\u00f3n. Suscripci\u00f3n : Usa la suscripci\u00f3n que has utilizado en el resto de la pr\u00e1ctica. IoT Hub : Selecciona la instancia de tu Hub IoT tal y como has hecho en el resto de la pr\u00e1ctica. Punto de Conexi\u00f3n : Selecciona Mensajer\u00eda . Nombre de la directiva de acceso compartido : Selecciona el nombre de la directiva de acceso compartido que quieras que utilice el trabajo de Stream Analytics para tu centro de IoT. Para esta pr\u00e1ctica, puedes seleccionar service . La directiva service se crea de forma predeterminada en los centros de IoT nuevos y concede permiso de env\u00edo y recepci\u00f3n para los puntos de conexi\u00f3n de la nube que expone el centro de IoT. Clave de directiva de acceso compartido : Se rellena autom\u00e1ticamente en funci\u00f3n del nombre de directiva de acceso compartido. Grupo de consumidores : Selecciona el gruop de consumidores que se cre\u00f3 anteriormente. El resto de campos pueden dejarse en sus valores predeterminados. Finalmente, selecciona Guardar .","title":"Adici\u00f3n de una entrada al trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#adicion-de-una-salida-al-trabajo-de-stream-analytics","text":"En Topolog\u00eda de trabajo, selecciona Salidas . En el panel Salidas , selecciona Agregar y Power BI . En el panel Power BI: Nueva salida panel , selecciona Autorizar y sigue las indicaciones para iniciar sesi\u00f3n en tu cuenta de Power BI. Una vez que hayas iniciado sesi\u00f3n en Power BI, escribe la siguiente informaci\u00f3n: Alias de salida : alias \u00fanico para la salida, por ejemplo MIOTOUTPUT . \u00c1rea de trabajo de grupo : selecciona el \u00e1rea de trabajo de grupo de destino. Nombre del conjunto de datos : escribe un nombre para el conjunto de datos, por ejemplo MIOTDATASET . Nombre de la tabla : Escribe un nombre de tabla, por ejemplo MIOTTABLE . Modo de autenticaci\u00f3n : Deja la opci\u00f3n predeterminada.","title":"Adici\u00f3n de una salida al trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#configuracion-de-la-consulta-del-trabajo-de-stream-analytics","text":"En Topolog\u00eda de trabajo , selecciona Consulta . Reemplaza [YourInputAlias] por el alias de entrada del trabajo. Reemplaza [YourOutputAlias] por el alias de salida del trabajo. Selecciona Guardar consulta .","title":"Configuraci\u00f3n de la consulta del trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#ejecucion-del-trabajo-de-stream-analytics","text":"En el trabajo de Stream Analytics , selecciona Informaci\u00f3n general y, a continuaci\u00f3n, elige Iniciar->Ahora->Iniciar . Una vez que el trabajo se inicia correctamente, su estado cambia de Detenido a En ejecuci\u00f3n .","title":"Ejecuci\u00f3n del trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#creacion-y-publicacion-de-un-informe-de-power-bi-para-visualizar-los-datos","text":"En los pasos siguientes se muestra c\u00f3mo crear y publicar un informe mediante el servicio Power BI: Aseg\u00farate de que la aplicaci\u00f3n (tu ESP32) est\u00e1 ejecut\u00e1ndose. Inicia sesi\u00f3n en Power BI. Selecciona tu \u00e1rea de trabajo ( workspace ). Selecciona Conjunto de datos usando el conjunto de datos que creaste en pasos anteriores (corresponde al que creaste en el momento de crear la salida para el trabajo de Stream Analytics . Para dicho conjunto de datos, selecciona Agregar Informe (el primer icono a la derecha del nombre del conjunto de datos. Crea un gr\u00e1fico de l\u00edneas para mostrar la temperatura en tiempo real en un per\u00edodo determinado. Para ello: En el panel Visualizaciones de la p\u00e1gina de creaci\u00f3n de informes, selecciona el icono de gr\u00e1fico de l\u00edneas para agregar un gr\u00e1fico de l\u00edneas. En el panel Campos , expande la tabla que especific\u00f3 en el momento de crear la salida para el trabajo de Stream Analytics . Arrastra EventEnqueuedUtcTime (Hora UTC de evento en cola) al Eje en el panel Visualizaciones. Arrastra temperature (temperatura) a Valores . Se ha creado un gr\u00e1fico de l\u00edneas. El eje X muestra la fecha y hora en la zona horaria UTC. El eje Y muestra la temperatura del sensor: Tarea A\u00f1ade ahora informaci\u00f3n sobre humedad y velocidad del viento y refresca (actualiza) la visualizaci\u00f3n. Tarea entregable En esta pr\u00e1ctica, simplemente se pide que entregues alguna evidencia (por ejemplo, una captura de pantalla con tu ESP32 femitiendo eventos y una captura simult\u00e1nea de PowerBI mostr\u00e1ndolos) del correcto funcionamiento de los pasos listados. Opcionalmente, se puede a\u00f1adir, como informaci\u00f3n emitida desde el ESP32, valores reales de temperatura obtenidos desde un sensor en el ESP32.","title":"Creaci\u00f3n y publicaci\u00f3n de un informe de Power BI para visualizar los datos"},{"location":"Subjects/NP2/P2/","text":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF Objetivos Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32 Introducci\u00f3n En la pr\u00e1ctica anterior, vimos c\u00f3mo desarrollar sistemas cliente/servidor sencillos utilizando Python, tanto en sus variantes TCP como UDP. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en la m\u00e1quina virtual (programados v\u00eda Python) y en la propia placa (utilizando la API de sockets de C). La API de sockets en C Funciones para ordenacion de bytes Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* . Estructuras de datos Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas comunmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utiliar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket. API b\u00e1sica socket() Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ). bind() Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ). listen() Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ). accept() Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ). connect() Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n espec\u00edficada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ). send() Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ). recv() / recvfrom() Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metrosd de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ). close() Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ). Ejemplos Se proporcionan a continuaci\u00f3n ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea Compila ( gcc ejemplo.c -o ejemplo.x ) y ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente. Ejemplo: un cliente TCP #include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error en connect\\n\"); return 1; } const char* data_to_send = \"Hola, RPI!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Recibido: '%s'\\n\", buffer); } close(sock); return 0; } Ejemplo: un servidor TCP #include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error en bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error en listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error en accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Recibido: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Tarea Reproduce el funcionamiento del anterior sistema cliente/servidor echo utilizando UDP. Construcci\u00f3n de mensajes Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea Modifica el cliente UDP para que encapsule y env\u00ede una estructura con distintos campos (por ejemplo, dos enteros), que sea recibida por un servidor Python siguiendo las directivas de la anterior pr\u00e1ctica. En este caso, no utilices campos de tipo flotante (veremos c\u00f3mo hacerlo m\u00e1s adelante). El objetivo del ejercicio es simplemente comprobar que la comunicaci\u00f3n entre un cliente programado en C y un servidor programado en Python es posible. No se pretende que desarrolles un sistema complejo. Sistemas cliente/servidor en el ESP32 La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT. Cliente/servidor UDP en el ESP32 En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/ Estructura general Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funcion app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se cerea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos. Despliegue. Opci\u00f3n 1 En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP. Despliegue. Opci\u00f3n 2 Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecera la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar. Cliente/servidor TCP en el ESP32 El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza la m\u00e1quina virtual como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea entregable En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: Sistema cliente/servidor desarrollado en la Pr\u00e1ctica 1, escrito en Python e implementando un protocolo b\u00e1sico de aplicacion (tipo de mensaje) propuesto por ti. C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea entregable, se pide que adaptes tu entrega de la Pr\u00e1ctica 1 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Python, o bien utilizando una nueva implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF"},{"location":"Subjects/NP2/P2/#practica-2-sockets-tcp-y-udp-en-esp-idf","text":"","title":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF"},{"location":"Subjects/NP2/P2/#objetivos","text":"Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32","title":"Objetivos"},{"location":"Subjects/NP2/P2/#introduccion","text":"En la pr\u00e1ctica anterior, vimos c\u00f3mo desarrollar sistemas cliente/servidor sencillos utilizando Python, tanto en sus variantes TCP como UDP. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en la m\u00e1quina virtual (programados v\u00eda Python) y en la propia placa (utilizando la API de sockets de C).","title":"Introducci\u00f3n"},{"location":"Subjects/NP2/P2/#la-api-de-sockets-en-c","text":"","title":"La API de sockets en C"},{"location":"Subjects/NP2/P2/#funciones-para-ordenacion-de-bytes","text":"Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* .","title":"Funciones para ordenacion de bytes"},{"location":"Subjects/NP2/P2/#estructuras-de-datos","text":"Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas comunmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utiliar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket.","title":"Estructuras de datos"},{"location":"Subjects/NP2/P2/#api-basica","text":"","title":"API b\u00e1sica"},{"location":"Subjects/NP2/P2/#socket","text":"Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ).","title":"socket()"},{"location":"Subjects/NP2/P2/#bind","text":"Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ).","title":"bind()"},{"location":"Subjects/NP2/P2/#listen","text":"Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ).","title":"listen()"},{"location":"Subjects/NP2/P2/#accept","text":"Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ).","title":"accept()"},{"location":"Subjects/NP2/P2/#connect","text":"Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n espec\u00edficada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ).","title":"connect()"},{"location":"Subjects/NP2/P2/#send","text":"Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ).","title":"send()"},{"location":"Subjects/NP2/P2/#recvrecvfrom","text":"Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metrosd de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ).","title":"recv()/recvfrom()"},{"location":"Subjects/NP2/P2/#close","text":"Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ).","title":"close()"},{"location":"Subjects/NP2/P2/#ejemplos","text":"Se proporcionan a continuaci\u00f3n ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea Compila ( gcc ejemplo.c -o ejemplo.x ) y ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente.","title":"Ejemplos"},{"location":"Subjects/NP2/P2/#ejemplo-un-cliente-tcp","text":"#include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error en connect\\n\"); return 1; } const char* data_to_send = \"Hola, RPI!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Recibido: '%s'\\n\", buffer); } close(sock); return 0; }","title":"Ejemplo: un cliente TCP"},{"location":"Subjects/NP2/P2/#ejemplo-un-servidor-tcp","text":"#include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error en bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error en listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error en accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Recibido: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Tarea Reproduce el funcionamiento del anterior sistema cliente/servidor echo utilizando UDP.","title":"Ejemplo: un servidor TCP"},{"location":"Subjects/NP2/P2/#construccion-de-mensajes","text":"Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea Modifica el cliente UDP para que encapsule y env\u00ede una estructura con distintos campos (por ejemplo, dos enteros), que sea recibida por un servidor Python siguiendo las directivas de la anterior pr\u00e1ctica. En este caso, no utilices campos de tipo flotante (veremos c\u00f3mo hacerlo m\u00e1s adelante). El objetivo del ejercicio es simplemente comprobar que la comunicaci\u00f3n entre un cliente programado en C y un servidor programado en Python es posible. No se pretende que desarrolles un sistema complejo.","title":"Construcci\u00f3n de mensajes"},{"location":"Subjects/NP2/P2/#sistemas-clienteservidor-en-el-esp32","text":"La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT.","title":"Sistemas cliente/servidor en el ESP32"},{"location":"Subjects/NP2/P2/#clienteservidor-udp-en-el-esp32","text":"En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/","title":"Cliente/servidor UDP en el ESP32"},{"location":"Subjects/NP2/P2/#estructura-general","text":"Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funcion app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se cerea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos.","title":"Estructura general"},{"location":"Subjects/NP2/P2/#despliegue-opcion-1","text":"En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP.","title":"Despliegue. Opci\u00f3n 1"},{"location":"Subjects/NP2/P2/#despliegue-opcion-2","text":"Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecera la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar.","title":"Despliegue. Opci\u00f3n 2"},{"location":"Subjects/NP2/P2/#clienteservidor-tcp-en-el-esp32","text":"El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza la m\u00e1quina virtual como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea entregable En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: Sistema cliente/servidor desarrollado en la Pr\u00e1ctica 1, escrito en Python e implementando un protocolo b\u00e1sico de aplicacion (tipo de mensaje) propuesto por ti. C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea entregable, se pide que adaptes tu entrega de la Pr\u00e1ctica 1 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Python, o bien utilizando una nueva implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Cliente/servidor TCP en el ESP32"},{"location":"Subjects/NP2/P3/","text":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS) Objetivos Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS). Contenido del paquete proporcionado y setup b\u00e1sico El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl24 Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n. Cliente/servidor TLS. Ejemplo b\u00e1sico en host Servidor TLS Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c . Cabeceras y constantes El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 . Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n. Cliente/servidor DTLS. Ejemplo b\u00e1sico en host El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos. TLS en el ESP32. El componente ESP-TLS ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla,y se basa en el uso de cuatro funciones b\u00e1sicas: Establecimiento de conexi\u00f3n TLS ( esp_tls_conn_new() ) Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n. Destrucci\u00f3n de conexi\u00f3n TLS ( esp_tls_conn_delete() ) void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n. Escritura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo. Lectura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n. Estructura b\u00e1sica de un cliente TCP usando ESP-IDF Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente (puedes compararlo con tus clientes TCP desarrollados en sesiones anteriores). La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Observa como, efectivamente, el c\u00f3digo del cliente se simplifica en gran medida con respecto a tu cliente TCP original. Toma el c\u00f3digo del proyecto que utilizaste para desarrollar tu cliente TCP original y, siguiendo las anteriores directivas, adapta la \u00fanica tarea a crear (por ejemplo, puede recibir el nombre tls_client_task ) para que realice un env\u00edo y recepci\u00f3n de datos (una cadena) al servidor TLS que probaste en el host . Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo . Note Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Adapta tu sistema cliente/servidor TCP desarrollado en la anterior pr\u00e1ctica para que se ejecute sobre el binomio host /ESP32 utlizando TLS. Entrega el c\u00f3digo generado junto con una captura de tr\u00e1fico que demuestre su correcto funcionamiento.","title":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS)"},{"location":"Subjects/NP2/P3/#practica-3-seguridad-tls-y-dtls","text":"","title":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS)"},{"location":"Subjects/NP2/P3/#objetivos","text":"Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS).","title":"Objetivos"},{"location":"Subjects/NP2/P3/#contenido-del-paquete-proporcionado-y-setup-basico","text":"El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl24 Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n.","title":"Contenido del paquete proporcionado y setup b\u00e1sico"},{"location":"Subjects/NP2/P3/#clienteservidor-tls-ejemplo-basico-en-host","text":"","title":"Cliente/servidor TLS. Ejemplo b\u00e1sico en host"},{"location":"Subjects/NP2/P3/#servidor-tls","text":"Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c .","title":"Servidor TLS"},{"location":"Subjects/NP2/P3/#cabeceras-y-constantes","text":"El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 .","title":"Cabeceras y constantes"},{"location":"Subjects/NP2/P3/#objetos-basicos-wolfssl-contexto-y-objeto-ssl","text":"Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n.","title":"Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL"},{"location":"Subjects/NP2/P3/#clienteservidor-dtls-ejemplo-basico-en-host","text":"El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos.","title":"Cliente/servidor DTLS. Ejemplo b\u00e1sico en host"},{"location":"Subjects/NP2/P3/#tls-en-el-esp32-el-componente-esp-tls","text":"ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla,y se basa en el uso de cuatro funciones b\u00e1sicas:","title":"TLS en el ESP32. El componente ESP-TLS"},{"location":"Subjects/NP2/P3/#establecimiento-de-conexion-tls-esp_tls_conn_new","text":"Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n.","title":"Establecimiento de conexi\u00f3n TLS (esp_tls_conn_new())"},{"location":"Subjects/NP2/P3/#destruccion-de-conexion-tls-esp_tls_conn_delete","text":"void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n.","title":"Destrucci\u00f3n de conexi\u00f3n TLS (esp_tls_conn_delete())"},{"location":"Subjects/NP2/P3/#escritura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo.","title":"Escritura de datos (esp_tls_conn_read())"},{"location":"Subjects/NP2/P3/#lectura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n.","title":"Lectura de datos (esp_tls_conn_read())"},{"location":"Subjects/NP2/P3/#estructura-basica-de-un-cliente-tcp-usando-esp-idf","text":"Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente (puedes compararlo con tus clientes TCP desarrollados en sesiones anteriores). La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Observa como, efectivamente, el c\u00f3digo del cliente se simplifica en gran medida con respecto a tu cliente TCP original. Toma el c\u00f3digo del proyecto que utilizaste para desarrollar tu cliente TCP original y, siguiendo las anteriores directivas, adapta la \u00fanica tarea a crear (por ejemplo, puede recibir el nombre tls_client_task ) para que realice un env\u00edo y recepci\u00f3n de datos (una cadena) al servidor TLS que probaste en el host . Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo . Note Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Adapta tu sistema cliente/servidor TCP desarrollado en la anterior pr\u00e1ctica para que se ejecute sobre el binomio host /ESP32 utlizando TLS. Entrega el c\u00f3digo generado junto con una captura de tr\u00e1fico que demuestre su correcto funcionamiento.","title":"Estructura b\u00e1sica de un cliente TCP usando ESP-IDF"},{"location":"Subjects/NP2/P4/","text":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets Objetivos Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets . Estudar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar mecanismos de mantenimiento y publicaci\u00f3n de estado a clientes conectados, t\u00edpicos en un entorno IoT. Estudiar el componente websockets client en ESP-IDF, y desarrollar un firmware b\u00e1sico que interact\u00fae con un servidor Python. Introducir la gesti\u00f3n de objetos JSON en ESP-IDF. Los ficheros necesarios para completar la pr\u00e1ctica pueden descargarse aqu\u00ed . Ejemplo b\u00e1sico: sistema cliente/servidor usando Websockets en Python (\u00b4client1.py, server1.py`) En primer lugar, introducimos el uso del m\u00f3dulo Python websockets , que proporciona toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor utilizando websockets . El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste, tal y como hemos visto en otras pr\u00e1cticas. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea entregable Ejecuta el servidor en una terminal de tu m\u00e1quina virtual, y a continuaci\u00f3n el cliente en otra. Analiza el tr\u00e1fico intercambiado y responde a las siguientes preguntas: \u00bfEn qu\u00e9 protocolo de capa de transporte se basa la comunicaci\u00f3n v\u00eda Websockets? En la fase de handshake , \u00bfqu\u00e9 peticiones HTTP se intercambian? Analiza sus emisores y destinatarios, e investiga el cometido principal de cada uno de los campos de sus encabezados (f\u00edjate principalmente en el campo Upgrade y los campos espec\u00edficos para Websockets). En la fase de intercambio de datos, \u00bfqu\u00e9 opcode se especifica en el encabezado de cada paquete? \u00bfPor qu\u00e9? \u00bfSe env\u00edan los datos en claro o cifrados? \u00bfQu\u00e9 opcode se a\u00f1ade en los mensajes de cierre de conexi\u00f3n? Interactuando con un navegador web ( client_for_web.html , server_for_web.py ) Aunque fuera del inter\u00e9s de esta pr\u00e1ctica, es conveniente observar una de las ventajas de websockets : el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, y observarlo a trav\u00e9s de un navegador web convencional (la mayor\u00eda de navegadores modernos soportan websockets a trav\u00e9s de scripts Javascript ). En este caso, simplemente observa la interacci\u00f3n de un servidor websocket que env\u00eda mensajes que incluyen la hora actual separados un n\u00famero aleatorio de tiempo entre ellos: #!/usr/bin/env python # WS server that sends messages at random intervals import asyncio import datetime import random import websockets async def time(websocket, path): while True: now = datetime.datetime.utcnow().isoformat() + \"Z\" await websocket.send(now) await asyncio.sleep(random.random() * 3) start_server = websockets.serve(time, \"127.0.0.1\", 5678) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Con un cliente (una p\u00e1gina HTML) que establece la conexi\u00f3n v\u00eda websockets , y muestra en la misma un elemento de texto con la marca de tiempo recibida tras la recepci\u00f3n de cada mensaje: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> </head> <body> <script> var ws = new WebSocket(\"ws://127.0.0.1:5678/\"), messages = document.createElement('ul'); ws.onmessage = function (event) { var messages = document.getElementsByTagName('ul')[0], message = document.createElement('li'), content = document.createTextNode(event.data); message.appendChild(content); messages.appendChild(message); }; document.body.appendChild(messages); </script> </body> </html> Tarea Ejecuta el servidor en tu m\u00e1quina virtual y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con un navegador. Observa como la p\u00e1gina se actualiza a medida que recibe mensajes a trav\u00e9s del socket. Si quieres, puedes observar el intercambio de mensajes. \u00bfQu\u00e9 ocurre si, en otra pesta\u00f1a, vuelves a abrir la p\u00e1gina cliente? Un ejemplo m\u00e1s complejo: sincronizaci\u00f3n entre m\u00faltiples clientes ( server2.py , client.html ) Un servidor websocket puede recibir eventos desde distintos clientes, procesarlos para, por ejemplo, mantener actualizado un estado a nivel de aplicaci\u00f3n, y sincronizar dicho estado entre todos los clientes conectados, envi\u00e1ndoles mensajes de forma as\u00edncrona a trav\u00e9s del socket bidireccional, a modo de \"notificaciones push \". A continuaci\u00f3n, se muestra el c\u00f3digo de un servidor que mantiene dos tipos de informaci\u00f3n de estado siempre actualizada: el valor de un contador ( STATE ), que puede ser modificado por los clientes conectados sumando o restando uno a su valor a trav\u00e9s de mensajes enviados por el socket ; y el n\u00famero de clientes conectados ( USERS ). #!/usr/bin/env python import asyncio import json import logging import websockets logging.basicConfig() STATE = {\"value\": 0} USERS = set() def state_event(): return json.dumps({\"type\": \"state\", **STATE}) def users_event(): return json.dumps({\"type\": \"users\", \"count\": len(USERS)}) async def notify_state(): if USERS: # asyncio.wait doesn't accept an empty list message = state_event() await asyncio.wait([user.send(message) for user in USERS]) async def notify_users(): if USERS: # asyncio.wait doesn't accept an empty list message = users_event() await asyncio.wait([user.send(message) for user in USERS]) async def register(websocket): USERS.add(websocket) await notify_users() async def unregister(websocket): USERS.remove(websocket) await notify_users() async def counter(websocket, path): # register(websocket) sends user_event() to websocket await register(websocket) try: await websocket.send(state_event()) async for message in websocket: data = json.loads(message) if data[\"action\"] == \"minus\": STATE[\"value\"] -= 1 await notify_state() elif data[\"action\"] == \"plus\": STATE[\"value\"] += 1 await notify_state() else: logging.error(\"unsupported event: {}\", data) finally: await unregister(websocket) start_server = websockets.serve(counter, \"localhost\", 6789) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Observa el c\u00f3digo del servidor. El manejador counter procesa cada conexi\u00f3n entrante, registrando a su entrada a un nuevo cliente en el sistema ( register ) y desregistr\u00e1ndolo antes de finalizar ( unregister ). Ante cada registro o desregistro, se notifica a los usuarios este hecho, enviando a cada cliente un peque\u00f1o texto en formato JSON cuyo contenido es: {\"type\": \"users\", \"count\": usuarios} Es decir, un mensaje con dos campos (veremos JSON en la pr\u00f3xima pr\u00e1ctica): campo type , con valor fijo users , y campo count , con un valor entero que indica el n\u00famero de clientes conectados. A continuaci\u00f3n, para cada mensaje recibido a trav\u00e9s del socket, \u00e9ste se procesa, esperando tambi\u00e9n un fichero JSON con la acci\u00f3n que el cliente solicita (sumar o restar 1 al contador), por ejemplo: {\"action\": \"minus\"} o {\"action\": \"plus\"} En funci\u00f3n de la acci\u00f3n solicitada, el servidor actualiza el valor de STATE , y env\u00eda (rutina notify_state ) dicho valor actualizado a TODOS los clientes conectados mediante un peque\u00f1o mensaje de texto en formato JSON: {\"type\": \"state\", \"value\": VALOR} La parte cliente sigue la misma filosof\u00eda, utilizando de nuevo el navegador como plataforma para visualizar la interacci\u00f3n con el cliente. El c\u00f3digo HTML que puedes abrir en tu navegador es el siguiente: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> <style type=\"text/css\"> body { font-family: \"Courier New\", sans-serif; text-align: center; } .buttons { font-size: 4em; display: flex; justify-content: center; } .button, .value { line-height: 1; padding: 2rem; margin: 2rem; border: medium solid; min-height: 1em; min-width: 1em; } .button { cursor: pointer; user-select: none; } .minus { color: red; } .plus { color: green; } .value { min-width: 2em; } .state { font-size: 2em; } </style> </head> <body> <div class=\"buttons\"> <div class=\"minus button\">-</div> <div class=\"value\">?</div> <div class=\"plus button\">+</div> </div> <div class=\"state\"> <span class=\"users\">?</span> online </div> <script> var minus = document.querySelector('.minus'), plus = document.querySelector('.plus'), value = document.querySelector('.value'), users = document.querySelector('.users'), websocket = new WebSocket(\"ws://127.0.0.1:6789/\"); minus.onclick = function (event) { websocket.send(JSON.stringify({action: 'minus'})); } plus.onclick = function (event) { websocket.send(JSON.stringify({action: 'plus'})); } websocket.onmessage = function (event) { data = JSON.parse(event.data); switch (data.type) { case 'state': value.textContent = data.value; break; case 'users': users.textContent = ( data.count.toString() + \" user\" + (data.count == 1 ? \"\" : \"s\")); break; default: console.error( \"unsupported event\", data); } }; </script> </body> </html> Observa c\u00f3mo el script env\u00eda mensajes de suma o resta en formato JSON acorde al esperado por el servidor, y procesa los mensajes de entrada actualizando la informaci\u00f3n mostrada en pantalla recibida acerca del valor del contador actualizado y n\u00famero de usuarios. Tarea Ejecuta el servidor en tu m\u00e1quina virtual, y m\u00faltiples clientes en distintas ventanas/pesta\u00f1as del navegador (con ventanas lo ver\u00e1s mejor). Interact\u00faa desde un cliente aumentando o reduciendo el valor del contador, y observa c\u00f3mo dicho valor es actualizado (a trav\u00e9s del servidor) en el resto de clientes abiertos. Conecta y desconecta nuevos clientes y observa tambi\u00e9n como el campo correspondiente en la p\u00e1gina web se actualiza correctamente. Si quieres, puedes analizar el tr\u00e1fico Websockets generado v\u00eda Wireshark. Websockets en el ESP32 El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9sd el componente websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente websocket client ofrece soporte para el protocolo websocket sobre TCP y tambi\u00e9n, opcionalmente, sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, sin intercambio de datos. WEBSOCKET_EVENT_DISCONNECTED : se emite en el instante de la desconexi\u00f3n entre cliente y servidor. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que accarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: const char * data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DISCONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256*data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( event_data ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:123\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos Websocket esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos. Ejemplo b\u00e1sico: cliente echo Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo examples/protocols/websockets . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (disponible en ws://websockets.org ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo? Ejercicio entregable: Comunicaci\u00f3n as\u00edncrona El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con el servidor Python que se prob\u00f3 en la secci\u00f3n anterior, y que implementaba comunicaci\u00f3n bidireccional para mantener y difundir el estado interno (contador y n\u00famero de clientes conectados) entre todos los clientes conectados. Para ello, se pide modificar el ejemplo de cliente echo para que: El cliente conecte con el servidor Python especificando su IP y puerto. El cliente sea cien por cien pasivo, es decir, no env\u00ede nunca mensajes al servidor. La funci\u00f3n de manejo de paquetes recibidos trate de forma especial el tipo de mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos tipos de mensajes de texto: Mensajes de estado: {\"type\": \"users\", \"count\": usuarios} Mensajes de usuarios: {\"type\": \"state\", \"value\": VALOR} Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con una representaci\u00f3n JSON de la informaci\u00f3n. Para tratarla desde ESP-IDF, puedes hacer uso del componente cJSON del framework . Por ejemplo, para tratar un mensaje de entrada de tipo \"state\", podr\u00edamos a\u00f1adir la siguiente secuencia de c\u00f3digo en nuestro manejador: #include \"cJSON.h\" // ... if( data->op_code == 1 ) { // Text frame only. cJSON *root = cJSON_Parse((char*)data->data_ptr); char *type = cJSON_GetObjectItem(root,\"type\")->valuestring; ESP_LOGI(TAG, \"type=%s\",type); int field = 0; if( strcmp( type, \"state\" ) == 0) { field = cJSON_GetObjectItem(root,\"value\")->valueint; ESP_LOGI(TAG, \"value=%d\",field); } } Tarea entregable Modifica el firmware de ejemplo websockets para que pueda comunicarse en modo lectura con el servidor Python que mantiene y publicita estado, cuyo c\u00f3digo se te proporciona. El programa ESP-IDF, al menos, mostar\u00e1 por pantalla un mensaje con los datos asociados cada vez que se reciban paquetes de tipo texto ( state o users ). Tambi\u00e9n mostrar\u00e1 un mensaje cada vez que el servidor env\u00ede un mensaje de tipo ping o pong (para ello, consulta el RFC que describe el protocolo para determinar el opcode asociado). Para comprobar el funcionamiento de la soluci\u00f3n, arranca el servidor y al menos dos clientes web. Cuando arranques el ESP32, ambos deber\u00e1n incrementar el n\u00famero de clientes reportado, en respuesta al mensaje enviado por el servidor. Cuando cualquiera de los clientes web incremente el valor del contador, el ESP32 recibir\u00e1 un mensaje con el valor actualizado, del mismo modo que cuando cierres uno de los navegadores web. Tarea opcional Modifica el c\u00f3digo para que el cliente, peri\u00f3dicamente, env\u00ede un mensaje de petici\u00f3n de suma o resta siguiendo las especificaciones y tipos de mensaje que se explicaron anteriormente.","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets"},{"location":"Subjects/NP2/P4/#practica-4-protocolos-basicos-de-capa-de-aplicacion-websockets","text":"","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets"},{"location":"Subjects/NP2/P4/#objetivos","text":"Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets . Estudar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar mecanismos de mantenimiento y publicaci\u00f3n de estado a clientes conectados, t\u00edpicos en un entorno IoT. Estudiar el componente websockets client en ESP-IDF, y desarrollar un firmware b\u00e1sico que interact\u00fae con un servidor Python. Introducir la gesti\u00f3n de objetos JSON en ESP-IDF. Los ficheros necesarios para completar la pr\u00e1ctica pueden descargarse aqu\u00ed .","title":"Objetivos"},{"location":"Subjects/NP2/P4/#ejemplo-basico-sistema-clienteservidor-usando-websockets-en-python-client1py-server1py","text":"En primer lugar, introducimos el uso del m\u00f3dulo Python websockets , que proporciona toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor utilizando websockets . El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste, tal y como hemos visto en otras pr\u00e1cticas. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea entregable Ejecuta el servidor en una terminal de tu m\u00e1quina virtual, y a continuaci\u00f3n el cliente en otra. Analiza el tr\u00e1fico intercambiado y responde a las siguientes preguntas: \u00bfEn qu\u00e9 protocolo de capa de transporte se basa la comunicaci\u00f3n v\u00eda Websockets? En la fase de handshake , \u00bfqu\u00e9 peticiones HTTP se intercambian? Analiza sus emisores y destinatarios, e investiga el cometido principal de cada uno de los campos de sus encabezados (f\u00edjate principalmente en el campo Upgrade y los campos espec\u00edficos para Websockets). En la fase de intercambio de datos, \u00bfqu\u00e9 opcode se especifica en el encabezado de cada paquete? \u00bfPor qu\u00e9? \u00bfSe env\u00edan los datos en claro o cifrados? \u00bfQu\u00e9 opcode se a\u00f1ade en los mensajes de cierre de conexi\u00f3n?","title":"Ejemplo b\u00e1sico: sistema cliente/servidor usando Websockets en Python (\u00b4client1.py, server1.py`)"},{"location":"Subjects/NP2/P4/#interactuando-con-un-navegador-web-client_for_webhtml-server_for_webpy","text":"Aunque fuera del inter\u00e9s de esta pr\u00e1ctica, es conveniente observar una de las ventajas de websockets : el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, y observarlo a trav\u00e9s de un navegador web convencional (la mayor\u00eda de navegadores modernos soportan websockets a trav\u00e9s de scripts Javascript ). En este caso, simplemente observa la interacci\u00f3n de un servidor websocket que env\u00eda mensajes que incluyen la hora actual separados un n\u00famero aleatorio de tiempo entre ellos: #!/usr/bin/env python # WS server that sends messages at random intervals import asyncio import datetime import random import websockets async def time(websocket, path): while True: now = datetime.datetime.utcnow().isoformat() + \"Z\" await websocket.send(now) await asyncio.sleep(random.random() * 3) start_server = websockets.serve(time, \"127.0.0.1\", 5678) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Con un cliente (una p\u00e1gina HTML) que establece la conexi\u00f3n v\u00eda websockets , y muestra en la misma un elemento de texto con la marca de tiempo recibida tras la recepci\u00f3n de cada mensaje: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> </head> <body> <script> var ws = new WebSocket(\"ws://127.0.0.1:5678/\"), messages = document.createElement('ul'); ws.onmessage = function (event) { var messages = document.getElementsByTagName('ul')[0], message = document.createElement('li'), content = document.createTextNode(event.data); message.appendChild(content); messages.appendChild(message); }; document.body.appendChild(messages); </script> </body> </html> Tarea Ejecuta el servidor en tu m\u00e1quina virtual y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con un navegador. Observa como la p\u00e1gina se actualiza a medida que recibe mensajes a trav\u00e9s del socket. Si quieres, puedes observar el intercambio de mensajes. \u00bfQu\u00e9 ocurre si, en otra pesta\u00f1a, vuelves a abrir la p\u00e1gina cliente?","title":"Interactuando con un navegador web (client_for_web.html, server_for_web.py)"},{"location":"Subjects/NP2/P4/#un-ejemplo-mas-complejo-sincronizacion-entre-multiples-clientes-server2py-clienthtml","text":"Un servidor websocket puede recibir eventos desde distintos clientes, procesarlos para, por ejemplo, mantener actualizado un estado a nivel de aplicaci\u00f3n, y sincronizar dicho estado entre todos los clientes conectados, envi\u00e1ndoles mensajes de forma as\u00edncrona a trav\u00e9s del socket bidireccional, a modo de \"notificaciones push \". A continuaci\u00f3n, se muestra el c\u00f3digo de un servidor que mantiene dos tipos de informaci\u00f3n de estado siempre actualizada: el valor de un contador ( STATE ), que puede ser modificado por los clientes conectados sumando o restando uno a su valor a trav\u00e9s de mensajes enviados por el socket ; y el n\u00famero de clientes conectados ( USERS ). #!/usr/bin/env python import asyncio import json import logging import websockets logging.basicConfig() STATE = {\"value\": 0} USERS = set() def state_event(): return json.dumps({\"type\": \"state\", **STATE}) def users_event(): return json.dumps({\"type\": \"users\", \"count\": len(USERS)}) async def notify_state(): if USERS: # asyncio.wait doesn't accept an empty list message = state_event() await asyncio.wait([user.send(message) for user in USERS]) async def notify_users(): if USERS: # asyncio.wait doesn't accept an empty list message = users_event() await asyncio.wait([user.send(message) for user in USERS]) async def register(websocket): USERS.add(websocket) await notify_users() async def unregister(websocket): USERS.remove(websocket) await notify_users() async def counter(websocket, path): # register(websocket) sends user_event() to websocket await register(websocket) try: await websocket.send(state_event()) async for message in websocket: data = json.loads(message) if data[\"action\"] == \"minus\": STATE[\"value\"] -= 1 await notify_state() elif data[\"action\"] == \"plus\": STATE[\"value\"] += 1 await notify_state() else: logging.error(\"unsupported event: {}\", data) finally: await unregister(websocket) start_server = websockets.serve(counter, \"localhost\", 6789) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Observa el c\u00f3digo del servidor. El manejador counter procesa cada conexi\u00f3n entrante, registrando a su entrada a un nuevo cliente en el sistema ( register ) y desregistr\u00e1ndolo antes de finalizar ( unregister ). Ante cada registro o desregistro, se notifica a los usuarios este hecho, enviando a cada cliente un peque\u00f1o texto en formato JSON cuyo contenido es: {\"type\": \"users\", \"count\": usuarios} Es decir, un mensaje con dos campos (veremos JSON en la pr\u00f3xima pr\u00e1ctica): campo type , con valor fijo users , y campo count , con un valor entero que indica el n\u00famero de clientes conectados. A continuaci\u00f3n, para cada mensaje recibido a trav\u00e9s del socket, \u00e9ste se procesa, esperando tambi\u00e9n un fichero JSON con la acci\u00f3n que el cliente solicita (sumar o restar 1 al contador), por ejemplo: {\"action\": \"minus\"} o {\"action\": \"plus\"} En funci\u00f3n de la acci\u00f3n solicitada, el servidor actualiza el valor de STATE , y env\u00eda (rutina notify_state ) dicho valor actualizado a TODOS los clientes conectados mediante un peque\u00f1o mensaje de texto en formato JSON: {\"type\": \"state\", \"value\": VALOR} La parte cliente sigue la misma filosof\u00eda, utilizando de nuevo el navegador como plataforma para visualizar la interacci\u00f3n con el cliente. El c\u00f3digo HTML que puedes abrir en tu navegador es el siguiente: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> <style type=\"text/css\"> body { font-family: \"Courier New\", sans-serif; text-align: center; } .buttons { font-size: 4em; display: flex; justify-content: center; } .button, .value { line-height: 1; padding: 2rem; margin: 2rem; border: medium solid; min-height: 1em; min-width: 1em; } .button { cursor: pointer; user-select: none; } .minus { color: red; } .plus { color: green; } .value { min-width: 2em; } .state { font-size: 2em; } </style> </head> <body> <div class=\"buttons\"> <div class=\"minus button\">-</div> <div class=\"value\">?</div> <div class=\"plus button\">+</div> </div> <div class=\"state\"> <span class=\"users\">?</span> online </div> <script> var minus = document.querySelector('.minus'), plus = document.querySelector('.plus'), value = document.querySelector('.value'), users = document.querySelector('.users'), websocket = new WebSocket(\"ws://127.0.0.1:6789/\"); minus.onclick = function (event) { websocket.send(JSON.stringify({action: 'minus'})); } plus.onclick = function (event) { websocket.send(JSON.stringify({action: 'plus'})); } websocket.onmessage = function (event) { data = JSON.parse(event.data); switch (data.type) { case 'state': value.textContent = data.value; break; case 'users': users.textContent = ( data.count.toString() + \" user\" + (data.count == 1 ? \"\" : \"s\")); break; default: console.error( \"unsupported event\", data); } }; </script> </body> </html> Observa c\u00f3mo el script env\u00eda mensajes de suma o resta en formato JSON acorde al esperado por el servidor, y procesa los mensajes de entrada actualizando la informaci\u00f3n mostrada en pantalla recibida acerca del valor del contador actualizado y n\u00famero de usuarios. Tarea Ejecuta el servidor en tu m\u00e1quina virtual, y m\u00faltiples clientes en distintas ventanas/pesta\u00f1as del navegador (con ventanas lo ver\u00e1s mejor). Interact\u00faa desde un cliente aumentando o reduciendo el valor del contador, y observa c\u00f3mo dicho valor es actualizado (a trav\u00e9s del servidor) en el resto de clientes abiertos. Conecta y desconecta nuevos clientes y observa tambi\u00e9n como el campo correspondiente en la p\u00e1gina web se actualiza correctamente. Si quieres, puedes analizar el tr\u00e1fico Websockets generado v\u00eda Wireshark.","title":"Un ejemplo m\u00e1s complejo: sincronizaci\u00f3n entre m\u00faltiples clientes (server2.py, client.html)"},{"location":"Subjects/NP2/P4/#websockets-en-el-esp32","text":"El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9sd el componente websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente websocket client ofrece soporte para el protocolo websocket sobre TCP y tambi\u00e9n, opcionalmente, sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, sin intercambio de datos. WEBSOCKET_EVENT_DISCONNECTED : se emite en el instante de la desconexi\u00f3n entre cliente y servidor. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que accarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: const char * data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DISCONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256*data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( event_data ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:123\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos Websocket esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos.","title":"Websockets en el ESP32"},{"location":"Subjects/NP2/P4/#ejemplo-basico-cliente-echo","text":"Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo examples/protocols/websockets . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (disponible en ws://websockets.org ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo?","title":"Ejemplo b\u00e1sico: cliente echo"},{"location":"Subjects/NP2/P4/#ejercicio-entregable-comunicacion-asincrona","text":"El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con el servidor Python que se prob\u00f3 en la secci\u00f3n anterior, y que implementaba comunicaci\u00f3n bidireccional para mantener y difundir el estado interno (contador y n\u00famero de clientes conectados) entre todos los clientes conectados. Para ello, se pide modificar el ejemplo de cliente echo para que: El cliente conecte con el servidor Python especificando su IP y puerto. El cliente sea cien por cien pasivo, es decir, no env\u00ede nunca mensajes al servidor. La funci\u00f3n de manejo de paquetes recibidos trate de forma especial el tipo de mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos tipos de mensajes de texto: Mensajes de estado: {\"type\": \"users\", \"count\": usuarios} Mensajes de usuarios: {\"type\": \"state\", \"value\": VALOR} Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con una representaci\u00f3n JSON de la informaci\u00f3n. Para tratarla desde ESP-IDF, puedes hacer uso del componente cJSON del framework . Por ejemplo, para tratar un mensaje de entrada de tipo \"state\", podr\u00edamos a\u00f1adir la siguiente secuencia de c\u00f3digo en nuestro manejador: #include \"cJSON.h\" // ... if( data->op_code == 1 ) { // Text frame only. cJSON *root = cJSON_Parse((char*)data->data_ptr); char *type = cJSON_GetObjectItem(root,\"type\")->valuestring; ESP_LOGI(TAG, \"type=%s\",type); int field = 0; if( strcmp( type, \"state\" ) == 0) { field = cJSON_GetObjectItem(root,\"value\")->valueint; ESP_LOGI(TAG, \"value=%d\",field); } } Tarea entregable Modifica el firmware de ejemplo websockets para que pueda comunicarse en modo lectura con el servidor Python que mantiene y publicita estado, cuyo c\u00f3digo se te proporciona. El programa ESP-IDF, al menos, mostar\u00e1 por pantalla un mensaje con los datos asociados cada vez que se reciban paquetes de tipo texto ( state o users ). Tambi\u00e9n mostrar\u00e1 un mensaje cada vez que el servidor env\u00ede un mensaje de tipo ping o pong (para ello, consulta el RFC que describe el protocolo para determinar el opcode asociado). Para comprobar el funcionamiento de la soluci\u00f3n, arranca el servidor y al menos dos clientes web. Cuando arranques el ESP32, ambos deber\u00e1n incrementar el n\u00famero de clientes reportado, en respuesta al mensaje enviado por el servidor. Cuando cualquiera de los clientes web incremente el valor del contador, el ESP32 recibir\u00e1 un mensaje con el valor actualizado, del mismo modo que cuando cierres uno de los navegadores web. Tarea opcional Modifica el c\u00f3digo para que el cliente, peri\u00f3dicamente, env\u00ede un mensaje de petici\u00f3n de suma o resta siguiendo las especificaciones y tipos de mensaje que se explicaron anteriormente.","title":"Ejercicio entregable: Comunicaci\u00f3n as\u00edncrona"},{"location":"Subjects/NP2/P5/","text":"Pr\u00e1ctica 5. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR Objetivos Entender los mecanismos ofrecidos por ESP-IDF para la creaci\u00f3n de un servidor REST HTTP. Implementar, a trav\u00e9s de los mecanismos ofrecidos por ESP-IDF, una API REST extendida en el ESP32. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de JSON. Implementar, a trav\u00e9s de la biblioteca cJSON , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de CBOR, y evaluar sus ventajas con respecto a JSON. Implementar, a trav\u00e9s de la biblioteca tinycbor , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor, comparando los tama\u00f1os de payload con respecto al intercambio JSON. Desarrollo de un servidor REST en ESP-IDF En la primera parte de la pr\u00e1ctica, veremos c\u00f3mo desarrollar, utilizando las funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API REST mediante la cual ser\u00e1 posible interactuar, en modos lectura y escritura, con un servidor (en nuestro caso, un dispositivo ESP32). Concretamente, trabajaremos con el ejemplo example/protocols/http_server/rest_server de la distribuci\u00f3n de IDF (versi\u00f3n 4.1). Descripci\u00f3n de la API El ejemplo que estudiaremos construye una sencilla interfaz (API) con tres endpoints que permiten interactuar con distintas funcionalidades del ESP32. N\u00f3tese que tanto las URLs como la funcionalidad asociada a ellas es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades de nuestra aplicaci\u00f3n. La siguiente tabla resume la funcionalidad de cada endpoint , as\u00ed como posibles ejemplos de valores enviados o devueltos a/por el servidor: API M\u00e9todo Ejemplo de recurso le\u00eddo/escrito Descripci\u00f3n URL /api/v1/system/info GET { version:\"v4.0-dev\", cores:2 } Utilizado por los clientes para obtener informaci\u00f3n de la placa (versi\u00f3n, n\u00famero de cores, ...) / /api/v1/temp/raw GET { raw:22 } Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32) /chart /api/v1/light/brightness POST { red:160, green:160, blue:160 } Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs /light Configuraci\u00f3n y compilaci\u00f3n del ejemplo En primer lugar, configura, compila y flashea el ejemplo mencionado. En este caso, las instrucciones se dividen en dos partes: compilaci\u00f3n del firmware para el ESP32, y preparaci\u00f3n de un cliente web sencillo que nos permitir\u00e1 observar la interacci\u00f3n con el mismo. Esta \u00faltima parte no es estrictamente necesaria, pero nos ayudar\u00e1 en la interacci\u00f3n con el dispositivo de forma visual hasta que veamos c\u00f3mo hacerlo a trav\u00e9s de l\u00ednea de comandos. A trav\u00e9s del men\u00fa de configuraci\u00f3n, configura un nombre para el dispositivo (por ejemplo, 'esp_home_tunombre'), e indica que el modo de despliegue ( Website deploy mode ) sea Deploy website to SPI Nor Flash . Por \u00faltimo, configura las credenciales del punto de acceso WiFi al que conectar\u00e1, siguiendo la metodolog\u00eda habitual. En segundo lugar, necesitamos instalar los componentes necesarios para desplegar el cliente web. Para ello, navega al subdirectorio front/web-demo , donde reside el c\u00f3digo fuente del cliente. Ejecuta los siguientes comandos para instalar las dependencias necesarias: sudo apt-get install npm node-vue* npm install npm run build En este punto, ya podr\u00e1s ejecutar, desde el directorio base del ejemplo, la orden de compilaci\u00f3n y flasheado: idf.py build idf.py flash idf.py monitor Interacci\u00f3n con el dispositivo v\u00eda interfaz web Si todo ha ido bien, podr\u00e1s observar en la salida de monitorizaci\u00f3n la IP proporcionada al ESP32. Abre un navegador en la m\u00e1quina virtual o en tu PC (estando conectada a la misma red que tu ESP32), navega hacia la direcci\u00f3n IP del ESP32, y deber\u00edas observar una p\u00e1gina como la siguiente: Esta es una p\u00e1gina web servida por el propio ESP32, que te permitir\u00e1 interactuar con \u00e9l. Concretamente, la p\u00e1gina dispone de dos funcionalidades: Chart : consulta peri\u00f3dicamente el valor de temperatura devuelto por el ESP32 a trav\u00e9s del endpoint /api/v1/temp/raw . Light : permite enviar al ESP32 nuevos valores para las tres componentes de luminosidad que hipot\u00e9ticamente podr\u00eda equipar el ESP32. Tarea Interact\u00faa con el sensor de luminosidad del ESP32 enviando distintos valores. Observa c\u00f3mo la salida de monitorizaci\u00f3n del ESP32 responde mostrando los valores recibidos. Analiza el tr\u00e1fico generado para una de dichas peticiones utilizando Wireshark. \u00bfC\u00f3mo se codifican los datos en el env\u00edo? \u00bfC\u00f3mo se codifican los datos peri\u00f3dicos de temperatura recibidos? Interacci\u00f3n con el dispositivo v\u00eda l\u00ednea de comandos ( curl ) curl es una herramienta orientada a la transferencia de archivos por red. Entre otras (muchas) funcionalidades, curl soporta los m\u00e9todos GET y PUT del protocolo HTTP, justo las necesarias para realizar peticiones de lectura y escritura sobre nuestro servidor HTTP REST. Concretamente, para realizar una petici\u00f3n HTTP GET sobre nuestro servidor, podemos ejecutar: curl http://IP/URI Por ejemplo, la petici\u00f3n: curl http://192.168.1.26/api/v1/temp/raw (siendo 192.168.1.26 la IP del ESP32) nos responder\u00e1 con el valor de temperatura instant\u00e1nea. Del mismo modo, para escribir (m\u00e9todo POST ) sobre el servidor, utilizaremos el par\u00e1metro -d , seguido del recurso que queramos enviar. Ten en cuenta que es responsabilidad del cliente enviar un recurso bien formado e interpretable por el dispositivo: curl -d '{\"red\":70,\"green\":80,\"blue\":99}' -H \"Content-Type: application/json\" -X POST http://192.168.1.26/api/v1/light/brightness Observa que hemos incluido el tipo de recurso enviado ( JSON ) y la operacion solicitada ( POST ). Volveremos a esto en breve. Tarea Comprueba que, efectivamente, el tr\u00e1fico generado por las anteriores \u00f3rdenes es el mismo que el que observaste en el caso del cliente web. Observa qu\u00e9 ocurre si consultas un endpoint inexistente, o si env\u00edas un JSON mal formado o con informaci\u00f3n incorrecta. Implementaci\u00f3n de un servidor HTTP con API REST La implementaci\u00f3n de un servidor HTTP en ESP-IDF se delega al componente HTTP Server , que implementa toda la funcionalida necesaria para tal fin de forma eficiente y ligera. La construcci\u00f3n de un servidor puede resumirse en tres funciones principales (observa la implementaci\u00f3n de la funcion start_rest_server en el fichero rest_server.c ) del ejemplo: httpd_start : crea una instancia de servidor HTTP, y aloja recursos para ella seg\u00fan la configuraci\u00f3n proporcionada. En funci\u00f3n del tr\u00e1fico generado (URIs solicitadas), se utilizar\u00e1n manejadores espec\u00edficos definidos por el usuario para analizarlo y, en caso necesario, enviar respuestas al cliente correspondiente. httpd_stop : finaliza el servidor HTTP, cerrando cualquier conexi\u00f3n previamente establecida con clientes. httpd_register_uri_handler : registra un manejador (una funci\u00f3n definida por el usuario) para tratar una petici\u00f3n sobre una URI determinada. La estructura proporcionada dispone de campos para indicar la URI destino ( uri ), el m\u00e9todo que se espera recibir ( method , por ejemplo HTTPD_GET o HTTPD_POST ) y un puntero a una funci\u00f3n que procesar\u00e1 la petici\u00f3n recibida a trav\u00e9s de la URI indicada. Dicha funci\u00f3n s\u00f3lo se ejecutar\u00e1 si el m\u00e9todo coincide con el indicado. La funci\u00f3n start_rest_server del ejemplo proporciona los mecanismos b\u00e1sicos para la creaci\u00f3n de la API anteriormente descrita. As\u00ed, para crear el endpoint /api/v1/system/info , procederemos, en primer lugar, registr\u00e1ndolo en el servidor, preparando previamente la estructura de tipo httpd_uri_t : httpd_uri_t system_info_get_uri = { .uri = \"/api/v1/system/info\", .method = HTTP_GET, .handler = system_info_get_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &system_info_get_uri); En este caso, la operaci\u00f3n asociada a la invocaci\u00f3n del handler ser\u00e1, exclusivamente GET ; de hecho, si invocamos a un m\u00e9todo POST sobre este endpoint , el servidor nos responder\u00e1 autom\u00e1ticamente con un aviso que indicar\u00e1 que dicho m\u00e9todo no est\u00e1 soportado. El procesamiento de la petici\u00f3n GET se realiza en la funci\u00f3n system_info_get_handler , y el esquema que se sigue es, en cualquier caso, sencillo: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de respuesta. httpd_resp_set_type(req, \"application/json\"); // Preparaci\u00f3n del buffer de respuesta. char * buffer = // En el ejemplo preparamos un buffer JSON. // Env\u00edo de respuesta. https_resp_sendstr( req, buffer ); return ESP_OK; Alternativamente, si la respuesta es binaria, podr\u00edamos utilizar la funci\u00f3n https_resp_send( req, buffer, buffer_len ) para procesarla y enviarla (lo necesitar\u00e1s para enviar un buffer binario CBOR). La creaci\u00f3n de un endpoint con soporte para m\u00e9todo POST resulta algo m\u00e1s larga, aunque el registro del mismo no difiere del ejemplo anterior: /* URI handler for light brightness control */ httpd_uri_t light_brightness_post_uri = { .uri = \"/api/v1/light/brightness\", .method = HTTP_POST, .handler = light_brightness_post_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &light_brightness_post_uri); Observa el cuerpo de la funci\u00f3n light_brightness_post_handler . La recepci\u00f3n del objeto enviado por parte del cliente se realiza en base a m\u00faltiples invocaciones a la rutina httpd_req_recv : /* Simple handler for light brightness control */ static esp_err_t light_brightness_post_handler(httpd_req_t *req) { int total_len = req->content_len; int cur_len = 0; char *buf = ((rest_server_context_t *)(req->user_ctx))->scratch; int received = 0; if (total_len >= SCRATCH_BUFSIZE) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"content too long\"); return ESP_FAIL; } while (cur_len < total_len) { received = httpd_req_recv(req, buf + cur_len, total_len); if (received <= 0) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"Failed to post control value\"); return ESP_FAIL; } cur_len += received; } buf[total_len] = '\\0'; /// A partir de este punto, disponemos en buf del objeto recibido v\u00eda HTTP. /// ... Tarea entregable Observa y estudia los c\u00f3digos de los manejadores implementados en el ejemplo. Extiende la API proporcionada para crear un nuevo endpoint que permita obtener la temperatura (n\u00famero aleatorio), pero transform\u00e1ndola a grados Fahrenheit. En este caso, el valor devuelto en el fichero JSON ser\u00e1 un n\u00famero en punto flotante (en la siguiente secci\u00f3n te se explicar\u00e1 c\u00f3mo hacerlo, por lo que de momento puedes enviar \u00fanicamente la parte entera del mismo). Representaci\u00f3n de la informaci\u00f3n. JSON JSON es un formato de representaci\u00f3n de datos en modo texto para el intercambio de datos entre sistemas inform\u00e1ticos. Se cre\u00f3 inicialmente como una notaci\u00f3n literal de los objetos Javascript, pero dada su amplia aceptaci\u00f3n (realmente como alternativa a XML), se considera a d\u00eda de hoy un componente totalmente independiente al lenguaje. Los tipos de datos soportados por JSON incluyen: Valores num\u00e9ricos: permitiendo n\u00fameros con y sin signo, y con parte decimla en notaci\u00f3n separada por puntos. Cadenas: secuencias de cero o m\u00e1s caracteres. Booleanos: true y false . Arrays: listas ordenadas de cero o m\u00e1s valores de cualquier tipo, separados por comas y encerrados entre corchetes. Objetos: colecciones no ordenadas de pares <nombre>:<valor> , separados por comas y encerrados entre llaves. ESP-IDF incluye el componente cJSON para parsear y construir objetos de tipo JSON de forma sencilla y consistente. La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, v\u00e9ase: /* The cJSON structure: */ typedef struct cJSON { struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; double valuedouble; char *string; } cJSON; El campo type informa sobre el tipo de dato contenido en el objeto, v\u00e9ase: cJSON_False ( cJSON_IsFalse() ): representa un valor booleano falso. cJSON_True ( cJSON_IsTrue() ): representa un valor booleano verdadero. cJSON_NULL ( cJSON_IsNULL() ): representa un valor nulo. cJSON_Number ( cJSON_IsNumber() ): representa un valor num\u00e9rico. Dicho valor se almacena en el campo valuedouble como flotante y en valueint como entero. cJSON_String ( cJSON_IsString() ): representa un valor cadena, y se almacena en el campo valuestring como un array de bytes terminado por el car\u00e1cter nulo ('\\0'). cJSON_Array ( cJSON_IsArray() ): representa un array de valores. En el campo child se almacena una lista enlazada con los elementos del array, terminada en NULL. cJSON_Object ( cJSON_IsObject() ): representa un valor objeto. Sus valores se almacenan de la misma manera que el array anterior, pero en el campo string se almacenan adem\u00e1s las claves del objeto a modo de lista. Creaci\u00f3n y parseado de una estructura JSON Para cada tipo de datos, existe una rutina asociada con nombre cJSON_Create... que permite crear un item del tipo correspondiente. Todas estas funciones alojan memoria suficiente como para albergar el dato creado. Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo) utilizando la funci\u00f3n cJSON_Parse : cJSON * json = cJSON_Parse( string ); Para imprimir el contenido de una estructura JSON en modo texto, podemos hacer uso de la funci\u00f3n cJSON_Print(json) : char * string = cJSON_Print( json ); Ejemplos Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor REST. Concretamente, c\u00e9ntrate en la funci\u00f3n system_info_get_handler , que construye un objeto JSON con dos campos, de tipo cadena (\"version\") y num\u00e9rico (\"cores\"): /* Simple handler for getting system handler */ static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de datos de la respuesta. httpd_resp_set_type(req, \"application/json\"); // Creaci\u00f3n del objeto JSON. cJSON *root = cJSON_CreateObject(); // Obtenci\u00f3n del dato. esp_chip_info_t chip_info; esp_chip_info(&chip_info); // Anyadimos un campo de tipo cadena. cJSON_AddStringToObject(root, \"version\", IDF_VER); // Anyadimos un campo de tipo num\u00e9rico. cJSON_AddNumberToObject(root, \"cores\", chip_info.cores); // Imprimimos a cadena previo al env\u00edo. const char *sys_info = cJSON_Print(root); // Enviamos cabecera + objeto JSON en modo texto v\u00eda HTTP. httpd_resp_sendstr(req, sys_info); // Liberamos recursos. free((void *)sys_info); // Liberamos recursos del objeto JSON. cJSON_Delete(root); return ESP_OK; } La funci\u00f3n light_brightness_post_handler realiza un parseado del objeto JSON recibido. Observa su cuerpo: // buf contiene la cadena recibida a trav\u00e9s de HTTP (m\u00e9todo POST). // ... // Parseamos el objeto JSON. cJSON *root = cJSON_Parse(buf); // Obtenemos tres valores num\u00e9ricos (RGB). int red = cJSON_GetObjectItem(root, \"red\")->valueint; int green = cJSON_GetObjectItem(root, \"green\")->valueint; int blue = cJSON_GetObjectItem(root, \"blue\")->valueint; // Mostramos por pantalla los valores parseados. ESP_LOGI(REST_TAG, \"Light control: red = %d, green = %d, blue = %d\", red, green, blue); // Liberamos recursos JSON. cJSON_Delete(root); // Enviamos una respuesta generica en modo texto. httpd_resp_sendstr(req, \"Post control value successfully\"); return ESP_OK; Tarea entregable Extiende la tarea anterior para a\u00f1adir el dato en formato punto flotante de la temperatura en grados Fahrenheit. Tarea entregable Crea un nuevo endpoint que utilice un formato m\u00e1s complejo de objetos JSON, incluyendo distintos tipos de datos que puedan dar respuesta a un hipot\u00e9tico entorno IoT. Documenta la API generada y el formato de los objetos que has dise\u00f1ado. Puedes, si as\u00ed lo deseas, incluir capturas Wireshark para ilustrar el intercambio de mensajes producido. Nos interesar\u00e1, especialmente, el n\u00famero de bytes transportados para enviar/recibir tus mensajes JSON. Representaci\u00f3n de la informaci\u00f3n. CBOR CBOR ( Concise Binary Object Representation ) es el formato de serializaci\u00f3n de datos recomendado en muchos de los stacks IoT, espec\u00edficamente en aquellos basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con JSON, ya que sigue su mismo modelo de datos: valores num\u00e9ricos, strings , arrays, mapas (objetos en JSON) y valores booleanos y nulos. Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en este punto radica una de sus ventajas: es posible intercambiar datos entre un cliente y un servidor sin ce\u00f1irse a un esquema de datos concreto conocido por ambas partes. El hecho de ser un formato binario implica mejoras sustanciales con respecto a JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos gr\u00e1ficos, o valores flotantes sensorizados, entre otros muchos); estos datos sol\u00edan codificarse en JSON utilizando, por ejemplo, formato base64 , a\u00f1adiendo complejidad al proceso de codificaci\u00f3n/decodificaci\u00f3n. En general, el uso de un formato binario implica menor complejidad a la hora de ser integrado en aplicaciones, y es por esta raz\u00f3n por la que se considera \u00f3ptimo para nodos de bajas prestaciones, t\u00edpicos en IoT. El formato CBOR est\u00e1 documentado en el RFC 7049 , y por tanto se considera un est\u00e1ndar bien documentado y estable de cara al futuro. CBOR en el ESP32 ESP-IDF incluye la biblioteca tinyCBOR como implementaci\u00f3n ligera del est\u00e1ndar, que permite tanto codificar distintos tipos de datos a formato CBOR, parsear estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable como a JSON. TinyCBOR est\u00e1 mantenido como proyecto de software libre por parte de Intel, y su documentaci\u00f3n detallada (se sugiere consultarla) se encuentra disponible en el siguiente enlace . Estudiaremos el funcionamiento de tinyCBOR a trav\u00e9s de un ejemplo funcional (lo puedes encontrar en examples/protocols/cbor ). El ejemplo muestra los mecanismos necesarios para, en primer lugar, crear un objeto CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo para convertir dicho objeto a representaci\u00f3n JSON, as\u00ed como para parsearlo manualmente. En primer lugar, compila, flashea y ejecuta el ejemplo. Ver\u00e1s que la salida deber\u00eda ser similar a la siguiente: I (320) example: encoded buffer size 67 I (320) example: convert CBOR to JSON [{\"chip\":\"esp32\",\"unicore\":false,\"ip\":[192,168,1,100]},3.1400001049041748,\"simple(99)\",\"2019-07-10 09:00:00+0000\",\"undefined\"] I (340) example: decode CBOR manually Array[ Map{ chip esp32 unicore false ip Array[ 192 168 1 100 ] } 3.14 simple(99) 2019-07-10 09:00:00+0000 undefined ] Observa que la estructura del objeto CBOR ser\u00e1 medianamente compleja: constar\u00e1 de un array formado por cinco elementos: Un mapa (conjunto no ordenado de pares clave-valor ), combinando cadenas, booleanos y un segundo array para especificar una direcci\u00f3n IP. Un valor flotante (3.14). Un valor num\u00e9rico \"simple\" (99). Una fecha (en forma de cadena). Un valor indefinido. El firmware procede en tres etapas: Etapa 1: creaci\u00f3n (codificaci\u00f3n) del objeto CBOR Observa el cuerpo de la tarea principal ( app_main ). El codificador CBOR se basa en dos variables: CborEncoder Root_encoder; // Codificador CBOR. uint8_t buf[100]; // Buffer para alojar el objeto CBOR (array de bytes). En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos constructores especiales para dichos objetos: // Creaci\u00f3n de Array. CborEncoder array_encoder; CborEncoder map_encoder; cbor_encoder_create_array(&root_encoder, &array_encoder, 5); // [ // 1. Creaci\u00f3n del Mapa. cbor_encoder_create_map(&array_encoder, &map_encoder, 3); // { A partir de este punto, podemos proceder con la construcci\u00f3n de los objetos siguiendo el esquema deseado: // chip: esp32 (cadena:cadena) cbor_encode_text_stringz(&map_encoder, \"chip\"); cbor_encode_text_stringz(&map_encoder, \"esp32\"); // unicore: false (cadena:booleano) cbor_encode_text_stringz(&map_encoder, \"unicore\"); cbor_encode_boolean(&map_encoder, false); // IP:[192,168,1,100] (cadena:array) cbor_encode_text_stringz(&map_encoder, \"ip\"); CborEncoder array2; cbor_encoder_create_array(&map_encoder, &array2, 4); // [ // Valores num\u00e9ricos. cbor_encode_uint(&array2, 192); cbor_encode_uint(&array2, 168); cbor_encode_uint(&array2, 1); cbor_encode_uint(&array2, 100); cbor_encoder_close_container(&map_encoder, &array2); // ] cbor_encoder_close_container(&array_encoder, &map_encoder); // } // 2. Flotante cbor_encode_float(&array_encoder, 3.14); // 3. Valor simple cbor_encode_simple_value(&array_encoder, 99); // 4. Cadena cbor_encode_text_stringz(&array_encoder, \"2019-07-10 09:00:00+0000\"); // 5. Undefined value. cbor_encode_undefined(&array_encoder); cbor_encoder_close_container(&root_encoder, &array_encoder); // ] // Mostramos el tama\u00f1o del buffer creado. ESP_LOGI(TAG, \"encoded buffer size %d\", cbor_encoder_get_buffer_size(&root_encoder, buf)); Etapa 2: conversi\u00f3n a JSON La conversi\u00f3n a JSON (t\u00edpicamente por motivos de visualizaci\u00f3n o depuraci\u00f3n), puede realizarse del siguiente modo: // Initialize the cbor parser and the value iterator cbor_parser_init(buf, sizeof(buf), 0, &root_parser, &it); ESP_LOGI(TAG, \"convert CBOR to JSON\"); // Dump the values in JSON format cbor_value_to_json(stdout, &it, 0); Etapa 3: parseado manual de un objeto CBOR Por \u00faltimo, el parseado manual del objeto CBOR se deja como ejercicio de estudio para el alumno, y est\u00e1 implementado en la funci\u00f3n example_dump_cbor_buffer del ejemplo. B\u00e1sicamente, la funci\u00f3n itera por cada uno de los elementos del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia. Para aquellos tipos complejos (e.g. arrays o mapas), la funci\u00f3n se invoca recursivamente hasta encontrar un elemento de tipo b\u00e1sico. En este caso, simplemente imprime por pantalla su valor (e.g. en el caso de un entero, caso CborIntegerType ). Tarea entregable Se pide extender la API REST con un nuevo endpoint que permita obtener la misma informaci\u00f3n que el endpoint JSON desarrollado en la anterior tarea, pero en esta ocasi\u00f3n, utilizando formato CBOR. El objetivo del ejercicio es comparar la cantidad de tr\u00e1fico generado en cada representaci\u00f3n, por lo que se sugiere que el objeto intercambiado sea relativamente complejo (es decir, incluya disintos tipos de datos num\u00e9ricos, arrays, o mapas). A continuaci\u00f3n se incluyen notas adicionales que te permitir\u00e1n depurar tu desarrollo, observando los valores devueltos por el servidor HTTP. Notas adicionales: creaci\u00f3n y consulta de un endpoint CBOR en la API REST Las modificaciones a realizar en la funci\u00f3n manejadora del endpoint para responder con un objeto CBOR son m\u00ednimas. De hecho, se centran simplemente en el tipo de respuesta y el mecanismo a usar para enviarla, v\u00e9ase: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Tipo de respuesta. httpd_resp_set_type(req, \"application/cbor\"); CborEncoder root_encoder; uint8_t buf[100]; // Codificador CBOR. cbor_encoder_init(&root_encoder, buf, sizeof(buf), 0); // Codificamos CBOR. // ... // Enviamos respuesta, consultando previamente el tama\u00f1o del buffer codificado. httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &root_encoder, buf)); return ESP_OK; Para consultar desde l\u00ednea de comandos sobre este endpoint , podemos utilizar directamente curl , volcando la salida recibida a un fichero (por ejemplo, output.cbor ): curl http://192.168.1.26/api/v1/system/info > output.cbor Si visualizas el contenido del fichero, ver\u00e1s que contiene datos binarios dif\u00edcilmente interpretables. A continuaci\u00f3n veremos distintos mecanismos de visualizaci\u00f3n. Notas adicionales: visualizaci\u00f3n de datos CBOR Una opci\u00f3n de visualizaci\u00f3n consiste en utilizar la web cbor.me . En el panel derecho, podr\u00e1s pegar el contenido binario le\u00eddo. Si necesitas realizar la conversi\u00f3n antes de pegarlo en la web, puedes hacerlo con la orden: xxd -ps output.cbor Un ejemplo de salida (a pegar en el panel derecho de la web), podr\u00eda ser: $ xxd -ps output.cbor 85a3646368697065657370333267756e69636f7265f46269708418c018a8 011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30 302b30303030f7 Deber\u00edas observar una salida similar a la siguiente (ten en cuenta que la herramiente autom\u00e1ticamente indenta el contenido del panel derecho; recuerda que simplemente debes pegar la salida generada por xxd ): Otra opci\u00f3n de visualizaci\u00f3n puede ser un programa Python (podr\u00edas integrarlo en tu servidor TCP/UDP, por ejemplo), que haga uso del m\u00f3dulo cbor2 ( documentaci\u00f3n ). Para comprobar su funcionamiento, primero inst\u00e1lalo: pip install cbor2 Y comprueba si efectivamente funciona utilizando el siguiente programa Python: from cbor2 import dumps, loads, dump, load with open('output.cbor', 'rb') as fp: obj = load(fp) print(obj) Al ejecutarlo, observar\u00e1s el contenido del objeto: python cbor.py [{'chip': 'esp32', 'unicore': False, 'ip': [192, 168, 1, 100]}, 3.140000104904175, CBORSimpleValue(value=99), '2019-07-10 09:00:00+0000', undefined]","title":"Pr\u00e1ctica 5. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR"},{"location":"Subjects/NP2/P5/#practica-5-servidores-rest-y-representacion-de-la-informacion-json-y-cbor","text":"","title":"Pr\u00e1ctica 5. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR"},{"location":"Subjects/NP2/P5/#objetivos","text":"Entender los mecanismos ofrecidos por ESP-IDF para la creaci\u00f3n de un servidor REST HTTP. Implementar, a trav\u00e9s de los mecanismos ofrecidos por ESP-IDF, una API REST extendida en el ESP32. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de JSON. Implementar, a trav\u00e9s de la biblioteca cJSON , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de CBOR, y evaluar sus ventajas con respecto a JSON. Implementar, a trav\u00e9s de la biblioteca tinycbor , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor, comparando los tama\u00f1os de payload con respecto al intercambio JSON.","title":"Objetivos"},{"location":"Subjects/NP2/P5/#desarrollo-de-un-servidor-rest-en-esp-idf","text":"En la primera parte de la pr\u00e1ctica, veremos c\u00f3mo desarrollar, utilizando las funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API REST mediante la cual ser\u00e1 posible interactuar, en modos lectura y escritura, con un servidor (en nuestro caso, un dispositivo ESP32). Concretamente, trabajaremos con el ejemplo example/protocols/http_server/rest_server de la distribuci\u00f3n de IDF (versi\u00f3n 4.1).","title":"Desarrollo de un servidor REST en ESP-IDF"},{"location":"Subjects/NP2/P5/#descripcion-de-la-api","text":"El ejemplo que estudiaremos construye una sencilla interfaz (API) con tres endpoints que permiten interactuar con distintas funcionalidades del ESP32. N\u00f3tese que tanto las URLs como la funcionalidad asociada a ellas es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades de nuestra aplicaci\u00f3n. La siguiente tabla resume la funcionalidad de cada endpoint , as\u00ed como posibles ejemplos de valores enviados o devueltos a/por el servidor: API M\u00e9todo Ejemplo de recurso le\u00eddo/escrito Descripci\u00f3n URL /api/v1/system/info GET { version:\"v4.0-dev\", cores:2 } Utilizado por los clientes para obtener informaci\u00f3n de la placa (versi\u00f3n, n\u00famero de cores, ...) / /api/v1/temp/raw GET { raw:22 } Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32) /chart /api/v1/light/brightness POST { red:160, green:160, blue:160 } Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs /light","title":"Descripci\u00f3n de la API"},{"location":"Subjects/NP2/P5/#configuracion-y-compilacion-del-ejemplo","text":"En primer lugar, configura, compila y flashea el ejemplo mencionado. En este caso, las instrucciones se dividen en dos partes: compilaci\u00f3n del firmware para el ESP32, y preparaci\u00f3n de un cliente web sencillo que nos permitir\u00e1 observar la interacci\u00f3n con el mismo. Esta \u00faltima parte no es estrictamente necesaria, pero nos ayudar\u00e1 en la interacci\u00f3n con el dispositivo de forma visual hasta que veamos c\u00f3mo hacerlo a trav\u00e9s de l\u00ednea de comandos. A trav\u00e9s del men\u00fa de configuraci\u00f3n, configura un nombre para el dispositivo (por ejemplo, 'esp_home_tunombre'), e indica que el modo de despliegue ( Website deploy mode ) sea Deploy website to SPI Nor Flash . Por \u00faltimo, configura las credenciales del punto de acceso WiFi al que conectar\u00e1, siguiendo la metodolog\u00eda habitual. En segundo lugar, necesitamos instalar los componentes necesarios para desplegar el cliente web. Para ello, navega al subdirectorio front/web-demo , donde reside el c\u00f3digo fuente del cliente. Ejecuta los siguientes comandos para instalar las dependencias necesarias: sudo apt-get install npm node-vue* npm install npm run build En este punto, ya podr\u00e1s ejecutar, desde el directorio base del ejemplo, la orden de compilaci\u00f3n y flasheado: idf.py build idf.py flash idf.py monitor","title":"Configuraci\u00f3n y compilaci\u00f3n del ejemplo"},{"location":"Subjects/NP2/P5/#interaccion-con-el-dispositivo-via-interfaz-web","text":"Si todo ha ido bien, podr\u00e1s observar en la salida de monitorizaci\u00f3n la IP proporcionada al ESP32. Abre un navegador en la m\u00e1quina virtual o en tu PC (estando conectada a la misma red que tu ESP32), navega hacia la direcci\u00f3n IP del ESP32, y deber\u00edas observar una p\u00e1gina como la siguiente: Esta es una p\u00e1gina web servida por el propio ESP32, que te permitir\u00e1 interactuar con \u00e9l. Concretamente, la p\u00e1gina dispone de dos funcionalidades: Chart : consulta peri\u00f3dicamente el valor de temperatura devuelto por el ESP32 a trav\u00e9s del endpoint /api/v1/temp/raw . Light : permite enviar al ESP32 nuevos valores para las tres componentes de luminosidad que hipot\u00e9ticamente podr\u00eda equipar el ESP32. Tarea Interact\u00faa con el sensor de luminosidad del ESP32 enviando distintos valores. Observa c\u00f3mo la salida de monitorizaci\u00f3n del ESP32 responde mostrando los valores recibidos. Analiza el tr\u00e1fico generado para una de dichas peticiones utilizando Wireshark. \u00bfC\u00f3mo se codifican los datos en el env\u00edo? \u00bfC\u00f3mo se codifican los datos peri\u00f3dicos de temperatura recibidos?","title":"Interacci\u00f3n con el dispositivo v\u00eda interfaz web"},{"location":"Subjects/NP2/P5/#interaccion-con-el-dispositivo-via-linea-de-comandos-curl","text":"curl es una herramienta orientada a la transferencia de archivos por red. Entre otras (muchas) funcionalidades, curl soporta los m\u00e9todos GET y PUT del protocolo HTTP, justo las necesarias para realizar peticiones de lectura y escritura sobre nuestro servidor HTTP REST. Concretamente, para realizar una petici\u00f3n HTTP GET sobre nuestro servidor, podemos ejecutar: curl http://IP/URI Por ejemplo, la petici\u00f3n: curl http://192.168.1.26/api/v1/temp/raw (siendo 192.168.1.26 la IP del ESP32) nos responder\u00e1 con el valor de temperatura instant\u00e1nea. Del mismo modo, para escribir (m\u00e9todo POST ) sobre el servidor, utilizaremos el par\u00e1metro -d , seguido del recurso que queramos enviar. Ten en cuenta que es responsabilidad del cliente enviar un recurso bien formado e interpretable por el dispositivo: curl -d '{\"red\":70,\"green\":80,\"blue\":99}' -H \"Content-Type: application/json\" -X POST http://192.168.1.26/api/v1/light/brightness Observa que hemos incluido el tipo de recurso enviado ( JSON ) y la operacion solicitada ( POST ). Volveremos a esto en breve. Tarea Comprueba que, efectivamente, el tr\u00e1fico generado por las anteriores \u00f3rdenes es el mismo que el que observaste en el caso del cliente web. Observa qu\u00e9 ocurre si consultas un endpoint inexistente, o si env\u00edas un JSON mal formado o con informaci\u00f3n incorrecta.","title":"Interacci\u00f3n con el dispositivo v\u00eda l\u00ednea de comandos (curl)"},{"location":"Subjects/NP2/P5/#implementacion-de-un-servidor-http-con-api-rest","text":"La implementaci\u00f3n de un servidor HTTP en ESP-IDF se delega al componente HTTP Server , que implementa toda la funcionalida necesaria para tal fin de forma eficiente y ligera. La construcci\u00f3n de un servidor puede resumirse en tres funciones principales (observa la implementaci\u00f3n de la funcion start_rest_server en el fichero rest_server.c ) del ejemplo: httpd_start : crea una instancia de servidor HTTP, y aloja recursos para ella seg\u00fan la configuraci\u00f3n proporcionada. En funci\u00f3n del tr\u00e1fico generado (URIs solicitadas), se utilizar\u00e1n manejadores espec\u00edficos definidos por el usuario para analizarlo y, en caso necesario, enviar respuestas al cliente correspondiente. httpd_stop : finaliza el servidor HTTP, cerrando cualquier conexi\u00f3n previamente establecida con clientes. httpd_register_uri_handler : registra un manejador (una funci\u00f3n definida por el usuario) para tratar una petici\u00f3n sobre una URI determinada. La estructura proporcionada dispone de campos para indicar la URI destino ( uri ), el m\u00e9todo que se espera recibir ( method , por ejemplo HTTPD_GET o HTTPD_POST ) y un puntero a una funci\u00f3n que procesar\u00e1 la petici\u00f3n recibida a trav\u00e9s de la URI indicada. Dicha funci\u00f3n s\u00f3lo se ejecutar\u00e1 si el m\u00e9todo coincide con el indicado. La funci\u00f3n start_rest_server del ejemplo proporciona los mecanismos b\u00e1sicos para la creaci\u00f3n de la API anteriormente descrita. As\u00ed, para crear el endpoint /api/v1/system/info , procederemos, en primer lugar, registr\u00e1ndolo en el servidor, preparando previamente la estructura de tipo httpd_uri_t : httpd_uri_t system_info_get_uri = { .uri = \"/api/v1/system/info\", .method = HTTP_GET, .handler = system_info_get_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &system_info_get_uri); En este caso, la operaci\u00f3n asociada a la invocaci\u00f3n del handler ser\u00e1, exclusivamente GET ; de hecho, si invocamos a un m\u00e9todo POST sobre este endpoint , el servidor nos responder\u00e1 autom\u00e1ticamente con un aviso que indicar\u00e1 que dicho m\u00e9todo no est\u00e1 soportado. El procesamiento de la petici\u00f3n GET se realiza en la funci\u00f3n system_info_get_handler , y el esquema que se sigue es, en cualquier caso, sencillo: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de respuesta. httpd_resp_set_type(req, \"application/json\"); // Preparaci\u00f3n del buffer de respuesta. char * buffer = // En el ejemplo preparamos un buffer JSON. // Env\u00edo de respuesta. https_resp_sendstr( req, buffer ); return ESP_OK; Alternativamente, si la respuesta es binaria, podr\u00edamos utilizar la funci\u00f3n https_resp_send( req, buffer, buffer_len ) para procesarla y enviarla (lo necesitar\u00e1s para enviar un buffer binario CBOR). La creaci\u00f3n de un endpoint con soporte para m\u00e9todo POST resulta algo m\u00e1s larga, aunque el registro del mismo no difiere del ejemplo anterior: /* URI handler for light brightness control */ httpd_uri_t light_brightness_post_uri = { .uri = \"/api/v1/light/brightness\", .method = HTTP_POST, .handler = light_brightness_post_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &light_brightness_post_uri); Observa el cuerpo de la funci\u00f3n light_brightness_post_handler . La recepci\u00f3n del objeto enviado por parte del cliente se realiza en base a m\u00faltiples invocaciones a la rutina httpd_req_recv : /* Simple handler for light brightness control */ static esp_err_t light_brightness_post_handler(httpd_req_t *req) { int total_len = req->content_len; int cur_len = 0; char *buf = ((rest_server_context_t *)(req->user_ctx))->scratch; int received = 0; if (total_len >= SCRATCH_BUFSIZE) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"content too long\"); return ESP_FAIL; } while (cur_len < total_len) { received = httpd_req_recv(req, buf + cur_len, total_len); if (received <= 0) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"Failed to post control value\"); return ESP_FAIL; } cur_len += received; } buf[total_len] = '\\0'; /// A partir de este punto, disponemos en buf del objeto recibido v\u00eda HTTP. /// ... Tarea entregable Observa y estudia los c\u00f3digos de los manejadores implementados en el ejemplo. Extiende la API proporcionada para crear un nuevo endpoint que permita obtener la temperatura (n\u00famero aleatorio), pero transform\u00e1ndola a grados Fahrenheit. En este caso, el valor devuelto en el fichero JSON ser\u00e1 un n\u00famero en punto flotante (en la siguiente secci\u00f3n te se explicar\u00e1 c\u00f3mo hacerlo, por lo que de momento puedes enviar \u00fanicamente la parte entera del mismo).","title":"Implementaci\u00f3n de un servidor HTTP con API REST"},{"location":"Subjects/NP2/P5/#representacion-de-la-informacion-json","text":"JSON es un formato de representaci\u00f3n de datos en modo texto para el intercambio de datos entre sistemas inform\u00e1ticos. Se cre\u00f3 inicialmente como una notaci\u00f3n literal de los objetos Javascript, pero dada su amplia aceptaci\u00f3n (realmente como alternativa a XML), se considera a d\u00eda de hoy un componente totalmente independiente al lenguaje. Los tipos de datos soportados por JSON incluyen: Valores num\u00e9ricos: permitiendo n\u00fameros con y sin signo, y con parte decimla en notaci\u00f3n separada por puntos. Cadenas: secuencias de cero o m\u00e1s caracteres. Booleanos: true y false . Arrays: listas ordenadas de cero o m\u00e1s valores de cualquier tipo, separados por comas y encerrados entre corchetes. Objetos: colecciones no ordenadas de pares <nombre>:<valor> , separados por comas y encerrados entre llaves. ESP-IDF incluye el componente cJSON para parsear y construir objetos de tipo JSON de forma sencilla y consistente. La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, v\u00e9ase: /* The cJSON structure: */ typedef struct cJSON { struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; double valuedouble; char *string; } cJSON; El campo type informa sobre el tipo de dato contenido en el objeto, v\u00e9ase: cJSON_False ( cJSON_IsFalse() ): representa un valor booleano falso. cJSON_True ( cJSON_IsTrue() ): representa un valor booleano verdadero. cJSON_NULL ( cJSON_IsNULL() ): representa un valor nulo. cJSON_Number ( cJSON_IsNumber() ): representa un valor num\u00e9rico. Dicho valor se almacena en el campo valuedouble como flotante y en valueint como entero. cJSON_String ( cJSON_IsString() ): representa un valor cadena, y se almacena en el campo valuestring como un array de bytes terminado por el car\u00e1cter nulo ('\\0'). cJSON_Array ( cJSON_IsArray() ): representa un array de valores. En el campo child se almacena una lista enlazada con los elementos del array, terminada en NULL. cJSON_Object ( cJSON_IsObject() ): representa un valor objeto. Sus valores se almacenan de la misma manera que el array anterior, pero en el campo string se almacenan adem\u00e1s las claves del objeto a modo de lista.","title":"Representaci\u00f3n de la informaci\u00f3n. JSON"},{"location":"Subjects/NP2/P5/#creacion-y-parseado-de-una-estructura-json","text":"Para cada tipo de datos, existe una rutina asociada con nombre cJSON_Create... que permite crear un item del tipo correspondiente. Todas estas funciones alojan memoria suficiente como para albergar el dato creado. Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo) utilizando la funci\u00f3n cJSON_Parse : cJSON * json = cJSON_Parse( string ); Para imprimir el contenido de una estructura JSON en modo texto, podemos hacer uso de la funci\u00f3n cJSON_Print(json) : char * string = cJSON_Print( json );","title":"Creaci\u00f3n y parseado de una estructura JSON"},{"location":"Subjects/NP2/P5/#ejemplos","text":"Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor REST. Concretamente, c\u00e9ntrate en la funci\u00f3n system_info_get_handler , que construye un objeto JSON con dos campos, de tipo cadena (\"version\") y num\u00e9rico (\"cores\"): /* Simple handler for getting system handler */ static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de datos de la respuesta. httpd_resp_set_type(req, \"application/json\"); // Creaci\u00f3n del objeto JSON. cJSON *root = cJSON_CreateObject(); // Obtenci\u00f3n del dato. esp_chip_info_t chip_info; esp_chip_info(&chip_info); // Anyadimos un campo de tipo cadena. cJSON_AddStringToObject(root, \"version\", IDF_VER); // Anyadimos un campo de tipo num\u00e9rico. cJSON_AddNumberToObject(root, \"cores\", chip_info.cores); // Imprimimos a cadena previo al env\u00edo. const char *sys_info = cJSON_Print(root); // Enviamos cabecera + objeto JSON en modo texto v\u00eda HTTP. httpd_resp_sendstr(req, sys_info); // Liberamos recursos. free((void *)sys_info); // Liberamos recursos del objeto JSON. cJSON_Delete(root); return ESP_OK; } La funci\u00f3n light_brightness_post_handler realiza un parseado del objeto JSON recibido. Observa su cuerpo: // buf contiene la cadena recibida a trav\u00e9s de HTTP (m\u00e9todo POST). // ... // Parseamos el objeto JSON. cJSON *root = cJSON_Parse(buf); // Obtenemos tres valores num\u00e9ricos (RGB). int red = cJSON_GetObjectItem(root, \"red\")->valueint; int green = cJSON_GetObjectItem(root, \"green\")->valueint; int blue = cJSON_GetObjectItem(root, \"blue\")->valueint; // Mostramos por pantalla los valores parseados. ESP_LOGI(REST_TAG, \"Light control: red = %d, green = %d, blue = %d\", red, green, blue); // Liberamos recursos JSON. cJSON_Delete(root); // Enviamos una respuesta generica en modo texto. httpd_resp_sendstr(req, \"Post control value successfully\"); return ESP_OK; Tarea entregable Extiende la tarea anterior para a\u00f1adir el dato en formato punto flotante de la temperatura en grados Fahrenheit. Tarea entregable Crea un nuevo endpoint que utilice un formato m\u00e1s complejo de objetos JSON, incluyendo distintos tipos de datos que puedan dar respuesta a un hipot\u00e9tico entorno IoT. Documenta la API generada y el formato de los objetos que has dise\u00f1ado. Puedes, si as\u00ed lo deseas, incluir capturas Wireshark para ilustrar el intercambio de mensajes producido. Nos interesar\u00e1, especialmente, el n\u00famero de bytes transportados para enviar/recibir tus mensajes JSON.","title":"Ejemplos"},{"location":"Subjects/NP2/P5/#representacion-de-la-informacion-cbor","text":"CBOR ( Concise Binary Object Representation ) es el formato de serializaci\u00f3n de datos recomendado en muchos de los stacks IoT, espec\u00edficamente en aquellos basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con JSON, ya que sigue su mismo modelo de datos: valores num\u00e9ricos, strings , arrays, mapas (objetos en JSON) y valores booleanos y nulos. Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en este punto radica una de sus ventajas: es posible intercambiar datos entre un cliente y un servidor sin ce\u00f1irse a un esquema de datos concreto conocido por ambas partes. El hecho de ser un formato binario implica mejoras sustanciales con respecto a JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos gr\u00e1ficos, o valores flotantes sensorizados, entre otros muchos); estos datos sol\u00edan codificarse en JSON utilizando, por ejemplo, formato base64 , a\u00f1adiendo complejidad al proceso de codificaci\u00f3n/decodificaci\u00f3n. En general, el uso de un formato binario implica menor complejidad a la hora de ser integrado en aplicaciones, y es por esta raz\u00f3n por la que se considera \u00f3ptimo para nodos de bajas prestaciones, t\u00edpicos en IoT. El formato CBOR est\u00e1 documentado en el RFC 7049 , y por tanto se considera un est\u00e1ndar bien documentado y estable de cara al futuro.","title":"Representaci\u00f3n de la informaci\u00f3n. CBOR"},{"location":"Subjects/NP2/P5/#cbor-en-el-esp32","text":"ESP-IDF incluye la biblioteca tinyCBOR como implementaci\u00f3n ligera del est\u00e1ndar, que permite tanto codificar distintos tipos de datos a formato CBOR, parsear estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable como a JSON. TinyCBOR est\u00e1 mantenido como proyecto de software libre por parte de Intel, y su documentaci\u00f3n detallada (se sugiere consultarla) se encuentra disponible en el siguiente enlace . Estudiaremos el funcionamiento de tinyCBOR a trav\u00e9s de un ejemplo funcional (lo puedes encontrar en examples/protocols/cbor ). El ejemplo muestra los mecanismos necesarios para, en primer lugar, crear un objeto CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo para convertir dicho objeto a representaci\u00f3n JSON, as\u00ed como para parsearlo manualmente. En primer lugar, compila, flashea y ejecuta el ejemplo. Ver\u00e1s que la salida deber\u00eda ser similar a la siguiente: I (320) example: encoded buffer size 67 I (320) example: convert CBOR to JSON [{\"chip\":\"esp32\",\"unicore\":false,\"ip\":[192,168,1,100]},3.1400001049041748,\"simple(99)\",\"2019-07-10 09:00:00+0000\",\"undefined\"] I (340) example: decode CBOR manually Array[ Map{ chip esp32 unicore false ip Array[ 192 168 1 100 ] } 3.14 simple(99) 2019-07-10 09:00:00+0000 undefined ] Observa que la estructura del objeto CBOR ser\u00e1 medianamente compleja: constar\u00e1 de un array formado por cinco elementos: Un mapa (conjunto no ordenado de pares clave-valor ), combinando cadenas, booleanos y un segundo array para especificar una direcci\u00f3n IP. Un valor flotante (3.14). Un valor num\u00e9rico \"simple\" (99). Una fecha (en forma de cadena). Un valor indefinido. El firmware procede en tres etapas:","title":"CBOR en el ESP32"},{"location":"Subjects/NP2/P5/#etapa-1-creacion-codificacion-del-objeto-cbor","text":"Observa el cuerpo de la tarea principal ( app_main ). El codificador CBOR se basa en dos variables: CborEncoder Root_encoder; // Codificador CBOR. uint8_t buf[100]; // Buffer para alojar el objeto CBOR (array de bytes). En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos constructores especiales para dichos objetos: // Creaci\u00f3n de Array. CborEncoder array_encoder; CborEncoder map_encoder; cbor_encoder_create_array(&root_encoder, &array_encoder, 5); // [ // 1. Creaci\u00f3n del Mapa. cbor_encoder_create_map(&array_encoder, &map_encoder, 3); // { A partir de este punto, podemos proceder con la construcci\u00f3n de los objetos siguiendo el esquema deseado: // chip: esp32 (cadena:cadena) cbor_encode_text_stringz(&map_encoder, \"chip\"); cbor_encode_text_stringz(&map_encoder, \"esp32\"); // unicore: false (cadena:booleano) cbor_encode_text_stringz(&map_encoder, \"unicore\"); cbor_encode_boolean(&map_encoder, false); // IP:[192,168,1,100] (cadena:array) cbor_encode_text_stringz(&map_encoder, \"ip\"); CborEncoder array2; cbor_encoder_create_array(&map_encoder, &array2, 4); // [ // Valores num\u00e9ricos. cbor_encode_uint(&array2, 192); cbor_encode_uint(&array2, 168); cbor_encode_uint(&array2, 1); cbor_encode_uint(&array2, 100); cbor_encoder_close_container(&map_encoder, &array2); // ] cbor_encoder_close_container(&array_encoder, &map_encoder); // } // 2. Flotante cbor_encode_float(&array_encoder, 3.14); // 3. Valor simple cbor_encode_simple_value(&array_encoder, 99); // 4. Cadena cbor_encode_text_stringz(&array_encoder, \"2019-07-10 09:00:00+0000\"); // 5. Undefined value. cbor_encode_undefined(&array_encoder); cbor_encoder_close_container(&root_encoder, &array_encoder); // ] // Mostramos el tama\u00f1o del buffer creado. ESP_LOGI(TAG, \"encoded buffer size %d\", cbor_encoder_get_buffer_size(&root_encoder, buf));","title":"Etapa 1: creaci\u00f3n (codificaci\u00f3n) del objeto CBOR"},{"location":"Subjects/NP2/P5/#etapa-2-conversion-a-json","text":"La conversi\u00f3n a JSON (t\u00edpicamente por motivos de visualizaci\u00f3n o depuraci\u00f3n), puede realizarse del siguiente modo: // Initialize the cbor parser and the value iterator cbor_parser_init(buf, sizeof(buf), 0, &root_parser, &it); ESP_LOGI(TAG, \"convert CBOR to JSON\"); // Dump the values in JSON format cbor_value_to_json(stdout, &it, 0);","title":"Etapa 2: conversi\u00f3n a JSON"},{"location":"Subjects/NP2/P5/#etapa-3-parseado-manual-de-un-objeto-cbor","text":"Por \u00faltimo, el parseado manual del objeto CBOR se deja como ejercicio de estudio para el alumno, y est\u00e1 implementado en la funci\u00f3n example_dump_cbor_buffer del ejemplo. B\u00e1sicamente, la funci\u00f3n itera por cada uno de los elementos del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia. Para aquellos tipos complejos (e.g. arrays o mapas), la funci\u00f3n se invoca recursivamente hasta encontrar un elemento de tipo b\u00e1sico. En este caso, simplemente imprime por pantalla su valor (e.g. en el caso de un entero, caso CborIntegerType ). Tarea entregable Se pide extender la API REST con un nuevo endpoint que permita obtener la misma informaci\u00f3n que el endpoint JSON desarrollado en la anterior tarea, pero en esta ocasi\u00f3n, utilizando formato CBOR. El objetivo del ejercicio es comparar la cantidad de tr\u00e1fico generado en cada representaci\u00f3n, por lo que se sugiere que el objeto intercambiado sea relativamente complejo (es decir, incluya disintos tipos de datos num\u00e9ricos, arrays, o mapas). A continuaci\u00f3n se incluyen notas adicionales que te permitir\u00e1n depurar tu desarrollo, observando los valores devueltos por el servidor HTTP.","title":"Etapa 3: parseado manual de un objeto CBOR"},{"location":"Subjects/NP2/P5/#notas-adicionales-creacion-y-consulta-de-un-endpoint-cbor-en-la-api-rest","text":"Las modificaciones a realizar en la funci\u00f3n manejadora del endpoint para responder con un objeto CBOR son m\u00ednimas. De hecho, se centran simplemente en el tipo de respuesta y el mecanismo a usar para enviarla, v\u00e9ase: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Tipo de respuesta. httpd_resp_set_type(req, \"application/cbor\"); CborEncoder root_encoder; uint8_t buf[100]; // Codificador CBOR. cbor_encoder_init(&root_encoder, buf, sizeof(buf), 0); // Codificamos CBOR. // ... // Enviamos respuesta, consultando previamente el tama\u00f1o del buffer codificado. httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &root_encoder, buf)); return ESP_OK; Para consultar desde l\u00ednea de comandos sobre este endpoint , podemos utilizar directamente curl , volcando la salida recibida a un fichero (por ejemplo, output.cbor ): curl http://192.168.1.26/api/v1/system/info > output.cbor Si visualizas el contenido del fichero, ver\u00e1s que contiene datos binarios dif\u00edcilmente interpretables. A continuaci\u00f3n veremos distintos mecanismos de visualizaci\u00f3n.","title":"Notas adicionales: creaci\u00f3n y consulta de un endpoint CBOR en la API REST"},{"location":"Subjects/NP2/P5/#notas-adicionales-visualizacion-de-datos-cbor","text":"Una opci\u00f3n de visualizaci\u00f3n consiste en utilizar la web cbor.me . En el panel derecho, podr\u00e1s pegar el contenido binario le\u00eddo. Si necesitas realizar la conversi\u00f3n antes de pegarlo en la web, puedes hacerlo con la orden: xxd -ps output.cbor Un ejemplo de salida (a pegar en el panel derecho de la web), podr\u00eda ser: $ xxd -ps output.cbor 85a3646368697065657370333267756e69636f7265f46269708418c018a8 011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30 302b30303030f7 Deber\u00edas observar una salida similar a la siguiente (ten en cuenta que la herramiente autom\u00e1ticamente indenta el contenido del panel derecho; recuerda que simplemente debes pegar la salida generada por xxd ): Otra opci\u00f3n de visualizaci\u00f3n puede ser un programa Python (podr\u00edas integrarlo en tu servidor TCP/UDP, por ejemplo), que haga uso del m\u00f3dulo cbor2 ( documentaci\u00f3n ). Para comprobar su funcionamiento, primero inst\u00e1lalo: pip install cbor2 Y comprueba si efectivamente funciona utilizando el siguiente programa Python: from cbor2 import dumps, loads, dump, load with open('output.cbor', 'rb') as fp: obj = load(fp) print(obj) Al ejecutarlo, observar\u00e1s el contenido del objeto: python cbor.py [{'chip': 'esp32', 'unicore': False, 'ip': [192, 168, 1, 100]}, 3.140000104904175, CBORSimpleValue(value=99), '2019-07-10 09:00:00+0000', undefined]","title":"Notas adicionales: visualizaci\u00f3n de datos CBOR"},{"location":"Subjects/NP2/P5/notas/","text":"Implementaci\u00f3n de una interfaz REST v\u00eda HTTP Ejemplo Ejemplo: restful_server navegar a front/webdemo apt-get install npm node-vue* npm install y npm run build en direcrorio front/web-demo idf.py build","title":"Notas"},{"location":"Subjects/NP2/P5/notas/#implementacion-de-una-interfaz-rest-via-http","text":"","title":"Implementaci\u00f3n de una interfaz REST v\u00eda HTTP"},{"location":"Subjects/NP2/P5/notas/#ejemplo","text":"Ejemplo: restful_server navegar a front/webdemo apt-get install npm node-vue* npm install y npm run build en direcrorio front/web-demo idf.py build","title":"Ejemplo"},{"location":"Subjects/NP2/P6/","text":"Pr\u00e1ctica 6. El protocolo MQTT (I). Despliegue de clientes y servidores/ brokers . An\u00e1lisis de tr\u00e1fico Objetivos Familiarizarse con el uso de brokers y clientes de suscripci\u00f3n/publicaci\u00f3n utilizando MQTT. Desplegar un sistema basado en MQTT local, incluyendo broker y clientes. Utilizar Eclipse Paho para integrar funcionalidad MQTT en programas Python. Familiarizarse con el uso de wildcards MQTT. Publicaci\u00f3n/suscripci\u00f3n contra un broker en la nube En la primera parte de la pr\u00e1ctica, utilizaremos un servidor/ broker disponible en la nube para su uso libre por parte de los usuarios ( test.mosquitto.org ). Este servidor suele utilizarse con fines de pruebas b\u00e1sicas y depuraci\u00f3n, y hay que ser consciente de que toda la informaci\u00f3n que en \u00e9l se publica puede ser le\u00edda por cualquier suscriptor. Debe tenerse este dato en cuenta a la hora de publicar informaci\u00f3n sensible a trav\u00e9s de MQTT cuando se use el servidor de pruebas. El servidor escucha en los siguientes puertos: 1883 : MQTT, sin encriptaci\u00f3n. 8883 : MQTT, con encriptaci\u00f3n. 8884 : MQTT, con encriptaci\u00f3n, certificado de cliente requerido. 8080 : MQTT sobre WebSockets, sin encriptaci\u00f3n. 8081 : MQTT sobre WebSockets, con encriptaci\u00f3n. Para realizar publicaciones/suscripciones contra el broker utilizaremos la distribuci\u00f3n mosquitto del proyecto Eclipse IoT. Aunque mosquitto es principalmente una implementaci\u00f3n de broker MQTT, nosotros la utilizaremos en este paso a modo de cliente, lo que nos permitir\u00e1 suscribirnos o publicar sobre cualquier topic MQTT. En primer lugar, instala mosquitto : sudo apt-get install mosquitto mosquitto-clients mosquitto-dev libmosquitto* Si todo ha ido bien, deber\u00edas disponer de dos binarios listos para ejecuci\u00f3n: mosquitto_sub : permite suscribirse a un determinado topic utilizando un broker . mosquitto_pub : permite publicar un mensaje asociado a un determinado topic utilizando un broker . Tarea Observa la ayuda de ambas ordenes, utilizando el argumento --help . Identifica los par\u00e1metros que te permitir\u00e1n especificar el broker destino, el topic a utilizar y, en el caso de la publicaci\u00f3n, el mensaje a enviar. Suscrib\u00e1monos al topic # en el broker , utilizando para ello la orden: mosquitto_sub -h test.mosquitto.org -t \"#\" Tarea Pausa la salida en cuanto puedas. \u00bfA qu\u00e9 corresponden los mensajes que est\u00e1s obteniendo? A continuaci\u00f3n, vamos a realizar un proceso de publicaci\u00f3n/suscripcion con un topic conocido (por ejemplo, /MIOT/tunombre/ ). Para publicar un mensaje bajo dicho topic : mosquitto_pub -h test.mosquitto.org -t \"/MIOT/tunombre\" -m \"Hola, soy tunombre\" Tarea Suscr\u00edbete al topic /MIOT/tunombre y observa si recibes los resultados tras la publicaci\u00f3n correspondiente. \u00bfC\u00f3mo podr\u00edas suscribirte a todos los mensajes publicados por compa\u00f1eros? Tarea entregable Realiza un an\u00e1lisis del intercambio de mensajes necesario para un proceso de publicaci\u00f3n/suscripci\u00f3n contra el broker de test. Incide en el tipo de protocolo de capa de transporte que utiliza MQTT, mensajes de datos y control, sobrecarga del protocolo de capa de aplicaci\u00f3n, y en general, cualquier aspecto que consideres de inter\u00e9s. Despliegue de un broker local usando Eclipse Mosquitto El uso de un servidor remoto presenta ventajas (facilidad de uso), pero una gran cantidad de inconvenientes (seguridad, imposibilidad de configuraci\u00f3n avanzada, ...) En esta secci\u00f3n, configuraremos un broker mosquitto para el despliegue de una infraestructura MQTT local o remota bajo nuestro control. El arranque de un broker (servidor) mosquitto se realiza mediante el propio comando mosquitto : mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] Sin embargo, en la mayor\u00eda de distribuciones Linux, el broker arranca por defecto y se ejecuta constantemente en segundo plano. Para comprobar el estado de funcionamiento del broker , basta con ejecutar: sudo service mosquitto status Observar\u00e1s un mensaje que indica que el servicio est\u00e1 activo. Las opciones restart , start o stop te permitir\u00e1n controlar el estado del broker en todo momento. Tarea Comprueba que, con el broker arrancado, puedes realizar un proceso de suscripci\u00f3n/publicaci\u00f3n contra el mismo. El broker mosquitto permite monitorizar sus propias estad\u00edsticas e informaci\u00f3n de estado utilizando el protocolo MQTT. As\u00ed, los topics $SYS retornan, bien peri\u00f3dicamente o bien cuando sucede un evento de inter\u00e9s, la informaci\u00f3n de estado del broker . Puedes consultar m\u00e1s detalles en la p\u00e1gina de manual de mosquitto (comando man mosquitto ), en el ep\u00edgrafe BROKER STATUS . Note Comprueba el estado del broker mientras realizas procesos de suscripci\u00f3n/publicaci\u00f3n reportando bytes recibidos/enviados, n\u00famero de conexiones activas e inactivas, y n\u00famero de mensajes enviados/recibidos por el broker . Desarrollo de un cliente local usando Eclipse Paho Los clientes mosquitto_pub y mosquitto_sub son b\u00e1sicamente herramientas de desarrollo y pruebas, pero resulta interesante conocer bibliotecas que permitan la integraci\u00f3n de MQTT en programas existentes. Una de ellas es Eclipse Paho . Paho es una infraestructura desarrollada en el proyecto Eclipse IoT para dar soporte a implementaciones de protocolos de mensajer\u00eda M2M e IoT, aunque, en este momento, su uso principal se centra exclusivamente en MQTT. En nuestro caso, utilizaremos la versi\u00f3n Python de la biblioteca, instalable v\u00eda: pip install paho-mqtt Dispones de la documentaci\u00f3n del m\u00f3dulo a trav\u00e9s de este enlace . El despliegue de un ejemplo sencillo para un cliente que se conecta a un broker y se suscribe al t\u00f3pico $SYS , imprimiendo los mensajes recibidos, resultar\u00eda, utilizando Paho, en el siguiente c\u00f3digo Python: import paho.mqtt.client as mqtt # Funcion callback invocada cuandl el cliente recibe un CONNACK desde el broker. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \"+str(rc)) # Suscribirse en on_connect() asegura que si se pierde la conexi\u00f3n y # se reestablece, las suscripciones se renovar\u00e1n. client.subscribe(\"$SYS/#\") # Funcion callback al recibir un mensaje de publicacion (PUBLISH) desde el # broker. def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"mqtt.eclipse.org\", 1883, 60) # Llamada bloqueante que procesa el tr\u00e1fico de red, invoca callbacks # y maneja la reconexi\u00f3n al broker. client.loop_forever() La clase cliente puede utilizarse para: Crear una instancia de cliente MQTT. Conectar a un broker usando las funciones de la familia connect*() . Invocar a funciones de la familia loop*() para mantener el tr\u00e1fico de datos con el servidor. Utilizar subscribe() para suscribirse a un topic y recibir mensajes. Utilizar publish() publicar mensajes en el broker . Utilizar disconnect() para desconectar del broker . Los callbacks se invocar\u00e1n autom\u00e1ticamente para permitir el procesamiento de eventos. De entre los m\u00e1s utilizados, destacan: ON_CONNECT : invocado cuando el broker responde a nuestra petici\u00f3n de conexi\u00f3n. Ejemplo: def on_connect(client, userdata, flags, rc): print(\"Connection returned result: \"+connack_string(rc)) ON_DISCONNECT : invocado cuando el cliente se desconecta del broker . Ejemplo: def on_disconnect(client, userdata, rc): if rc != 0: print(\"Unexpected disconnection.\") ON_MESSAGE : invocado cuando se recibe un mensaje en un topic al que el cliente est\u00e1 suscrito. Ejemplo: def on_message(client, userdata, message): print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos)) Para publicar de forma puntual sobre un broker (sin mantener una conexi\u00f3n establecida), es posible utilizar la siguiente secuencia de ordenes: import paho.mqtt.publish as publish publish.single(\"paho/test/single\", \"payload\", hostname=\"mqtt.eclipse.org\") Del mismo modo, podemos suscribirnos de forma puntual mediante una llamada bloqueante a: import paho.mqtt.subscribe as subscribe msg = subscribe.simple(\"paho/test/simple\", hostname=\"mqtt.eclipse.org\") print(\"%s %s\" % (msg.topic, msg.payload)) Toda la informaci\u00f3n y documentaci\u00f3n asociada al m\u00f3dulo puede consultarse aqu\u00ed . Wildcards Adem\u00e1s de permitir el uso de topics completos para el proceso de suscripci\u00f3n, los topics pueden incluir wildcards o comodines en su estructura. + es la wildcard utilizada para obtener correspondencias con un \u00fanico nivel de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d +/b/c/d a/+/c/d a/+/+/d +/+/+/+ Pero no las siguientes: a/b/c b/+/c/d +/+/+ La segunda wildcard soportada es # , y permite corresponencias con cualquier nivel sucesivo de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d # a/# a/b/# a/b/c/# +/b/c/# Tarea entregable Cada alumno propondr\u00e1 una soluci\u00f3n para monitorizar un edificio inteligente a trav\u00e9s de un sistema de mensajer\u00eda MQTT. Para ello, cabe destacar que el edificio constar\u00e1 de: Un identificador del tipo EDIFICIO_TUPUESTODELABORATORIO. Un conjunto de plantas, identificadas por la cadena \"P_NUMPLANTA\". En cada planta, cuatro alas (norte -N-, sur -S-, este -E-, oeste -O-) En cada ala, un conjunto de salas, identificadas por un valor num\u00e9rico. En cada sala, cuatro sensores: TEMP (temperatura), HUM (humedad), LUX (luminosidad), VIBR (vibraci\u00f3n). Se pide, en primer lugar, dise\u00f1ar la jerarqu\u00eda de topics que permita una correcta monitorizaci\u00f3n de los edificios. En segundo lugar, se desarrollar\u00e1 un programa Python cliente que publique, peri\u00f3dicamente y de forma aleatoria, objetos JSON (opcionalmente puedes utilizar CBOR) que incluyan el valor de temperatura, humedad, luminosidad o vibraci\u00f3n para una determinada sala del edificio, elegida tambi\u00e9n aleatoriamente, a trav\u00e9s del topic correspondiente. Estos mensajes estar\u00e1n espaciados en el tiempo un n\u00famero aleatorio de segundos. En tercer lugar, se piden las wildcards que permitan consultar distintos tipos de informaci\u00f3n jer\u00e1rquica. Por ejemplo: Todos los mensajes de temperatura para el edificio. Todos los mensajes de vibraci\u00f3n del ala oeste de la planta 2 del edificio. Todos los mensajes de sensorizaci\u00f3n de la sala 4 del ala Sur de la planta 7 del edificio. ... En \u00faltimo lugar, se pide desarrollar un programa Python que act\u00fae a modo de alarma, y que muestre mensajes s\u00f3lo si alg\u00fan valor recibido para los datos sensorizados supera un umbral preestablecido. En dicho caso, el programa mostrar\u00e1 el edificio, planta, ala, sala y sensor que ha producido la alarma, junto con su valor num\u00e9rico. Puedes utilizar el m\u00f3dulo JSON para parsear los objetos recibidos.","title":"Pr\u00e1ctica 6. El protocolo MQTT (I). Despliegue de clientes y servidores/*brokers*. An\u00e1lisis de tr\u00e1fico"},{"location":"Subjects/NP2/P6/#practica-6-el-protocolo-mqtt-i-despliegue-de-clientes-y-servidoresbrokers-analisis-de-trafico","text":"","title":"Pr\u00e1ctica 6. El protocolo MQTT (I). Despliegue de clientes y servidores/brokers. An\u00e1lisis de tr\u00e1fico"},{"location":"Subjects/NP2/P6/#objetivos","text":"Familiarizarse con el uso de brokers y clientes de suscripci\u00f3n/publicaci\u00f3n utilizando MQTT. Desplegar un sistema basado en MQTT local, incluyendo broker y clientes. Utilizar Eclipse Paho para integrar funcionalidad MQTT en programas Python. Familiarizarse con el uso de wildcards MQTT.","title":"Objetivos"},{"location":"Subjects/NP2/P6/#publicacionsuscripcion-contra-un-broker-en-la-nube","text":"En la primera parte de la pr\u00e1ctica, utilizaremos un servidor/ broker disponible en la nube para su uso libre por parte de los usuarios ( test.mosquitto.org ). Este servidor suele utilizarse con fines de pruebas b\u00e1sicas y depuraci\u00f3n, y hay que ser consciente de que toda la informaci\u00f3n que en \u00e9l se publica puede ser le\u00edda por cualquier suscriptor. Debe tenerse este dato en cuenta a la hora de publicar informaci\u00f3n sensible a trav\u00e9s de MQTT cuando se use el servidor de pruebas. El servidor escucha en los siguientes puertos: 1883 : MQTT, sin encriptaci\u00f3n. 8883 : MQTT, con encriptaci\u00f3n. 8884 : MQTT, con encriptaci\u00f3n, certificado de cliente requerido. 8080 : MQTT sobre WebSockets, sin encriptaci\u00f3n. 8081 : MQTT sobre WebSockets, con encriptaci\u00f3n. Para realizar publicaciones/suscripciones contra el broker utilizaremos la distribuci\u00f3n mosquitto del proyecto Eclipse IoT. Aunque mosquitto es principalmente una implementaci\u00f3n de broker MQTT, nosotros la utilizaremos en este paso a modo de cliente, lo que nos permitir\u00e1 suscribirnos o publicar sobre cualquier topic MQTT. En primer lugar, instala mosquitto : sudo apt-get install mosquitto mosquitto-clients mosquitto-dev libmosquitto* Si todo ha ido bien, deber\u00edas disponer de dos binarios listos para ejecuci\u00f3n: mosquitto_sub : permite suscribirse a un determinado topic utilizando un broker . mosquitto_pub : permite publicar un mensaje asociado a un determinado topic utilizando un broker . Tarea Observa la ayuda de ambas ordenes, utilizando el argumento --help . Identifica los par\u00e1metros que te permitir\u00e1n especificar el broker destino, el topic a utilizar y, en el caso de la publicaci\u00f3n, el mensaje a enviar. Suscrib\u00e1monos al topic # en el broker , utilizando para ello la orden: mosquitto_sub -h test.mosquitto.org -t \"#\" Tarea Pausa la salida en cuanto puedas. \u00bfA qu\u00e9 corresponden los mensajes que est\u00e1s obteniendo? A continuaci\u00f3n, vamos a realizar un proceso de publicaci\u00f3n/suscripcion con un topic conocido (por ejemplo, /MIOT/tunombre/ ). Para publicar un mensaje bajo dicho topic : mosquitto_pub -h test.mosquitto.org -t \"/MIOT/tunombre\" -m \"Hola, soy tunombre\" Tarea Suscr\u00edbete al topic /MIOT/tunombre y observa si recibes los resultados tras la publicaci\u00f3n correspondiente. \u00bfC\u00f3mo podr\u00edas suscribirte a todos los mensajes publicados por compa\u00f1eros? Tarea entregable Realiza un an\u00e1lisis del intercambio de mensajes necesario para un proceso de publicaci\u00f3n/suscripci\u00f3n contra el broker de test. Incide en el tipo de protocolo de capa de transporte que utiliza MQTT, mensajes de datos y control, sobrecarga del protocolo de capa de aplicaci\u00f3n, y en general, cualquier aspecto que consideres de inter\u00e9s.","title":"Publicaci\u00f3n/suscripci\u00f3n contra un broker en la nube"},{"location":"Subjects/NP2/P6/#despliegue-de-un-broker-local-usando-eclipse-mosquitto","text":"El uso de un servidor remoto presenta ventajas (facilidad de uso), pero una gran cantidad de inconvenientes (seguridad, imposibilidad de configuraci\u00f3n avanzada, ...) En esta secci\u00f3n, configuraremos un broker mosquitto para el despliegue de una infraestructura MQTT local o remota bajo nuestro control. El arranque de un broker (servidor) mosquitto se realiza mediante el propio comando mosquitto : mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] Sin embargo, en la mayor\u00eda de distribuciones Linux, el broker arranca por defecto y se ejecuta constantemente en segundo plano. Para comprobar el estado de funcionamiento del broker , basta con ejecutar: sudo service mosquitto status Observar\u00e1s un mensaje que indica que el servicio est\u00e1 activo. Las opciones restart , start o stop te permitir\u00e1n controlar el estado del broker en todo momento. Tarea Comprueba que, con el broker arrancado, puedes realizar un proceso de suscripci\u00f3n/publicaci\u00f3n contra el mismo. El broker mosquitto permite monitorizar sus propias estad\u00edsticas e informaci\u00f3n de estado utilizando el protocolo MQTT. As\u00ed, los topics $SYS retornan, bien peri\u00f3dicamente o bien cuando sucede un evento de inter\u00e9s, la informaci\u00f3n de estado del broker . Puedes consultar m\u00e1s detalles en la p\u00e1gina de manual de mosquitto (comando man mosquitto ), en el ep\u00edgrafe BROKER STATUS . Note Comprueba el estado del broker mientras realizas procesos de suscripci\u00f3n/publicaci\u00f3n reportando bytes recibidos/enviados, n\u00famero de conexiones activas e inactivas, y n\u00famero de mensajes enviados/recibidos por el broker .","title":"Despliegue de un broker local usando Eclipse Mosquitto"},{"location":"Subjects/NP2/P6/#desarrollo-de-un-cliente-local-usando-eclipse-paho","text":"Los clientes mosquitto_pub y mosquitto_sub son b\u00e1sicamente herramientas de desarrollo y pruebas, pero resulta interesante conocer bibliotecas que permitan la integraci\u00f3n de MQTT en programas existentes. Una de ellas es Eclipse Paho . Paho es una infraestructura desarrollada en el proyecto Eclipse IoT para dar soporte a implementaciones de protocolos de mensajer\u00eda M2M e IoT, aunque, en este momento, su uso principal se centra exclusivamente en MQTT. En nuestro caso, utilizaremos la versi\u00f3n Python de la biblioteca, instalable v\u00eda: pip install paho-mqtt Dispones de la documentaci\u00f3n del m\u00f3dulo a trav\u00e9s de este enlace . El despliegue de un ejemplo sencillo para un cliente que se conecta a un broker y se suscribe al t\u00f3pico $SYS , imprimiendo los mensajes recibidos, resultar\u00eda, utilizando Paho, en el siguiente c\u00f3digo Python: import paho.mqtt.client as mqtt # Funcion callback invocada cuandl el cliente recibe un CONNACK desde el broker. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \"+str(rc)) # Suscribirse en on_connect() asegura que si se pierde la conexi\u00f3n y # se reestablece, las suscripciones se renovar\u00e1n. client.subscribe(\"$SYS/#\") # Funcion callback al recibir un mensaje de publicacion (PUBLISH) desde el # broker. def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"mqtt.eclipse.org\", 1883, 60) # Llamada bloqueante que procesa el tr\u00e1fico de red, invoca callbacks # y maneja la reconexi\u00f3n al broker. client.loop_forever() La clase cliente puede utilizarse para: Crear una instancia de cliente MQTT. Conectar a un broker usando las funciones de la familia connect*() . Invocar a funciones de la familia loop*() para mantener el tr\u00e1fico de datos con el servidor. Utilizar subscribe() para suscribirse a un topic y recibir mensajes. Utilizar publish() publicar mensajes en el broker . Utilizar disconnect() para desconectar del broker . Los callbacks se invocar\u00e1n autom\u00e1ticamente para permitir el procesamiento de eventos. De entre los m\u00e1s utilizados, destacan: ON_CONNECT : invocado cuando el broker responde a nuestra petici\u00f3n de conexi\u00f3n. Ejemplo: def on_connect(client, userdata, flags, rc): print(\"Connection returned result: \"+connack_string(rc)) ON_DISCONNECT : invocado cuando el cliente se desconecta del broker . Ejemplo: def on_disconnect(client, userdata, rc): if rc != 0: print(\"Unexpected disconnection.\") ON_MESSAGE : invocado cuando se recibe un mensaje en un topic al que el cliente est\u00e1 suscrito. Ejemplo: def on_message(client, userdata, message): print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos)) Para publicar de forma puntual sobre un broker (sin mantener una conexi\u00f3n establecida), es posible utilizar la siguiente secuencia de ordenes: import paho.mqtt.publish as publish publish.single(\"paho/test/single\", \"payload\", hostname=\"mqtt.eclipse.org\") Del mismo modo, podemos suscribirnos de forma puntual mediante una llamada bloqueante a: import paho.mqtt.subscribe as subscribe msg = subscribe.simple(\"paho/test/simple\", hostname=\"mqtt.eclipse.org\") print(\"%s %s\" % (msg.topic, msg.payload)) Toda la informaci\u00f3n y documentaci\u00f3n asociada al m\u00f3dulo puede consultarse aqu\u00ed .","title":"Desarrollo de un cliente local usando Eclipse Paho"},{"location":"Subjects/NP2/P6/#wildcards","text":"Adem\u00e1s de permitir el uso de topics completos para el proceso de suscripci\u00f3n, los topics pueden incluir wildcards o comodines en su estructura. + es la wildcard utilizada para obtener correspondencias con un \u00fanico nivel de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d +/b/c/d a/+/c/d a/+/+/d +/+/+/+ Pero no las siguientes: a/b/c b/+/c/d +/+/+ La segunda wildcard soportada es # , y permite corresponencias con cualquier nivel sucesivo de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d # a/# a/b/# a/b/c/# +/b/c/# Tarea entregable Cada alumno propondr\u00e1 una soluci\u00f3n para monitorizar un edificio inteligente a trav\u00e9s de un sistema de mensajer\u00eda MQTT. Para ello, cabe destacar que el edificio constar\u00e1 de: Un identificador del tipo EDIFICIO_TUPUESTODELABORATORIO. Un conjunto de plantas, identificadas por la cadena \"P_NUMPLANTA\". En cada planta, cuatro alas (norte -N-, sur -S-, este -E-, oeste -O-) En cada ala, un conjunto de salas, identificadas por un valor num\u00e9rico. En cada sala, cuatro sensores: TEMP (temperatura), HUM (humedad), LUX (luminosidad), VIBR (vibraci\u00f3n). Se pide, en primer lugar, dise\u00f1ar la jerarqu\u00eda de topics que permita una correcta monitorizaci\u00f3n de los edificios. En segundo lugar, se desarrollar\u00e1 un programa Python cliente que publique, peri\u00f3dicamente y de forma aleatoria, objetos JSON (opcionalmente puedes utilizar CBOR) que incluyan el valor de temperatura, humedad, luminosidad o vibraci\u00f3n para una determinada sala del edificio, elegida tambi\u00e9n aleatoriamente, a trav\u00e9s del topic correspondiente. Estos mensajes estar\u00e1n espaciados en el tiempo un n\u00famero aleatorio de segundos. En tercer lugar, se piden las wildcards que permitan consultar distintos tipos de informaci\u00f3n jer\u00e1rquica. Por ejemplo: Todos los mensajes de temperatura para el edificio. Todos los mensajes de vibraci\u00f3n del ala oeste de la planta 2 del edificio. Todos los mensajes de sensorizaci\u00f3n de la sala 4 del ala Sur de la planta 7 del edificio. ... En \u00faltimo lugar, se pide desarrollar un programa Python que act\u00fae a modo de alarma, y que muestre mensajes s\u00f3lo si alg\u00fan valor recibido para los datos sensorizados supera un umbral preestablecido. En dicho caso, el programa mostrar\u00e1 el edificio, planta, ala, sala y sensor que ha producido la alarma, junto con su valor num\u00e9rico. Puedes utilizar el m\u00f3dulo JSON para parsear los objetos recibidos.","title":"Wildcards"},{"location":"Subjects/NP2/P6-II/","text":"Pr\u00e1ctica 6. El protocolo MQTT (II). Despliegue de clientes en el ESP32 Objetivos Familiarizarse con el componente MQTT en ESP-IDF. Desplegar un cliente completo MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n. Implementar QoS y LWT en el ESP32. El componente MQTT en ESP-IDF El componente ESP-MQTT es una implementaci\u00f3n del protocolo MQTT en su parte cliente, que permite la implementaci\u00f3n completa de clientes MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n a brokers existentes. El componente soporte MQTT sobre TCP por defecto, as\u00ed como funcionalidades avanzadas como SSL/TLS o MQTT sobre Websockets. Adem\u00e1s, permite el despliegue de m\u00faltiples instancias de cliente MQTT sobre la misma placa; el componente implementa tambi\u00e9n par\u00e1metros avanzados soportados por el protocolo MQTT, como autenticaci\u00f3n (mediante nombre de usuario y contrase\u00f1a), mensajes last will y tres niveles de calidad de servicio (QoS). Eventos Como otros componentes, la interacci\u00f3n entre el cliente MQTT y la aplicaci\u00f3n se basa en la recepci\u00f3n de eventos, entre los que destacan: MQTT_EVENT_BEFORE_CONNECT : El cliente se ha inicializado y va a comenzar el proceso de conexi\u00f3n con el broker . MQTT_EVENT_CONNECTED : El cliente ha establecido de forma exitosa una conexi\u00f3n con el broker y est\u00e1 listo para enviar y recibir datos. MQTT_EVENT_DISCONNECTED : El cliente ha abortado la conexi\u00f3n. MQTT_EVENT_SUBSCRIBED : El broker ha confirmado la petici\u00f3n de suscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de suscripci\u00f3n. MQTT_EVENT_UNSUBSCRIBED : El broker confirma la petici\u00f3n de desuscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de desuscripci\u00f3n . MQTT_EVENT_PUBLISHED : El broker ha acusado la recepci\u00f3n de un mensaje previamente publicado por el cliente. Este evento s\u00f3lo se producir\u00e1 cuando QoS sea 1 o 2, ya que el nivel 0 de QoS no utiliza acuses de recibo. Los datos asociados al evento contendr\u00e1n el ID del mensaje publicado. MQTT_EVENT_DATA : El cliente ha recibido un mensaje publicado en el broker . Los datos asociados al evento contienen el ID del mensaje, nombre del topic , datos recibidos y su longitud. API esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config) Rutina de inicializaci\u00f3n del cliente MQTT. Devuelve un manejador de la conexi\u00f3n, o NULL en caso de error. El par\u00e1metro config es una estructura con los par\u00e1metros que regir\u00e1n la conexi\u00f3n, entre los que destacan (v\u00e9ase la documentaci\u00f3n del componente para par\u00e1metros adicionales): esp_event_loop_handle_t event_loop_handle : manejador para eventos MQTT. const char *uri : URI del broker MQTT. uint32_t port : puerto del broker MQTT. const char *username : nombre de usuario, en caso de estar soportado por el broker . const char *password : contrase\u00f1a, en caso de estar soportada por el broker . const char *lwt_topic : topic del mensaje LWT ( Last Will and Testament ). const char *lwt_msg : contenido del mensaje LWT. int lwt_qos : QoS del mensaje LWT. int lwt_retain : flag retain para el mensaje LWT. int lwt_msg_len : longitud del mensaje LWT. int keepalive : valor del temporizador de keepalive (por defecto 120 segundos). esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) Rutina de arranque del cliente MQTT. Su \u00fanico par\u00e1metro es el manejador devuelto por la anterior rutina. int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) Realiza la suscripci\u00f3n del cliente a un topic con el QoS determinado a trav\u00e9s de su tercer par\u00e1metro. El cliente debe estar conectado al broker para enviar el mensaje de suscripci\u00f3n. int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) Desuscribe al cliente de un determinado topic. El ciente debe estar conectado al broker para poder enviar el mensaje correspondiente. int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) El cliente publica un mensaje en el broker . El cliente no tiene que estar conectado al broker para enviar el mensaje de publicaci\u00f3n. En dicho caso, si qos=0 , los mensajes se descartar\u00e1n, y si qos>=1 , los mensajes se encolar\u00e1n a la espera de ser enviados. Devuelve el identificador del mensaje publicado (si qos=0 , el valor de retorno siempre ser\u00e1 0), o -1 en caso de error. Par\u00e1metros de inter\u00e9s: client : manejador del cliente MQTT. topic : topic (en forma de cadena) bajo el cual se publicar\u00e1 el mensaje. data : contenido del mensaje a publicar (es posible publicar un mensaje sin contenido, en cuyo caso se proporcionar\u00e1 un valor NULL en este par\u00e1metro). len : longitud de los datos a enviar. Si se proporciona el valor 0 , se calcula su longitud a partir de la cadena data . qos : nivel de QoS deseado. retain : flag Retain . Tarea Analiza el ejemplo examples/protocols/mqtt/tcp , y configuralo para que utilice como broker el que desplegaste en la m\u00e1quina virtual (aseg\u00farate de que tanto m\u00e1quina virtual como ESP32 pertenecen a la misma red). Realiza procesos de publicaci\u00f3n y suscripci\u00f3n en la m\u00e1quina virtual que permitan visualizar los mensajes publicados por el ESP32 en tu terminal Linux, y los mensajes publicados desde el terminal Linux en la salida de monitorizaci\u00f3n del ESP32. Modifica el ejemplo y analiza el tr\u00e1fico generado (a trav\u00e9s de Wireshark) para los siguientes casos: Publicaci\u00f3n de mensajes con niveles de QoS 0, 1 y 2. Activaci\u00f3n o desactivaci\u00f3n del flag retain en la publicaci\u00f3n desde el ESP32. Configuraci\u00f3n de un mensaje LWT con el topic /disconnected . Para ello, reduce el valor de keepalive a 10 segundos, para que la detecci\u00f3n de desconexi\u00f3n sea m\u00e1s r\u00e1pida. Deber\u00e1s observar el env\u00edo del mensaje con dicho topic transcurrido dicho tiempo desde una desconexi\u00f3n forzada del ESP32 si est\u00e1s suscrito al mismo desde tu terminal Linux. Tarea Modifica el ejemplo proporcionado para que se integre en tu entorno de monitorizaci\u00f3n de un edificio. As\u00ed, el firmware proceder\u00e1 creando una tarea que, peri\u00f3dicamente (cada interval segundos), publique un valor aleatorio para los cuatro par\u00e1metros monitorizados. Adem\u00e1s, deber\u00e1s dise\u00f1a un sistema basado en MQTT mediante el cual puedas controlar, externamente, el comportamiento del sensor, atendiendo a los siguientes criterios: El tiempo ( interval ) mediante que transcurrir\u00e1 entre publicaciones ser\u00e1 configurable a trav\u00e9s de un proceso de publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. La sensorizaci\u00f3n (y publicaci\u00f3n de datos) podr\u00e1 activarse o desactivarse bajo demanda a trav\u00e9s de la publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. Por ejemplo, imagina que tu sensor publica mensajes de sensorizaci\u00f3n en el topic /EDIFICIO_3/P_4/N/12/(TEMP|HUM|LUX|VIBR) . Para controlar el intervalo de publicaci\u00f3n de datos desde dicho ESP32 y fijarlo a 1 segundo, podr\u00edamos publicar un mensaje utilizando la orden: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/interval -m \"1000\" -h IP_BROKER Para desactivar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/disable -m \"\" -h IP_BROKER Para activar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/enable -m \"\" -h IP_BROKER Opcionalmente, puedes ampliar tu soluci\u00f3n para que cada sensor se active o desactive individualmente bajo demanda. En este caso, elige y documenta el topic utilizado.","title":"Pr\u00e1ctica 6. El protocolo MQTT (II). Despliegue de clientes en el ESP32"},{"location":"Subjects/NP2/P6-II/#practica-6-el-protocolo-mqtt-ii-despliegue-de-clientes-en-el-esp32","text":"","title":"Pr\u00e1ctica 6. El protocolo MQTT (II). Despliegue de clientes en el ESP32"},{"location":"Subjects/NP2/P6-II/#objetivos","text":"Familiarizarse con el componente MQTT en ESP-IDF. Desplegar un cliente completo MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n. Implementar QoS y LWT en el ESP32.","title":"Objetivos"},{"location":"Subjects/NP2/P6-II/#el-componente-mqtt-en-esp-idf","text":"El componente ESP-MQTT es una implementaci\u00f3n del protocolo MQTT en su parte cliente, que permite la implementaci\u00f3n completa de clientes MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n a brokers existentes. El componente soporte MQTT sobre TCP por defecto, as\u00ed como funcionalidades avanzadas como SSL/TLS o MQTT sobre Websockets. Adem\u00e1s, permite el despliegue de m\u00faltiples instancias de cliente MQTT sobre la misma placa; el componente implementa tambi\u00e9n par\u00e1metros avanzados soportados por el protocolo MQTT, como autenticaci\u00f3n (mediante nombre de usuario y contrase\u00f1a), mensajes last will y tres niveles de calidad de servicio (QoS).","title":"El componente MQTT en ESP-IDF"},{"location":"Subjects/NP2/P6-II/#eventos","text":"Como otros componentes, la interacci\u00f3n entre el cliente MQTT y la aplicaci\u00f3n se basa en la recepci\u00f3n de eventos, entre los que destacan: MQTT_EVENT_BEFORE_CONNECT : El cliente se ha inicializado y va a comenzar el proceso de conexi\u00f3n con el broker . MQTT_EVENT_CONNECTED : El cliente ha establecido de forma exitosa una conexi\u00f3n con el broker y est\u00e1 listo para enviar y recibir datos. MQTT_EVENT_DISCONNECTED : El cliente ha abortado la conexi\u00f3n. MQTT_EVENT_SUBSCRIBED : El broker ha confirmado la petici\u00f3n de suscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de suscripci\u00f3n. MQTT_EVENT_UNSUBSCRIBED : El broker confirma la petici\u00f3n de desuscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de desuscripci\u00f3n . MQTT_EVENT_PUBLISHED : El broker ha acusado la recepci\u00f3n de un mensaje previamente publicado por el cliente. Este evento s\u00f3lo se producir\u00e1 cuando QoS sea 1 o 2, ya que el nivel 0 de QoS no utiliza acuses de recibo. Los datos asociados al evento contendr\u00e1n el ID del mensaje publicado. MQTT_EVENT_DATA : El cliente ha recibido un mensaje publicado en el broker . Los datos asociados al evento contienen el ID del mensaje, nombre del topic , datos recibidos y su longitud.","title":"Eventos"},{"location":"Subjects/NP2/P6-II/#api","text":"esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config) Rutina de inicializaci\u00f3n del cliente MQTT. Devuelve un manejador de la conexi\u00f3n, o NULL en caso de error. El par\u00e1metro config es una estructura con los par\u00e1metros que regir\u00e1n la conexi\u00f3n, entre los que destacan (v\u00e9ase la documentaci\u00f3n del componente para par\u00e1metros adicionales): esp_event_loop_handle_t event_loop_handle : manejador para eventos MQTT. const char *uri : URI del broker MQTT. uint32_t port : puerto del broker MQTT. const char *username : nombre de usuario, en caso de estar soportado por el broker . const char *password : contrase\u00f1a, en caso de estar soportada por el broker . const char *lwt_topic : topic del mensaje LWT ( Last Will and Testament ). const char *lwt_msg : contenido del mensaje LWT. int lwt_qos : QoS del mensaje LWT. int lwt_retain : flag retain para el mensaje LWT. int lwt_msg_len : longitud del mensaje LWT. int keepalive : valor del temporizador de keepalive (por defecto 120 segundos). esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) Rutina de arranque del cliente MQTT. Su \u00fanico par\u00e1metro es el manejador devuelto por la anterior rutina. int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) Realiza la suscripci\u00f3n del cliente a un topic con el QoS determinado a trav\u00e9s de su tercer par\u00e1metro. El cliente debe estar conectado al broker para enviar el mensaje de suscripci\u00f3n. int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) Desuscribe al cliente de un determinado topic. El ciente debe estar conectado al broker para poder enviar el mensaje correspondiente. int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) El cliente publica un mensaje en el broker . El cliente no tiene que estar conectado al broker para enviar el mensaje de publicaci\u00f3n. En dicho caso, si qos=0 , los mensajes se descartar\u00e1n, y si qos>=1 , los mensajes se encolar\u00e1n a la espera de ser enviados. Devuelve el identificador del mensaje publicado (si qos=0 , el valor de retorno siempre ser\u00e1 0), o -1 en caso de error. Par\u00e1metros de inter\u00e9s: client : manejador del cliente MQTT. topic : topic (en forma de cadena) bajo el cual se publicar\u00e1 el mensaje. data : contenido del mensaje a publicar (es posible publicar un mensaje sin contenido, en cuyo caso se proporcionar\u00e1 un valor NULL en este par\u00e1metro). len : longitud de los datos a enviar. Si se proporciona el valor 0 , se calcula su longitud a partir de la cadena data . qos : nivel de QoS deseado. retain : flag Retain . Tarea Analiza el ejemplo examples/protocols/mqtt/tcp , y configuralo para que utilice como broker el que desplegaste en la m\u00e1quina virtual (aseg\u00farate de que tanto m\u00e1quina virtual como ESP32 pertenecen a la misma red). Realiza procesos de publicaci\u00f3n y suscripci\u00f3n en la m\u00e1quina virtual que permitan visualizar los mensajes publicados por el ESP32 en tu terminal Linux, y los mensajes publicados desde el terminal Linux en la salida de monitorizaci\u00f3n del ESP32. Modifica el ejemplo y analiza el tr\u00e1fico generado (a trav\u00e9s de Wireshark) para los siguientes casos: Publicaci\u00f3n de mensajes con niveles de QoS 0, 1 y 2. Activaci\u00f3n o desactivaci\u00f3n del flag retain en la publicaci\u00f3n desde el ESP32. Configuraci\u00f3n de un mensaje LWT con el topic /disconnected . Para ello, reduce el valor de keepalive a 10 segundos, para que la detecci\u00f3n de desconexi\u00f3n sea m\u00e1s r\u00e1pida. Deber\u00e1s observar el env\u00edo del mensaje con dicho topic transcurrido dicho tiempo desde una desconexi\u00f3n forzada del ESP32 si est\u00e1s suscrito al mismo desde tu terminal Linux. Tarea Modifica el ejemplo proporcionado para que se integre en tu entorno de monitorizaci\u00f3n de un edificio. As\u00ed, el firmware proceder\u00e1 creando una tarea que, peri\u00f3dicamente (cada interval segundos), publique un valor aleatorio para los cuatro par\u00e1metros monitorizados. Adem\u00e1s, deber\u00e1s dise\u00f1a un sistema basado en MQTT mediante el cual puedas controlar, externamente, el comportamiento del sensor, atendiendo a los siguientes criterios: El tiempo ( interval ) mediante que transcurrir\u00e1 entre publicaciones ser\u00e1 configurable a trav\u00e9s de un proceso de publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. La sensorizaci\u00f3n (y publicaci\u00f3n de datos) podr\u00e1 activarse o desactivarse bajo demanda a trav\u00e9s de la publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. Por ejemplo, imagina que tu sensor publica mensajes de sensorizaci\u00f3n en el topic /EDIFICIO_3/P_4/N/12/(TEMP|HUM|LUX|VIBR) . Para controlar el intervalo de publicaci\u00f3n de datos desde dicho ESP32 y fijarlo a 1 segundo, podr\u00edamos publicar un mensaje utilizando la orden: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/interval -m \"1000\" -h IP_BROKER Para desactivar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/disable -m \"\" -h IP_BROKER Para activar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/enable -m \"\" -h IP_BROKER Opcionalmente, puedes ampliar tu soluci\u00f3n para que cada sensor se active o desactive individualmente bajo demanda. En este caso, elige y documenta el topic utilizado.","title":"API"},{"location":"Subjects/NP2/P7/","text":"Pr\u00e1ctica 7. El protocolo CoAP Objetivos El objetivo de esta pr\u00e1ctica es realizar una introducci\u00f3n al protocolo CoAP, uno de los m\u00e1s extendidos a d\u00eda de hoy para llevar a cabo comunicaciones M2M. Los objetivos did\u00e1cticos de la pr\u00e1ctica son: Entender la estructura cliente-servidor del protocolo CoAP. Comprender los mensajes utilizados para establecer una comunicaci\u00f3n CoAP, tanto a nivel de sintaxis como de sem\u00e1ntica. Modificar una aplicaci\u00f3n cliente/servidor ejemplo basada en libcoap que realice una comunicaci\u00f3n sencilla a trav\u00e9s del protocolo CoAP en un entorno Linux. Estudiar el componente libcoap en ESP-IDF para reproducir el comportamiento del servidor CoAP para ofrecer su fucionalidad desde un ESP32. Instalaci\u00f3n y requisitos previos En esta pr\u00e1ctica realizaremos un estudio del protocolo CoAP utilizando una implementaci\u00f3n ya desarrollada para un sistema cliente/servidor que hace uso del protocolo CoAP, distribuida a trav\u00e9s de la biblioteca libcoap . N\u00f3tese que se trata de una pr\u00e1ctica introductoria, ya que el protocolo CoAP se utilizar\u00e1, en sucesivas pr\u00e1cticas, para dar soporte a protocolos de m\u00e1s alto nivel (principalmente LWM2M). El objetivo principal de la pr\u00e1ctica es, pues, introducir a alto nivel las caracter\u00edsticas de CoAP como protocolo de capa de aplicaci\u00f3n, as\u00ed como ser capaces de interactuar con un servidor existente a trav\u00e9s de herramientas ya desarrolladas. De forma adicional, se estudiar\u00e1 la posibilidad de implementar un servidor CoAP en el ESP32. Instalaci\u00f3n de requisitos adicionales y libcoap En primer lugar, instalemos los prerequisitos necesarios para hacer funcionar {\\tt libcoap}. Para ello, en la m\u00e1quina virtual, ejecutaremos las siguientes \u00f3rdenes: sudo apt-get update sudo apt-get install libtool Procedemos ahora con la instalaci\u00f3n de {\\tt libcoap}. Para ello, descarga la \u00faltima versi\u00f3n de la biblioteca desde la p\u00e1gina web del proyecto, descompr\u00edmelo y pasa a la fase de compilaci\u00f3n e instalaci\u00f3n: sh autogen.sh ./configure --enable-examples --enable-dtls --with-openssl --disable-documentation make make install Si no hay ning\u00fan error, libcoap se habr\u00e1 instalado con \u00e9xito. Ser\u00e1 de especial inter\u00e9s para nosotros la instalaci\u00f3n de programas servidor ( coap-server ) y cliente ( coap-client ) de ejemplo en el directorio examples . Tarea Ejecuta los programas servidor y cliente CoAP del directorio examples . Estudia sus opciones y par\u00e1metros de configuraci\u00f3n. \u00bfEn qu\u00e9 puertos y bajo qu\u00e9 protocolos escucha el servidor CoAP tras su arranque? Intercambio de mensajes CoAP Tarea entregable En la presente secci\u00f3n se proponen distintos intercambios de mensajes CoAP entre el cliente y el servidor de ejemplo proporcionados como parte de la instalaci\u00f3n de libcoap . Para cada uno de ellos, se pide un estudio b\u00e1sico de los paquetes intercambiados, haciendo especial hincapi\u00e9 en la pila de protocolos utilizados, contenido de los paquetes y n\u00famero de paquetes intercambiados. Este estudio, incluyendo capturas y comentarios adicionales, conformar\u00e1 el entregable asociado a la pr\u00e1ctica. Arranque del servidor CoAP En primer lugar, realizaremos un intercambio b\u00e1sico de mensajes CoAP entre el cliente y el servidor. Para ello, abriremos dos terminales desde las que ejecutaremos, respectivamente, el servidor y el cliente. Tarea Investiga las opciones disponibles en el cliente y servidor con respecto a la cantidad de mensajes de depuraci\u00f3n a mostrar. Ejecuta el servidor CoAP con suficiente nivel de detalle en los mensajes de depuraci\u00f3n. Una vez arrancado el servidor, ejecuta la orden correspondiente desde l\u00ednea de \u00f3rdenes para averiguar qu\u00e9 puertos ha abierto, y por tanto c\u00f3mo nos podemos comunicar con \u00e9l. Averigua si estos puertos son bien conocidos well-known , valor menor a 1024) y, en su caso, c\u00f3mo pueden modificarse. Obtenci\u00f3n de informaci\u00f3n del servidor ( Resource Discovery ) En primer lugar, obtendremos la informaci\u00f3n sobre los recursos disponibles en el servidor CoAP. Para ello, realizaremos una petici\u00f3n GET sobre el recurso /.well-known/core del servidor. Esta transacci\u00f3n nos devolver\u00e1 los recursos disponibles en el mismo, as\u00ed como algunas caracter\u00edsticas adicionales. Tarea \u00bfQu\u00e9 recursos est\u00e1n disponibles en el servidor? Estudia el c\u00f3digo fuente del mismo para observar la correlaci\u00f3n entre los recursos descubiertos y los programados en el c\u00f3digo. Averigua el significado de los atributos rt , ct , if y *title. Obtenci\u00f3n de informaci\u00f3n desde recursos Utilizando el cliente CoAP proporcionado, resulta sencillo realizar consultas para obtener datos desde el servidor. Para ello, utilizaremos la acci\u00f3n (verbo) {\\tt GET}, seguido del recurso a consultar y, opcionalmente, de una consulta concreta. Tarea Consulta la marca de tiempo proporcionada por el servidor en modo legible (por ejemplo, Dec 13 14:20:43 ), y tambi\u00e9n en forma de ticks de reloj, utilizando la consulta adecuada. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito? Modificaci\u00f3n de recursos Al igual que con el verbo GET, es posible realizar modificaciones en el servidor utilizando el verbo PUT. Consulta la ayuda del cliente proporcionado para observar alg\u00fan ejemplo que d\u00e9 soporte a esta funcionalidad. Tarea Modifica la marca de tiempo que proporciona el servidor CoAP. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito? Eliminaci\u00f3n y creaci\u00f3n de recursos Es posible eliminar un determinado recurso (en el ejemplo, el temporizador), utilizando el verbo DELETE . Investiga c\u00f3mo hacerlo desde el cliente proporcionado. Tarea Elimina el recurso time del servidor y, a continuaci\u00f3n, modifica la marca de tiempo mediante una orden PUT }. \u00bfQu\u00e9 valores de retorno (c\u00f3digo) se devuelven en ambos casos?} Suscripci\u00f3n (observaci\u00f3n) de recursos Es posible suscribirse a los cambios en el valor de un recurso utilizando la opci\u00f3n -s del cliente. Tarea Activa la observaci\u00f3n sobre el recurso time del servidor y analiza tanto la frecuencia de respuesta como el intercambio de mensajes producido (a trav\u00e9s de Wireshark ). \u00bfSe producen peticiones peri\u00f3dicas usando GET ? CoAP sobre TCP Alternativamente, CoAP puede funcionar utilizando el protocolo de capa de transporte TCP. En este caso, como es l\u00f3gico, se establecer\u00e1 una conexi\u00f3n entre cliente y servidor previa a cualquier intercambio de datos. Tarea Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP? Tareas entregables Tarea entregable Deber\u00e1s entregar una memoria en la que se incida en detalles observados y aprendidos acerca del protocolo CoAP, con especial atenci\u00f3n a las capturas obtenidas a trav\u00e9s de Wireshark. Tarea entregable Estudia el c\u00f3digo del servidor proporcionado, especialmente de la funci\u00f3n init_resources , y a\u00f1ade un nuevo recurso llamado temperature . Este recurso aceptar\u00e1 dos consultas distintas: ?celsius (consulta por defecto) devolver\u00e1 el valor de temperatura expresado en grados cent\u00edgrados, mientras que \\tt fahrenheit devolver\u00e1 la temperatura en grados Fahrenheit. En este caso, el valor de temperatura se obtendr\u00e1 directamente a trav\u00e9s de un n\u00famero aleatorio, pero se valorar\u00e1 su obtenci\u00f3n a partir de un sensor real. Tarea entregable ESP-IDF incluye un port de libcoap . El ejemplo examples/protocols/coap_server implementa un servidor CoAP b\u00e1sico, con un s\u00f3lo recurso (puedes consultarlo t\u00fa mismo/a obteniendo la informaci\u00f3n del recurso /well-known/core ). Analiza el c\u00f3digo y observa que la biblioteca libcoap se utiliza de forma exacta a como has estudiado en el c\u00f3digo del servidor de ejemplo. Se pide modificar el firmware para dar soporte al recurso time de forma id\u00e9ntica (con la misma sem\u00e1ntica) que la utilizada en el host .","title":"Pr\u00e1ctica 7. El protocolo CoAP"},{"location":"Subjects/NP2/P7/#practica-7-el-protocolo-coap","text":"","title":"Pr\u00e1ctica 7. El protocolo CoAP"},{"location":"Subjects/NP2/P7/#objetivos","text":"El objetivo de esta pr\u00e1ctica es realizar una introducci\u00f3n al protocolo CoAP, uno de los m\u00e1s extendidos a d\u00eda de hoy para llevar a cabo comunicaciones M2M. Los objetivos did\u00e1cticos de la pr\u00e1ctica son: Entender la estructura cliente-servidor del protocolo CoAP. Comprender los mensajes utilizados para establecer una comunicaci\u00f3n CoAP, tanto a nivel de sintaxis como de sem\u00e1ntica. Modificar una aplicaci\u00f3n cliente/servidor ejemplo basada en libcoap que realice una comunicaci\u00f3n sencilla a trav\u00e9s del protocolo CoAP en un entorno Linux. Estudiar el componente libcoap en ESP-IDF para reproducir el comportamiento del servidor CoAP para ofrecer su fucionalidad desde un ESP32.","title":"Objetivos"},{"location":"Subjects/NP2/P7/#instalacion-y-requisitos-previos","text":"En esta pr\u00e1ctica realizaremos un estudio del protocolo CoAP utilizando una implementaci\u00f3n ya desarrollada para un sistema cliente/servidor que hace uso del protocolo CoAP, distribuida a trav\u00e9s de la biblioteca libcoap . N\u00f3tese que se trata de una pr\u00e1ctica introductoria, ya que el protocolo CoAP se utilizar\u00e1, en sucesivas pr\u00e1cticas, para dar soporte a protocolos de m\u00e1s alto nivel (principalmente LWM2M). El objetivo principal de la pr\u00e1ctica es, pues, introducir a alto nivel las caracter\u00edsticas de CoAP como protocolo de capa de aplicaci\u00f3n, as\u00ed como ser capaces de interactuar con un servidor existente a trav\u00e9s de herramientas ya desarrolladas. De forma adicional, se estudiar\u00e1 la posibilidad de implementar un servidor CoAP en el ESP32.","title":"Instalaci\u00f3n y requisitos previos"},{"location":"Subjects/NP2/P7/#instalacion-de-requisitos-adicionales-y-libcoap","text":"En primer lugar, instalemos los prerequisitos necesarios para hacer funcionar {\\tt libcoap}. Para ello, en la m\u00e1quina virtual, ejecutaremos las siguientes \u00f3rdenes: sudo apt-get update sudo apt-get install libtool Procedemos ahora con la instalaci\u00f3n de {\\tt libcoap}. Para ello, descarga la \u00faltima versi\u00f3n de la biblioteca desde la p\u00e1gina web del proyecto, descompr\u00edmelo y pasa a la fase de compilaci\u00f3n e instalaci\u00f3n: sh autogen.sh ./configure --enable-examples --enable-dtls --with-openssl --disable-documentation make make install Si no hay ning\u00fan error, libcoap se habr\u00e1 instalado con \u00e9xito. Ser\u00e1 de especial inter\u00e9s para nosotros la instalaci\u00f3n de programas servidor ( coap-server ) y cliente ( coap-client ) de ejemplo en el directorio examples . Tarea Ejecuta los programas servidor y cliente CoAP del directorio examples . Estudia sus opciones y par\u00e1metros de configuraci\u00f3n. \u00bfEn qu\u00e9 puertos y bajo qu\u00e9 protocolos escucha el servidor CoAP tras su arranque?","title":"Instalaci\u00f3n de requisitos adicionales y libcoap"},{"location":"Subjects/NP2/P7/#intercambio-de-mensajes-coap","text":"Tarea entregable En la presente secci\u00f3n se proponen distintos intercambios de mensajes CoAP entre el cliente y el servidor de ejemplo proporcionados como parte de la instalaci\u00f3n de libcoap . Para cada uno de ellos, se pide un estudio b\u00e1sico de los paquetes intercambiados, haciendo especial hincapi\u00e9 en la pila de protocolos utilizados, contenido de los paquetes y n\u00famero de paquetes intercambiados. Este estudio, incluyendo capturas y comentarios adicionales, conformar\u00e1 el entregable asociado a la pr\u00e1ctica.","title":"Intercambio de mensajes CoAP"},{"location":"Subjects/NP2/P7/#arranque-del-servidor-coap","text":"En primer lugar, realizaremos un intercambio b\u00e1sico de mensajes CoAP entre el cliente y el servidor. Para ello, abriremos dos terminales desde las que ejecutaremos, respectivamente, el servidor y el cliente. Tarea Investiga las opciones disponibles en el cliente y servidor con respecto a la cantidad de mensajes de depuraci\u00f3n a mostrar. Ejecuta el servidor CoAP con suficiente nivel de detalle en los mensajes de depuraci\u00f3n. Una vez arrancado el servidor, ejecuta la orden correspondiente desde l\u00ednea de \u00f3rdenes para averiguar qu\u00e9 puertos ha abierto, y por tanto c\u00f3mo nos podemos comunicar con \u00e9l. Averigua si estos puertos son bien conocidos well-known , valor menor a 1024) y, en su caso, c\u00f3mo pueden modificarse.","title":"Arranque del servidor CoAP"},{"location":"Subjects/NP2/P7/#obtencion-de-informacion-del-servidor-resource-discovery","text":"En primer lugar, obtendremos la informaci\u00f3n sobre los recursos disponibles en el servidor CoAP. Para ello, realizaremos una petici\u00f3n GET sobre el recurso /.well-known/core del servidor. Esta transacci\u00f3n nos devolver\u00e1 los recursos disponibles en el mismo, as\u00ed como algunas caracter\u00edsticas adicionales. Tarea \u00bfQu\u00e9 recursos est\u00e1n disponibles en el servidor? Estudia el c\u00f3digo fuente del mismo para observar la correlaci\u00f3n entre los recursos descubiertos y los programados en el c\u00f3digo. Averigua el significado de los atributos rt , ct , if y *title.","title":"Obtenci\u00f3n de informaci\u00f3n del servidor (Resource Discovery)"},{"location":"Subjects/NP2/P7/#obtencion-de-informacion-desde-recursos","text":"Utilizando el cliente CoAP proporcionado, resulta sencillo realizar consultas para obtener datos desde el servidor. Para ello, utilizaremos la acci\u00f3n (verbo) {\\tt GET}, seguido del recurso a consultar y, opcionalmente, de una consulta concreta. Tarea Consulta la marca de tiempo proporcionada por el servidor en modo legible (por ejemplo, Dec 13 14:20:43 ), y tambi\u00e9n en forma de ticks de reloj, utilizando la consulta adecuada. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito?","title":"Obtenci\u00f3n de informaci\u00f3n desde recursos"},{"location":"Subjects/NP2/P7/#modificacion-de-recursos","text":"Al igual que con el verbo GET, es posible realizar modificaciones en el servidor utilizando el verbo PUT. Consulta la ayuda del cliente proporcionado para observar alg\u00fan ejemplo que d\u00e9 soporte a esta funcionalidad. Tarea Modifica la marca de tiempo que proporciona el servidor CoAP. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito?","title":"Modificaci\u00f3n de recursos"},{"location":"Subjects/NP2/P7/#eliminacion-y-creacion-de-recursos","text":"Es posible eliminar un determinado recurso (en el ejemplo, el temporizador), utilizando el verbo DELETE . Investiga c\u00f3mo hacerlo desde el cliente proporcionado. Tarea Elimina el recurso time del servidor y, a continuaci\u00f3n, modifica la marca de tiempo mediante una orden PUT }. \u00bfQu\u00e9 valores de retorno (c\u00f3digo) se devuelven en ambos casos?}","title":"Eliminaci\u00f3n y creaci\u00f3n de recursos"},{"location":"Subjects/NP2/P7/#suscripcion-observacion-de-recursos","text":"Es posible suscribirse a los cambios en el valor de un recurso utilizando la opci\u00f3n -s del cliente. Tarea Activa la observaci\u00f3n sobre el recurso time del servidor y analiza tanto la frecuencia de respuesta como el intercambio de mensajes producido (a trav\u00e9s de Wireshark ). \u00bfSe producen peticiones peri\u00f3dicas usando GET ?","title":"Suscripci\u00f3n (observaci\u00f3n) de recursos"},{"location":"Subjects/NP2/P7/#coap-sobre-tcp","text":"Alternativamente, CoAP puede funcionar utilizando el protocolo de capa de transporte TCP. En este caso, como es l\u00f3gico, se establecer\u00e1 una conexi\u00f3n entre cliente y servidor previa a cualquier intercambio de datos. Tarea Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP?","title":"CoAP sobre TCP"},{"location":"Subjects/NP2/P7/#tareas-entregables","text":"Tarea entregable Deber\u00e1s entregar una memoria en la que se incida en detalles observados y aprendidos acerca del protocolo CoAP, con especial atenci\u00f3n a las capturas obtenidas a trav\u00e9s de Wireshark. Tarea entregable Estudia el c\u00f3digo del servidor proporcionado, especialmente de la funci\u00f3n init_resources , y a\u00f1ade un nuevo recurso llamado temperature . Este recurso aceptar\u00e1 dos consultas distintas: ?celsius (consulta por defecto) devolver\u00e1 el valor de temperatura expresado en grados cent\u00edgrados, mientras que \\tt fahrenheit devolver\u00e1 la temperatura en grados Fahrenheit. En este caso, el valor de temperatura se obtendr\u00e1 directamente a trav\u00e9s de un n\u00famero aleatorio, pero se valorar\u00e1 su obtenci\u00f3n a partir de un sensor real. Tarea entregable ESP-IDF incluye un port de libcoap . El ejemplo examples/protocols/coap_server implementa un servidor CoAP b\u00e1sico, con un s\u00f3lo recurso (puedes consultarlo t\u00fa mismo/a obteniendo la informaci\u00f3n del recurso /well-known/core ). Analiza el c\u00f3digo y observa que la biblioteca libcoap se utiliza de forma exacta a como has estudiado en el c\u00f3digo del servidor de ejemplo. Se pide modificar el firmware para dar soporte al recurso time de forma id\u00e9ntica (con la misma sem\u00e1ntica) que la utilizada en el host .","title":"Tareas entregables"},{"location":"Subjects/NP2/P8/","text":"Pr\u00e1ctica 8. El protocolo LWM2M Objetivos Familiarizarse con el protocolo LWM2M, tanto en la interacci\u00f3n con servidores como en la generaci\u00f3n y definici\u00f3n de objetos y recursos. Familiarizarse con el protocolo de bootstrapping LWM2M y entender su importancia en entornos reales. Conocer dos herramientas para el desarrollo de sistemas basados en LWM2M: Wakaama y Leshan. Experimentar con el proceso de definici\u00f3n de objetos en Wakaama. Observar y poner en marcha un proceso de provisionamiento ( bootstrapping ) usando Wakaama. Desplegar servidores locales LWM2M usando tanto Wakaama como Leshan. El protocolo LWM2M OMA Lightweight M2M (LWM2M) es un protocolo impulsado por la Open Mobile Alliance para la comunicaci\u00f3n M2M entre dispositivos y su gesti\u00f3n en entornos IoT. LWM2M est\u00e1 construido sobre el protocolo CoAP, y soporta, a nivel de transporte, el protocolo UDP (tambi\u00e9n presenta soporte para SMS). Entre las funcionalidades b\u00e1sicas de LWM2M destacan la existencia de servidores LWM2M, bootstrapping , control de acceso, gesti\u00f3n de dispositivos, actualizaciones de firmware , localizaci\u00f3n o estad\u00edsticas de conectividad. Adem\u00e1s, soporta seguridad a trav\u00e9s de DTLS. Concretamente, la primera especificaci\u00f3n de LWM2M (versi\u00f3n 1.0) introdujo las siguientes caracter\u00edsticas b\u00e1sicas: Definici\u00f3n de un modelo simple para la definici\u00f3n de recursos, basado en objetos. Definici\u00f3n de operaciones de creaci\u00f3n, consulta, modificaci\u00f3n, borrado y configuraci\u00f3n de recursos. Observaci\u00f3n/notificaci\u00f3n sobre recursos. Soporte para formato de datos JSON, texto plano y TLV. Colas de mensajes para soportar modos de bajo consumo en dispositivos. Soporte para m\u00faltiples servidores LWM2M. Objetos b\u00e1sicos LWM2M: Seguridad, Servidor, Control de Acceso, Dispositivo, Conectividad, Actualizaci\u00f3n de Firmware, Localizaci\u00f3n, Estad\u00edsticas de Conectividad. Para m\u00e1s informaci\u00f3n sobre los objetos predefinidos, consulta el siguiente enlace . Versiones subsiguientes del protocolo (1.1 y 1.2) introdujeron caracter\u00edsticas adicionales, como por ejemplo: Mejora del proceso de bootstrapping . Mejora del soporte para PKI. Soporte para TCP/TLS. Soporte para CBOR. Soporte para MQTT y HTTP como protocolos subyacentes. Implementaciones LWM2M En la presente pr\u00e1ctica, utilizaremos dos paquetes de software pertenecientes al proyecto Eclipse IoT, ambos con soporte completo para LWM2M. Cada uno de ellos presenta ventajas e inconvenientes que es necesario conocer. Eclipse Wakaama Eclipse Wakaama es un conjunto de ficheros fuente escritos en C que permiten ser integrados en cualquier proyecto para proporcionar funcionalidad de cliente , servidor y servidor de bootstrap LWM2M hasta su versi\u00f3n 1.1. En el lado cliente, Wakaama permite la definici\u00f3n de objetos conforme al est\u00e1ndar, as\u00ed como la recepci\u00f3n de comandos desde servidores y su enrutado hacia el objeto u objetos correspondientes. Desde el punto de vista servidor, Wakaama proporciona APIs para enviar comandos a clientes LWM2M registrados. Todo el proyecto es compatible con POSIX, y en esta pr\u00e1ctica experimentaremos con su funcionalidad trabajando desde Linux (modo cliente, servidor y servidor de bootstrap ) y desde el ESP32 (modo cliente). Instalaci\u00f3n Utilizaremos una versi\u00f3n espec\u00edfica que permitir\u00e1 ser ejecutada tanto en Linux como en el ESP32. Para ello, clonamos en primer lugar la versi\u00f3n correspondiente del proyecto (es importante que utilices este commit espec\u00edfico): git clone https://github.com/eclipse/wakaama.git cd wakaama git reset --hard 31d64c0c41fae9653c1fa53ef58d1a44e49017fa El proyecto Wakaama proporciona cuatro componentes que utilizaremos durante la pr\u00e1ctica, todos dentro del directorio examples : bootstrap_server : implementa un servidor de bootstrap con l\u00ednea de comandos propia. client : implementa un cliente complejo, con definici\u00f3n de nueve objetos que siguen las especificaciones de la OMA m\u00e1s uno propio, y soporte para bootstrapping . lightclient : implementa un cliente sencillo, con definici\u00f3n de tres objetos seg\u00fan especificaciones OMA y un cuarto objeto propio. server : implementa un servidor LWM2M que ofrece l\u00ednea de comandos para la interacci\u00f3n con clientes registrados. El modo de compilar cada uno de los ejemplos es exactamente el mismo: Dir\u00edgete al directorio del ejemplo. Crea un directorio build y accede a \u00e9l. Configura el proyecto con la orden cmake .. . Compila el ejemplo con la orden make . Si todo ha ido bien, deber\u00edas tener un binario distinto en el directorio build correspondiente, con los que trabajar\u00e1s el resto de la pr\u00e1ctica. Tarea Compila cada uno de los ejemplos anteriormente mencionados en tu m\u00e1quina virtual, utilizando los par\u00e1metros por defecto para cada uno de ellos. Eclipse Leshan Eclipse Leshan es un proyecto alternativo que proporciona implementaciones en Java de clientes, servidores y servidores de bootstrap LWM2M, y est\u00e1 especialmente dise\u00f1ado para ser adaptable y extensible, permitiendo a los desarrolladores implementar sus propias versiones de cada uno de los tres anteriores elmentos adaptados a sus necesidades espec\u00edficas. Al igual que Wakaama, Leshan proporciona la definici\u00f3n e interacci\u00f3n con objetos IPSO, construcci\u00f3n sobre DTLS y utilizaci\u00f3n de CoAP como protocolo subyacente. Adem\u00e1s, el proyecto proporciona dos servidores de test que resultan muy \u00fatiles a la hora de desarrollar, v\u00e9ase: Servidor LWM2M en leshan.eclipseprojects.io , disponible en coap://leshan.eclipseprojects.io:5683 y coaps://leshan.eclipseprojects.io:5684 . Servidor de bootstrap en leshan.eclipseprojects.io/bs , disponible en coap://leshan.eclipseprojects.io:5783 y coaps://leshan.eclipseprojects.io:5784 . Instalaci\u00f3n Instala en primer lugar los prerequisitos necesarios para la correcta instalaci\u00f3n de Leshan (pueden variar en funci\u00f3n de tu distribuci\u00f3n Linux): sudo apt-get update sudo apt-get install openjdk-14-jdk maven git-core Clona el repositorio oficial de Leshan desde la siguiente direcci\u00f3n: git clone https://github.com/eclipse/leshan.git Por \u00faltimo, compila el proyecto: cd leshan mvn clean install Tras la fase de instalaci\u00f3n, podr\u00e1s lanzar tanto el servidor LWM2M: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. Como el servidor de bootstrapping : java -jar leshan-bsserver-demo/target/leshan-bsserver-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. En ambos casos, la salida asociada a la ejecuci\u00f3n de los servidores nos indicar\u00e1n la URL que podremos consultar desde cualquier navegador para obtener informaci\u00f3n del mismo, as\u00ed como la URL y puerto de escucha de cada uno, que deberemos indicar en los clientes correspondientes. Tarea Instala Eclipse Leshan y arranca el servidor LWM2M. Accede a la p\u00e1gina web de gesti\u00f3n y comprueba que efectivamente funciona. A continucaci\u00f3n, detenlo y haz lo propio con el servidor de bootstrapping . Eclipse Wakaama. Cliente y servidor LWM2M El objetivo principal de esta parte de la pr\u00e1ctica ser\u00e1 disponer de un sistema completo LWM2M basado en un cliente y dos servidores (uno LWM2M, otro de bootstrapping ), todos funcionando bajo Eclipse Wakaama. Para ello, en primer lugar, arrancaremos el servidor Wakaama en una de las terminales. Observa que el servidor, tras arrancar, expone una sencilla l\u00ednea de comandos que podemos aprovechar para interactuar con \u00e9l: ./lwm2mserver > help help Type 'help [COMMAND]' for more details on a command. list List registered clients. read Read from a client. disc Discover resources of a client. write Write to a client. time Write time-related attributes to a client. attr Write value-related attributes to a client. clear Clear attributes of a client. exec Execute a client resource. del Delete a client Object instance. create Create an Object instance. observe Observe from a client. cancel Cancel an observe. q Quit the server. La orden help muestra la ayuda global, pudi\u00e9ndose especializar para cada comando concreto: > help read read CLIENT# URI CLIENT#: client number as returned by command 'list' URI: uri to read such as /3, /3/0/2, /1024/11, /1024/0/1 Result will be displayed asynchronously. Si en este instante listamos un los clientes registrados, veremos que no hay ninguno: > list No client. En segundo lugar, vamos a arrancar el cliente Wakaama. Por defecto, este cliente intentar\u00e1 conectar con un servidor LWM2M existente en localhost , puerto 5683. En cualquier caso, estos valores pueden modificarse en la propia invocaci\u00f3n (consulta la opci\u00f3n -h para m\u00e1s informaci\u00f3n sobre par\u00e1metros disponibles): ./lwm2mclient Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > Opening connection to server at ::1:5683 -> State: STATE_REGISTERING 13 bytes received from [::1]:5683 64 41 69 06 06 69 E8 86 82 72 64 01 30 dAi..i...rd.0 -> State: STATE_READY > help help Type 'help [COMMAND]' for more details on a command. list List known servers. change Change the value of resource. update Trigger a registration update bootstrap Initiate a DI bootstrap process dispb Display current backup of objects/instances/resources (only security and server objects are backupped) ls List Objects and Instances disp Display current objects/instances/resources dump Dump an Object add Add support of object 31024 rm Remove support of object 31024 quit Quit the client gracefully. ^C Quit the client abruptly (without sending a de-register message). > -> State: STATE_READY Al igual que el servidor, el cliente soporta la introducci\u00f3n de comandos por parte del usuario. Observa que hemos ejecutado el comando help para mostrar los comandos disponibles. Adem\u00e1s, el cliente ha pasado desde un estado STATE_REGISTERING a un estado STATE_READY , lo que significa que se ha registrado correctamente en el servidor con el nombre testlwm2mclient . Observa ahora la salida del servidor, y ver\u00e1s que \u00e9ste ha realizado un proceso de descubrimiento de recursos en el cliente conectado. Concretamente, el servidor reporta la informaci\u00f3n relativa al nuevo cliente conectado: New client #0 registered. Client #0: name: \"testlwm2mclient\" version: \"1.1\" binding: \"UDP\" lifetime: 300 sec objects: /1/0, /2/0, /3/0, /4/0, /5/0, /6/0, /7/0, /31024/10, /31024/11, /31024/12, Concretamente, el n\u00famero asociado al cliente es el 0 . Podemos recuperar esta informaci\u00f3n en todo momento con el comando list en el servidor. En el cliente, puedes seleccionar el nombre que se utilizar\u00e1 en el proceso de registro con la opci\u00f3n -n . Tarea entregable Observa, utilizando Wireshark, el proceso de registro de un cliente en un servidor, y analiza el contenido del mensaje o mensajes intercambiados entre ambos. \u00bfQu\u00e9 protocolos se utilizan? El cliente con el que estamos trabajando es suficientemente complejo en su funcionamiento, y permite observar c\u00f3mo se implementa el soporte tanto para objetos predefinidos por la OMA como para objetos propios. Concretamente, el cliente implementa nueve objetos distintos: Security Object ( id=0 ). Server Object ( id=1 ). Access Control Object ( id=2 ), como un simple esqueleto, sin funcionalidad asociada. Device Object ( id=3 ), que contiene (y devuelve) valores espec\u00edficos codificados en base al ap\u00e9ndice E de la especificaci\u00f3n t\u00e9cnica de LWM2M. Connectivity Monitoring Object ( id=4 ), como un simple esqueleto, sin funcionalidad. Firmware Update Object ( id=5 ), como un simple esqueleto, sin funcionalidad. Location Object ( id=6 ), como un simple esqueleto, sin funcionalidad. Connectivity Statistics Object ( id=7 ), como un simple esqueleto, sin funcionalidad. Test Object ( id=31024 ), con la siguiente descripci\u00f3n: Objetos: Objeto ID Multiples Instancias Obligatorio Test 31024 S\u00ed No Recurso: Nombre ID Operaciones M\u00faltiples Instancias Obligatorio Tipo Rango test 1 R/W No Yes Integer 0-255 exec 2 E No Yes dec 3 R/W No Yes Float En el cliente, el comando dump nos permitir\u00e1 observar el contenido de una instancia determinada de un objeto, o de todas ellas. En el servidor, el comando read nos permitir\u00e1 hacer lo propio. Tarea entregable Analiza el valor actual de los objetos /3 y el objeto de test, tanto desde el cliente (comando dump ) como desde el servidor (comando read ). En \u00faltimo caso, realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos. Para escribir en un determinado recurso desde el servidor, podemos hacer uso del comando write de la siguiente forma: write 0 /31024/10/1 91 As\u00ed, estar\u00edamos escribiendo en el recurso 1 de la instancia 10 del objeto 31024 el valor entero 91. Tarea entregable Realiza escrituras en objetos del cliente y analiza el nuevo valor, comprobando que efectivamente se han llevado a cabo. Realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos en el caso de una escritura. Observa tambi\u00e9n que el servidor permite la observaci\u00f3n de recursos espec\u00edficos (comando observe ). Experimenta con esta opci\u00f3n y observa el tr\u00e1fico generado (puedes modificar el valor de un recurso desde el propio cliente y ver qu\u00e9 ocurre en el servidor). Por \u00faltimo, con la orden quit desconectamos del servidor. Observa tambi\u00e9n los mensajes CoAP que se generan en este caso. Definici\u00f3n de un objeto en Eclipse Wakaama Como has podido observar, el ejemplo de cliente define una serie de objetos, algunos especificados por la OMA, y otros personalizados. En este \u00faltimo caso, al que nos referiremos como test_object , se utilizan e ilustran algunas de las funcionalidades b\u00e1sicas de Wakaama como infraestructura para el desarrollo de Smart Objects v\u00eda LWM2M. Observa tanto el c\u00f3digo del cliente LWM2M (fichero fuente lwm2mclient.c del ejemplo client ) como la definici\u00f3n del objeto de test (fichero fuente test_object.c ). El primer fichero implementa la l\u00f3gica principal del cliente, incluyendo gesti\u00f3n de la conexi\u00f3n, l\u00f3gica de an\u00e1lisis de comandos introducidos por el usuario, gesti\u00f3n de bootstrapping , etc. Concretamente, nos interesa analizar las l\u00edneas relativas a la invocaci\u00f3n de la funci\u00f3n get_test_object , en cuyo interior se definen tanto los recursos como el comportamiento de nuestro cliente ante distintos tipos de operaciones sobre ellos. Observa que, al igual que para nuestro objeto de test, existen funciones similares para el resto de objetos definidos (obviamente podr\u00edan existir m\u00e1s), con un fichero fuente donde se define el comportamiento de cada uno de ellos. Uno de estos objetos es test_object.c . La principal funci\u00f3n de entrada a este m\u00f3dulo es precisamente get_test_object() . Observa que, en ella, se define el identificador del objeto, as\u00ed como cada uno de los recursos que expone (en este caso, tres), sus valores iniciales, y las funciones que se utilizar\u00e1n como callbacks asociados a cada posible operaci\u00f3n: lwm2m_object_t * testObj; testObj = (lwm2m_object_t *)lwm2m_malloc(sizeof(lwm2m_object_t)); if (NULL != testObj) { int i; prv_instance_t * targetP; memset(testObj, 0, sizeof(lwm2m_object_t)); testObj->objID = TEST_OBJECT_ID; for (i=0 ; i < 3 ; i++) { targetP = (prv_instance_t *)lwm2m_malloc(sizeof(prv_instance_t)); if (NULL == targetP) return NULL; memset(targetP, 0, sizeof(prv_instance_t)); targetP->shortID = 10 + i; targetP->test = 20 + i; targetP->dec = -30 + i + (double)i/100.0; testObj->instanceList = LWM2M_LIST_ADD(testObj->instanceList, targetP); } /* * From a single instance object, two more functions are available. * - The first one (createFunc) create a new instance and filled it with the provided informations. If an ID is * provided a check is done for verifying his disponibility, or a new one is generated. * - The other one (deleteFunc) delete an instance by removing it from the instance list (and freeing the memory * allocated to it) */ testObj->readFunc = prv_read; testObj->discoverFunc = prv_discover; testObj->writeFunc = prv_write; testObj->executeFunc = prv_exec; testObj->createFunc = prv_create; testObj->deleteFunc = prv_delete; } return testObj; Estas funciones de callback est\u00e1n definidas en el propio fichero, y su contenido es personalizable en funci\u00f3n del dise\u00f1o del objeto. Observemos, por ejemplo, el contenido de la funci\u00f3n asociada a la lectura, prv_read : static uint8_t prv_read(uint16_t instanceId, int * numDataP, lwm2m_data_t ** dataArrayP, lwm2m_object_t * objectP) { prv_instance_t * targetP; int i; targetP = (prv_instance_t *)lwm2m_list_find(objectP->instanceList, instanceId); if (NULL == targetP) return COAP_404_NOT_FOUND; if (*numDataP == 0) { *dataArrayP = lwm2m_data_new(2); if (*dataArrayP == NULL) return COAP_500_INTERNAL_SERVER_ERROR; *numDataP = 2; (*dataArrayP)[0].id = 1; (*dataArrayP)[1].id = 3; } for (i = 0 ; i < *numDataP ; i++) { switch ((*dataArrayP)[i].id) { case 1: lwm2m_data_encode_int(targetP->test, *dataArrayP + i); break; case 2: return COAP_405_METHOD_NOT_ALLOWED; case 3: lwm2m_data_encode_float(targetP->dec, *dataArrayP + i); break; default: return COAP_404_NOT_FOUND; } } return COAP_205_CONTENT; } Observa que en primer lugar se busca la instancia del objeto solicitada, devolvi\u00e9ndose el error correspondiente en caso de no existir (puedes comprobar esta funcionalidad solicitando desde el servidor la lectura de una instancia inexistente). El par\u00e1metro numDataP nos indica el recurso concreto que se desea leer, o todos si dicho valor es 0. Tras tomar el valor actual a servir, \u00e9ste se codifica en funci\u00f3n del tipo de datos predefinido para el recurso espec\u00edfico solicitado. En caso de no estar soportado el m\u00e9todo para un recurso espec\u00edfico, se devuelve el error correspondiente (en este caso 405 ). En caso de solicitar un recurso inexistente, se devuelve el error 404 . Tarea Comprueba que el comportamiento del objeto de test es el esperado, interactuando con \u00e9l desde el servidor utilizando todos los m\u00e9todos disponibles. Puedes modificar su comportamiento, a\u00f1adir invocaciones a rutinas de log , o lo que consideres de utilidad. Eclipse Wakaama. Bootstrapping En este punto, el cliente Wakaama se conecta directamente con el servidor que hemos lanzado, y cuya direcci\u00f3n IP y puerto son los proporcionados por defecto en el c\u00f3digo. Llevado el cliente a un sensor, esto har\u00eda que nunca pudiese variar, durante el ciclo de vida del mismo, el servidor (o servidores) a los que conecta. Esto hace tambi\u00e9n que un cliente pueda \u00fanicamente conectar con un servidor LWM2M, cuando en algunas ocasiones es deseable replicar los mensajes enviados a m\u00faltiples servidores, bien por razones de tolerancia a fallos, o bien por necesidades de la aplicaci\u00f3n. Para solucionar este problema, los firmwares de f\u00e1brica suelen conocer \u00fanicamente la direcci\u00f3n o direcciones fijas de uno o varios servidores de bootstrap que, ante peticiones de provisionamiento, proporcionan al cliente las credenciales de seguridad y las direcciones de los servidores LWM2M en los que deben registrarse. As\u00ed, resulta sencillo manejar din\u00e1micamente ambos aspectos sin necesitar reflashear el firmware del sensor. En nuestro caso, utilizaremos un sencillo servidor de bootstrap proporcionado por Wakaama, aunque Leshan ofrece mecanismos mucho m\u00e1s sofisticados para realizar este mismo proceso, con su propio esqueleto de servidor bootstrap e interfaces REST (con monitores web) para gestionar el proceso. En primer lugar, dir\u00edgete al directorio que contiene el servidor bootstrap de Wakaama. All\u00ed encontrar\u00e1s un fichero de configuraci\u00f3n ( bootstrap_server.ini ) para el proceso de bootstrapping , cuyo contenido es completamente estructurado. El servidor, ante una petici\u00f3n de bootstrapping por parte de un cliente, responde en funci\u00f3n del contenido del fichero, que sigue las siguientes directivas: Las secciones soportadas son [Server] y [Endpoint] . [Server] describe una cuenta en un servidor LWM2M: Las claves soportadas en esta secci\u00f3n son: id: Identificador del servidor. (OBLIGATORIO). uri: URI del servidor LWM2M (OBLIGATORIO). bootstrap: YES o NO. Determina si este servidor es un servidor de bootstrap. Su valor por defecto es NO. lifetime: tiempo de vida del registro (opcional). security: modo de seguridad. Valores soportados: NoSec, PSK, RPK and Certificate (OBLIGATORIO). public: clave p\u00fablica o identidad del cliente, definida por el recurso /0/x/3 . server: clave p\u00fablica del servidor, definida por el recurso /0/x/4 . secret: clave privada definida por el recurso /0/x/5 . [Endpoint] contiene las operaciones de bootstrapping Si no se especifica un nombre (Name) las operaciones se enviar\u00e1n a cualquier cliente desconocido que solicite bootstrapping Si se especifica, las operaciones se enviar\u00e1n s\u00f3lo al cliente con el correspondiente nombre. Las operaciones se env\u00edan en el orden definido en el fichero. Las claves soportadas en esta secci\u00f3n son: - Name: Nombre del cliente (OPCIONAL). - Delete: Debe ser una URI LWM2M v\u00e1lida, incluida / . Env\u00eda una operaci\u00f3n delete en la URI indicada. - Server: [Value] es un ID de servidor que debe existir en la secci\u00f3n correspondiente. Env\u00eda operaciones de escritura sobre el objeto correspondiente del cliente para definir el servidor sobre el que debe conectar. Tarea Analiza e intenta entender el contenido por defecto del fichero de bootstrapping proporcionado. Puedes de momento obviar los par\u00e1metros referentes a seguridad, ya que los trataremos en la pr\u00f3xima pr\u00e1ctica. Tarea entregable Modifica el fichero de configuraci\u00f3n para que, ante la petici\u00f3n de un cliente con nombre determinado, conecte, por este orden, a un servidor LWM2M en la m\u00e1quina local, y al servidor de pruebas de Leshan en Internet. Adem\u00e1s, elimina cualquier intento de borrado de recursos en la informaci\u00f3n de bootstrapping para dicho cliente. Para arrancar el servidor bootstrap , basta con ejecutar (puedes utilizar otro fichero de configuraci\u00f3n): ./build/bootstrap_server -f bootstrap_server.ini El servidor quedar\u00e1 a la espera de peticiones por parte del cualquier cliente en el puerto 5685, tal y como indica su salida. Se puede forzar un proceso de bootstrapping con el comando boot , pero en este punto no es necesario. A continuaci\u00f3n, lanzaremos un cliente indicando que deseamos un proceso de bootstrapping contra el servidor local. Aseg\u00farate de dar un nombre a tu dispositivo que te permita diferenciarlo de cualquier otro : Nota importante Antes de realizar este ejercicio, debes modificar una l\u00ednea del fichero lwm2mclient.c , reemplazando la l\u00ednea que contiene data.addressFamily = AF_INET6; por data.addressFamily = AF_INET; . ./lwm2mclient -h localhost -p 5685 -b -c -n midispositivo Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > New Battery Level: 38 value changed! Opening connection to server at localhost:5685 -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING Observa que las opciones de invocaci\u00f3n han cambiado, y hemos usado -b para indicar que deseamos un proceso de bootstrapping contra el servidor proporcionado. Como nota adicional, la opci\u00f3n -c simplemente actualiza de forma peri\u00f3dica la lectura del nivel de bater\u00eda (esto no es en absoluto obligatorio, pero as\u00ed podremos observar sus cambios desde el servidor). Si todo ha ido bien, el cliente estar\u00e1 ahora registrado en dos servidores: el local Wakaama (observa su salida) y el remoto Leshan, al que puedes acceder a trav\u00e9s de la direcci\u00f3n leshan.eclipseprojects.io . Eclipse Leshan. Despliegue de un servidor local En este punto, tu cliente deber\u00eda estar conectado tanto a tu servidor LWM2M Wakaama local, como a un servidor Leshan en la nube. Aprovecha esta situaci\u00f3n para observar las funcionalides del servidor Leshan. Deber\u00edas, para un dispositivo con nombre \"foo\" observar algo como esto: Observa que todos y cada uno de los objetos de los que hablamos anteriormente se muestran ahora en pantalla tras el proceso de registro. Adem\u00e1s, para aquellos que son bien conocidos (estandarizados por la OMA), se muestran nombres legibles, no s\u00f3lo URIs. Tarea Busca y observa el recurso que te indica el nivel de bater\u00eda del cliente, y observa c\u00f3mo se actualiza autom\u00e1ticamente cuando var\u00eda en el cliente (ver\u00e1s a la vez un cambio en el servidor y un mensaje en el cliente). Interact\u00faa con el objeto de test que se defini\u00f3 anteriormente. En todos los casos, observa que, efectivamente, el tr\u00e1fico generado corresponde al esperado. Para replicar dicha instalaci\u00f3n en tu m\u00e1quina local, rescata la instalaci\u00f3n de Leshan que realizaste en la primera parte de la pr\u00e1ctica, y arranca el servidor LWM2M usando la siguiente orden: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar Tarea entregable Arranca el servidor Leshan para que escuche en un puerto diferente al que est\u00e1 escuchando ya el servidor Wakaama, para que puedan convivir en la misma m\u00e1quina. Modifica tu proceso de provisionamiento para que el cliente o clientes se conecten a ambos servidores. Tarea entregable El principal objetivo de esta parte es que seas capaz de definir un objeto e instanciarlo, con una cantidad de recursos suficientemente rica como para observar y ejercitar las capacidades de LWM2M en general, y de Eclipse Wakaama en particular. Por ello, se pide que definas, en primer lugar, uno o m\u00faltiples objetos y sus recursos que podr\u00edan formar parte de un hipot\u00e9tico sensor IoT. En segundo lugar, se pide que, siguiendo las directivas del c\u00f3digo analizado, lo implementes en Eclipse Wakaama y seas capaz de interactuar con \u00e9l desde un servidor Leshan y/o Wakaama utilizando adem\u00e1s un proceso de provisionamiento o bootstrapping .","title":"Pr\u00e1ctica 8. El protocolo LWM2M"},{"location":"Subjects/NP2/P8/#practica-8-el-protocolo-lwm2m","text":"","title":"Pr\u00e1ctica 8. El protocolo LWM2M"},{"location":"Subjects/NP2/P8/#objetivos","text":"Familiarizarse con el protocolo LWM2M, tanto en la interacci\u00f3n con servidores como en la generaci\u00f3n y definici\u00f3n de objetos y recursos. Familiarizarse con el protocolo de bootstrapping LWM2M y entender su importancia en entornos reales. Conocer dos herramientas para el desarrollo de sistemas basados en LWM2M: Wakaama y Leshan. Experimentar con el proceso de definici\u00f3n de objetos en Wakaama. Observar y poner en marcha un proceso de provisionamiento ( bootstrapping ) usando Wakaama. Desplegar servidores locales LWM2M usando tanto Wakaama como Leshan.","title":"Objetivos"},{"location":"Subjects/NP2/P8/#el-protocolo-lwm2m","text":"OMA Lightweight M2M (LWM2M) es un protocolo impulsado por la Open Mobile Alliance para la comunicaci\u00f3n M2M entre dispositivos y su gesti\u00f3n en entornos IoT. LWM2M est\u00e1 construido sobre el protocolo CoAP, y soporta, a nivel de transporte, el protocolo UDP (tambi\u00e9n presenta soporte para SMS). Entre las funcionalidades b\u00e1sicas de LWM2M destacan la existencia de servidores LWM2M, bootstrapping , control de acceso, gesti\u00f3n de dispositivos, actualizaciones de firmware , localizaci\u00f3n o estad\u00edsticas de conectividad. Adem\u00e1s, soporta seguridad a trav\u00e9s de DTLS. Concretamente, la primera especificaci\u00f3n de LWM2M (versi\u00f3n 1.0) introdujo las siguientes caracter\u00edsticas b\u00e1sicas: Definici\u00f3n de un modelo simple para la definici\u00f3n de recursos, basado en objetos. Definici\u00f3n de operaciones de creaci\u00f3n, consulta, modificaci\u00f3n, borrado y configuraci\u00f3n de recursos. Observaci\u00f3n/notificaci\u00f3n sobre recursos. Soporte para formato de datos JSON, texto plano y TLV. Colas de mensajes para soportar modos de bajo consumo en dispositivos. Soporte para m\u00faltiples servidores LWM2M. Objetos b\u00e1sicos LWM2M: Seguridad, Servidor, Control de Acceso, Dispositivo, Conectividad, Actualizaci\u00f3n de Firmware, Localizaci\u00f3n, Estad\u00edsticas de Conectividad. Para m\u00e1s informaci\u00f3n sobre los objetos predefinidos, consulta el siguiente enlace . Versiones subsiguientes del protocolo (1.1 y 1.2) introdujeron caracter\u00edsticas adicionales, como por ejemplo: Mejora del proceso de bootstrapping . Mejora del soporte para PKI. Soporte para TCP/TLS. Soporte para CBOR. Soporte para MQTT y HTTP como protocolos subyacentes.","title":"El protocolo LWM2M"},{"location":"Subjects/NP2/P8/#implementaciones-lwm2m","text":"En la presente pr\u00e1ctica, utilizaremos dos paquetes de software pertenecientes al proyecto Eclipse IoT, ambos con soporte completo para LWM2M. Cada uno de ellos presenta ventajas e inconvenientes que es necesario conocer.","title":"Implementaciones LWM2M"},{"location":"Subjects/NP2/P8/#eclipse-wakaama","text":"Eclipse Wakaama es un conjunto de ficheros fuente escritos en C que permiten ser integrados en cualquier proyecto para proporcionar funcionalidad de cliente , servidor y servidor de bootstrap LWM2M hasta su versi\u00f3n 1.1. En el lado cliente, Wakaama permite la definici\u00f3n de objetos conforme al est\u00e1ndar, as\u00ed como la recepci\u00f3n de comandos desde servidores y su enrutado hacia el objeto u objetos correspondientes. Desde el punto de vista servidor, Wakaama proporciona APIs para enviar comandos a clientes LWM2M registrados. Todo el proyecto es compatible con POSIX, y en esta pr\u00e1ctica experimentaremos con su funcionalidad trabajando desde Linux (modo cliente, servidor y servidor de bootstrap ) y desde el ESP32 (modo cliente).","title":"Eclipse Wakaama"},{"location":"Subjects/NP2/P8/#instalacion","text":"Utilizaremos una versi\u00f3n espec\u00edfica que permitir\u00e1 ser ejecutada tanto en Linux como en el ESP32. Para ello, clonamos en primer lugar la versi\u00f3n correspondiente del proyecto (es importante que utilices este commit espec\u00edfico): git clone https://github.com/eclipse/wakaama.git cd wakaama git reset --hard 31d64c0c41fae9653c1fa53ef58d1a44e49017fa El proyecto Wakaama proporciona cuatro componentes que utilizaremos durante la pr\u00e1ctica, todos dentro del directorio examples : bootstrap_server : implementa un servidor de bootstrap con l\u00ednea de comandos propia. client : implementa un cliente complejo, con definici\u00f3n de nueve objetos que siguen las especificaciones de la OMA m\u00e1s uno propio, y soporte para bootstrapping . lightclient : implementa un cliente sencillo, con definici\u00f3n de tres objetos seg\u00fan especificaciones OMA y un cuarto objeto propio. server : implementa un servidor LWM2M que ofrece l\u00ednea de comandos para la interacci\u00f3n con clientes registrados. El modo de compilar cada uno de los ejemplos es exactamente el mismo: Dir\u00edgete al directorio del ejemplo. Crea un directorio build y accede a \u00e9l. Configura el proyecto con la orden cmake .. . Compila el ejemplo con la orden make . Si todo ha ido bien, deber\u00edas tener un binario distinto en el directorio build correspondiente, con los que trabajar\u00e1s el resto de la pr\u00e1ctica. Tarea Compila cada uno de los ejemplos anteriormente mencionados en tu m\u00e1quina virtual, utilizando los par\u00e1metros por defecto para cada uno de ellos.","title":"Instalaci\u00f3n"},{"location":"Subjects/NP2/P8/#eclipse-leshan","text":"Eclipse Leshan es un proyecto alternativo que proporciona implementaciones en Java de clientes, servidores y servidores de bootstrap LWM2M, y est\u00e1 especialmente dise\u00f1ado para ser adaptable y extensible, permitiendo a los desarrolladores implementar sus propias versiones de cada uno de los tres anteriores elmentos adaptados a sus necesidades espec\u00edficas. Al igual que Wakaama, Leshan proporciona la definici\u00f3n e interacci\u00f3n con objetos IPSO, construcci\u00f3n sobre DTLS y utilizaci\u00f3n de CoAP como protocolo subyacente. Adem\u00e1s, el proyecto proporciona dos servidores de test que resultan muy \u00fatiles a la hora de desarrollar, v\u00e9ase: Servidor LWM2M en leshan.eclipseprojects.io , disponible en coap://leshan.eclipseprojects.io:5683 y coaps://leshan.eclipseprojects.io:5684 . Servidor de bootstrap en leshan.eclipseprojects.io/bs , disponible en coap://leshan.eclipseprojects.io:5783 y coaps://leshan.eclipseprojects.io:5784 .","title":"Eclipse Leshan"},{"location":"Subjects/NP2/P8/#instalacion_1","text":"Instala en primer lugar los prerequisitos necesarios para la correcta instalaci\u00f3n de Leshan (pueden variar en funci\u00f3n de tu distribuci\u00f3n Linux): sudo apt-get update sudo apt-get install openjdk-14-jdk maven git-core Clona el repositorio oficial de Leshan desde la siguiente direcci\u00f3n: git clone https://github.com/eclipse/leshan.git Por \u00faltimo, compila el proyecto: cd leshan mvn clean install Tras la fase de instalaci\u00f3n, podr\u00e1s lanzar tanto el servidor LWM2M: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. Como el servidor de bootstrapping : java -jar leshan-bsserver-demo/target/leshan-bsserver-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. En ambos casos, la salida asociada a la ejecuci\u00f3n de los servidores nos indicar\u00e1n la URL que podremos consultar desde cualquier navegador para obtener informaci\u00f3n del mismo, as\u00ed como la URL y puerto de escucha de cada uno, que deberemos indicar en los clientes correspondientes. Tarea Instala Eclipse Leshan y arranca el servidor LWM2M. Accede a la p\u00e1gina web de gesti\u00f3n y comprueba que efectivamente funciona. A continucaci\u00f3n, detenlo y haz lo propio con el servidor de bootstrapping .","title":"Instalaci\u00f3n"},{"location":"Subjects/NP2/P8/#eclipse-wakaama-cliente-y-servidor-lwm2m","text":"El objetivo principal de esta parte de la pr\u00e1ctica ser\u00e1 disponer de un sistema completo LWM2M basado en un cliente y dos servidores (uno LWM2M, otro de bootstrapping ), todos funcionando bajo Eclipse Wakaama. Para ello, en primer lugar, arrancaremos el servidor Wakaama en una de las terminales. Observa que el servidor, tras arrancar, expone una sencilla l\u00ednea de comandos que podemos aprovechar para interactuar con \u00e9l: ./lwm2mserver > help help Type 'help [COMMAND]' for more details on a command. list List registered clients. read Read from a client. disc Discover resources of a client. write Write to a client. time Write time-related attributes to a client. attr Write value-related attributes to a client. clear Clear attributes of a client. exec Execute a client resource. del Delete a client Object instance. create Create an Object instance. observe Observe from a client. cancel Cancel an observe. q Quit the server. La orden help muestra la ayuda global, pudi\u00e9ndose especializar para cada comando concreto: > help read read CLIENT# URI CLIENT#: client number as returned by command 'list' URI: uri to read such as /3, /3/0/2, /1024/11, /1024/0/1 Result will be displayed asynchronously. Si en este instante listamos un los clientes registrados, veremos que no hay ninguno: > list No client. En segundo lugar, vamos a arrancar el cliente Wakaama. Por defecto, este cliente intentar\u00e1 conectar con un servidor LWM2M existente en localhost , puerto 5683. En cualquier caso, estos valores pueden modificarse en la propia invocaci\u00f3n (consulta la opci\u00f3n -h para m\u00e1s informaci\u00f3n sobre par\u00e1metros disponibles): ./lwm2mclient Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > Opening connection to server at ::1:5683 -> State: STATE_REGISTERING 13 bytes received from [::1]:5683 64 41 69 06 06 69 E8 86 82 72 64 01 30 dAi..i...rd.0 -> State: STATE_READY > help help Type 'help [COMMAND]' for more details on a command. list List known servers. change Change the value of resource. update Trigger a registration update bootstrap Initiate a DI bootstrap process dispb Display current backup of objects/instances/resources (only security and server objects are backupped) ls List Objects and Instances disp Display current objects/instances/resources dump Dump an Object add Add support of object 31024 rm Remove support of object 31024 quit Quit the client gracefully. ^C Quit the client abruptly (without sending a de-register message). > -> State: STATE_READY Al igual que el servidor, el cliente soporta la introducci\u00f3n de comandos por parte del usuario. Observa que hemos ejecutado el comando help para mostrar los comandos disponibles. Adem\u00e1s, el cliente ha pasado desde un estado STATE_REGISTERING a un estado STATE_READY , lo que significa que se ha registrado correctamente en el servidor con el nombre testlwm2mclient . Observa ahora la salida del servidor, y ver\u00e1s que \u00e9ste ha realizado un proceso de descubrimiento de recursos en el cliente conectado. Concretamente, el servidor reporta la informaci\u00f3n relativa al nuevo cliente conectado: New client #0 registered. Client #0: name: \"testlwm2mclient\" version: \"1.1\" binding: \"UDP\" lifetime: 300 sec objects: /1/0, /2/0, /3/0, /4/0, /5/0, /6/0, /7/0, /31024/10, /31024/11, /31024/12, Concretamente, el n\u00famero asociado al cliente es el 0 . Podemos recuperar esta informaci\u00f3n en todo momento con el comando list en el servidor. En el cliente, puedes seleccionar el nombre que se utilizar\u00e1 en el proceso de registro con la opci\u00f3n -n . Tarea entregable Observa, utilizando Wireshark, el proceso de registro de un cliente en un servidor, y analiza el contenido del mensaje o mensajes intercambiados entre ambos. \u00bfQu\u00e9 protocolos se utilizan? El cliente con el que estamos trabajando es suficientemente complejo en su funcionamiento, y permite observar c\u00f3mo se implementa el soporte tanto para objetos predefinidos por la OMA como para objetos propios. Concretamente, el cliente implementa nueve objetos distintos: Security Object ( id=0 ). Server Object ( id=1 ). Access Control Object ( id=2 ), como un simple esqueleto, sin funcionalidad asociada. Device Object ( id=3 ), que contiene (y devuelve) valores espec\u00edficos codificados en base al ap\u00e9ndice E de la especificaci\u00f3n t\u00e9cnica de LWM2M. Connectivity Monitoring Object ( id=4 ), como un simple esqueleto, sin funcionalidad. Firmware Update Object ( id=5 ), como un simple esqueleto, sin funcionalidad. Location Object ( id=6 ), como un simple esqueleto, sin funcionalidad. Connectivity Statistics Object ( id=7 ), como un simple esqueleto, sin funcionalidad. Test Object ( id=31024 ), con la siguiente descripci\u00f3n: Objetos: Objeto ID Multiples Instancias Obligatorio Test 31024 S\u00ed No Recurso: Nombre ID Operaciones M\u00faltiples Instancias Obligatorio Tipo Rango test 1 R/W No Yes Integer 0-255 exec 2 E No Yes dec 3 R/W No Yes Float En el cliente, el comando dump nos permitir\u00e1 observar el contenido de una instancia determinada de un objeto, o de todas ellas. En el servidor, el comando read nos permitir\u00e1 hacer lo propio. Tarea entregable Analiza el valor actual de los objetos /3 y el objeto de test, tanto desde el cliente (comando dump ) como desde el servidor (comando read ). En \u00faltimo caso, realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos. Para escribir en un determinado recurso desde el servidor, podemos hacer uso del comando write de la siguiente forma: write 0 /31024/10/1 91 As\u00ed, estar\u00edamos escribiendo en el recurso 1 de la instancia 10 del objeto 31024 el valor entero 91. Tarea entregable Realiza escrituras en objetos del cliente y analiza el nuevo valor, comprobando que efectivamente se han llevado a cabo. Realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos en el caso de una escritura. Observa tambi\u00e9n que el servidor permite la observaci\u00f3n de recursos espec\u00edficos (comando observe ). Experimenta con esta opci\u00f3n y observa el tr\u00e1fico generado (puedes modificar el valor de un recurso desde el propio cliente y ver qu\u00e9 ocurre en el servidor). Por \u00faltimo, con la orden quit desconectamos del servidor. Observa tambi\u00e9n los mensajes CoAP que se generan en este caso.","title":"Eclipse Wakaama. Cliente y servidor LWM2M"},{"location":"Subjects/NP2/P8/#definicion-de-un-objeto-en-eclipse-wakaama","text":"Como has podido observar, el ejemplo de cliente define una serie de objetos, algunos especificados por la OMA, y otros personalizados. En este \u00faltimo caso, al que nos referiremos como test_object , se utilizan e ilustran algunas de las funcionalidades b\u00e1sicas de Wakaama como infraestructura para el desarrollo de Smart Objects v\u00eda LWM2M. Observa tanto el c\u00f3digo del cliente LWM2M (fichero fuente lwm2mclient.c del ejemplo client ) como la definici\u00f3n del objeto de test (fichero fuente test_object.c ). El primer fichero implementa la l\u00f3gica principal del cliente, incluyendo gesti\u00f3n de la conexi\u00f3n, l\u00f3gica de an\u00e1lisis de comandos introducidos por el usuario, gesti\u00f3n de bootstrapping , etc. Concretamente, nos interesa analizar las l\u00edneas relativas a la invocaci\u00f3n de la funci\u00f3n get_test_object , en cuyo interior se definen tanto los recursos como el comportamiento de nuestro cliente ante distintos tipos de operaciones sobre ellos. Observa que, al igual que para nuestro objeto de test, existen funciones similares para el resto de objetos definidos (obviamente podr\u00edan existir m\u00e1s), con un fichero fuente donde se define el comportamiento de cada uno de ellos. Uno de estos objetos es test_object.c . La principal funci\u00f3n de entrada a este m\u00f3dulo es precisamente get_test_object() . Observa que, en ella, se define el identificador del objeto, as\u00ed como cada uno de los recursos que expone (en este caso, tres), sus valores iniciales, y las funciones que se utilizar\u00e1n como callbacks asociados a cada posible operaci\u00f3n: lwm2m_object_t * testObj; testObj = (lwm2m_object_t *)lwm2m_malloc(sizeof(lwm2m_object_t)); if (NULL != testObj) { int i; prv_instance_t * targetP; memset(testObj, 0, sizeof(lwm2m_object_t)); testObj->objID = TEST_OBJECT_ID; for (i=0 ; i < 3 ; i++) { targetP = (prv_instance_t *)lwm2m_malloc(sizeof(prv_instance_t)); if (NULL == targetP) return NULL; memset(targetP, 0, sizeof(prv_instance_t)); targetP->shortID = 10 + i; targetP->test = 20 + i; targetP->dec = -30 + i + (double)i/100.0; testObj->instanceList = LWM2M_LIST_ADD(testObj->instanceList, targetP); } /* * From a single instance object, two more functions are available. * - The first one (createFunc) create a new instance and filled it with the provided informations. If an ID is * provided a check is done for verifying his disponibility, or a new one is generated. * - The other one (deleteFunc) delete an instance by removing it from the instance list (and freeing the memory * allocated to it) */ testObj->readFunc = prv_read; testObj->discoverFunc = prv_discover; testObj->writeFunc = prv_write; testObj->executeFunc = prv_exec; testObj->createFunc = prv_create; testObj->deleteFunc = prv_delete; } return testObj; Estas funciones de callback est\u00e1n definidas en el propio fichero, y su contenido es personalizable en funci\u00f3n del dise\u00f1o del objeto. Observemos, por ejemplo, el contenido de la funci\u00f3n asociada a la lectura, prv_read : static uint8_t prv_read(uint16_t instanceId, int * numDataP, lwm2m_data_t ** dataArrayP, lwm2m_object_t * objectP) { prv_instance_t * targetP; int i; targetP = (prv_instance_t *)lwm2m_list_find(objectP->instanceList, instanceId); if (NULL == targetP) return COAP_404_NOT_FOUND; if (*numDataP == 0) { *dataArrayP = lwm2m_data_new(2); if (*dataArrayP == NULL) return COAP_500_INTERNAL_SERVER_ERROR; *numDataP = 2; (*dataArrayP)[0].id = 1; (*dataArrayP)[1].id = 3; } for (i = 0 ; i < *numDataP ; i++) { switch ((*dataArrayP)[i].id) { case 1: lwm2m_data_encode_int(targetP->test, *dataArrayP + i); break; case 2: return COAP_405_METHOD_NOT_ALLOWED; case 3: lwm2m_data_encode_float(targetP->dec, *dataArrayP + i); break; default: return COAP_404_NOT_FOUND; } } return COAP_205_CONTENT; } Observa que en primer lugar se busca la instancia del objeto solicitada, devolvi\u00e9ndose el error correspondiente en caso de no existir (puedes comprobar esta funcionalidad solicitando desde el servidor la lectura de una instancia inexistente). El par\u00e1metro numDataP nos indica el recurso concreto que se desea leer, o todos si dicho valor es 0. Tras tomar el valor actual a servir, \u00e9ste se codifica en funci\u00f3n del tipo de datos predefinido para el recurso espec\u00edfico solicitado. En caso de no estar soportado el m\u00e9todo para un recurso espec\u00edfico, se devuelve el error correspondiente (en este caso 405 ). En caso de solicitar un recurso inexistente, se devuelve el error 404 . Tarea Comprueba que el comportamiento del objeto de test es el esperado, interactuando con \u00e9l desde el servidor utilizando todos los m\u00e9todos disponibles. Puedes modificar su comportamiento, a\u00f1adir invocaciones a rutinas de log , o lo que consideres de utilidad.","title":"Definici\u00f3n de un objeto en Eclipse Wakaama"},{"location":"Subjects/NP2/P8/#eclipse-wakaama-bootstrapping","text":"En este punto, el cliente Wakaama se conecta directamente con el servidor que hemos lanzado, y cuya direcci\u00f3n IP y puerto son los proporcionados por defecto en el c\u00f3digo. Llevado el cliente a un sensor, esto har\u00eda que nunca pudiese variar, durante el ciclo de vida del mismo, el servidor (o servidores) a los que conecta. Esto hace tambi\u00e9n que un cliente pueda \u00fanicamente conectar con un servidor LWM2M, cuando en algunas ocasiones es deseable replicar los mensajes enviados a m\u00faltiples servidores, bien por razones de tolerancia a fallos, o bien por necesidades de la aplicaci\u00f3n. Para solucionar este problema, los firmwares de f\u00e1brica suelen conocer \u00fanicamente la direcci\u00f3n o direcciones fijas de uno o varios servidores de bootstrap que, ante peticiones de provisionamiento, proporcionan al cliente las credenciales de seguridad y las direcciones de los servidores LWM2M en los que deben registrarse. As\u00ed, resulta sencillo manejar din\u00e1micamente ambos aspectos sin necesitar reflashear el firmware del sensor. En nuestro caso, utilizaremos un sencillo servidor de bootstrap proporcionado por Wakaama, aunque Leshan ofrece mecanismos mucho m\u00e1s sofisticados para realizar este mismo proceso, con su propio esqueleto de servidor bootstrap e interfaces REST (con monitores web) para gestionar el proceso. En primer lugar, dir\u00edgete al directorio que contiene el servidor bootstrap de Wakaama. All\u00ed encontrar\u00e1s un fichero de configuraci\u00f3n ( bootstrap_server.ini ) para el proceso de bootstrapping , cuyo contenido es completamente estructurado. El servidor, ante una petici\u00f3n de bootstrapping por parte de un cliente, responde en funci\u00f3n del contenido del fichero, que sigue las siguientes directivas: Las secciones soportadas son [Server] y [Endpoint] . [Server] describe una cuenta en un servidor LWM2M: Las claves soportadas en esta secci\u00f3n son: id: Identificador del servidor. (OBLIGATORIO). uri: URI del servidor LWM2M (OBLIGATORIO). bootstrap: YES o NO. Determina si este servidor es un servidor de bootstrap. Su valor por defecto es NO. lifetime: tiempo de vida del registro (opcional). security: modo de seguridad. Valores soportados: NoSec, PSK, RPK and Certificate (OBLIGATORIO). public: clave p\u00fablica o identidad del cliente, definida por el recurso /0/x/3 . server: clave p\u00fablica del servidor, definida por el recurso /0/x/4 . secret: clave privada definida por el recurso /0/x/5 . [Endpoint] contiene las operaciones de bootstrapping Si no se especifica un nombre (Name) las operaciones se enviar\u00e1n a cualquier cliente desconocido que solicite bootstrapping Si se especifica, las operaciones se enviar\u00e1n s\u00f3lo al cliente con el correspondiente nombre. Las operaciones se env\u00edan en el orden definido en el fichero. Las claves soportadas en esta secci\u00f3n son: - Name: Nombre del cliente (OPCIONAL). - Delete: Debe ser una URI LWM2M v\u00e1lida, incluida / . Env\u00eda una operaci\u00f3n delete en la URI indicada. - Server: [Value] es un ID de servidor que debe existir en la secci\u00f3n correspondiente. Env\u00eda operaciones de escritura sobre el objeto correspondiente del cliente para definir el servidor sobre el que debe conectar. Tarea Analiza e intenta entender el contenido por defecto del fichero de bootstrapping proporcionado. Puedes de momento obviar los par\u00e1metros referentes a seguridad, ya que los trataremos en la pr\u00f3xima pr\u00e1ctica. Tarea entregable Modifica el fichero de configuraci\u00f3n para que, ante la petici\u00f3n de un cliente con nombre determinado, conecte, por este orden, a un servidor LWM2M en la m\u00e1quina local, y al servidor de pruebas de Leshan en Internet. Adem\u00e1s, elimina cualquier intento de borrado de recursos en la informaci\u00f3n de bootstrapping para dicho cliente. Para arrancar el servidor bootstrap , basta con ejecutar (puedes utilizar otro fichero de configuraci\u00f3n): ./build/bootstrap_server -f bootstrap_server.ini El servidor quedar\u00e1 a la espera de peticiones por parte del cualquier cliente en el puerto 5685, tal y como indica su salida. Se puede forzar un proceso de bootstrapping con el comando boot , pero en este punto no es necesario. A continuaci\u00f3n, lanzaremos un cliente indicando que deseamos un proceso de bootstrapping contra el servidor local. Aseg\u00farate de dar un nombre a tu dispositivo que te permita diferenciarlo de cualquier otro : Nota importante Antes de realizar este ejercicio, debes modificar una l\u00ednea del fichero lwm2mclient.c , reemplazando la l\u00ednea que contiene data.addressFamily = AF_INET6; por data.addressFamily = AF_INET; . ./lwm2mclient -h localhost -p 5685 -b -c -n midispositivo Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > New Battery Level: 38 value changed! Opening connection to server at localhost:5685 -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING Observa que las opciones de invocaci\u00f3n han cambiado, y hemos usado -b para indicar que deseamos un proceso de bootstrapping contra el servidor proporcionado. Como nota adicional, la opci\u00f3n -c simplemente actualiza de forma peri\u00f3dica la lectura del nivel de bater\u00eda (esto no es en absoluto obligatorio, pero as\u00ed podremos observar sus cambios desde el servidor). Si todo ha ido bien, el cliente estar\u00e1 ahora registrado en dos servidores: el local Wakaama (observa su salida) y el remoto Leshan, al que puedes acceder a trav\u00e9s de la direcci\u00f3n leshan.eclipseprojects.io .","title":"Eclipse Wakaama. Bootstrapping"},{"location":"Subjects/NP2/P8/#eclipse-leshan-despliegue-de-un-servidor-local","text":"En este punto, tu cliente deber\u00eda estar conectado tanto a tu servidor LWM2M Wakaama local, como a un servidor Leshan en la nube. Aprovecha esta situaci\u00f3n para observar las funcionalides del servidor Leshan. Deber\u00edas, para un dispositivo con nombre \"foo\" observar algo como esto: Observa que todos y cada uno de los objetos de los que hablamos anteriormente se muestran ahora en pantalla tras el proceso de registro. Adem\u00e1s, para aquellos que son bien conocidos (estandarizados por la OMA), se muestran nombres legibles, no s\u00f3lo URIs. Tarea Busca y observa el recurso que te indica el nivel de bater\u00eda del cliente, y observa c\u00f3mo se actualiza autom\u00e1ticamente cuando var\u00eda en el cliente (ver\u00e1s a la vez un cambio en el servidor y un mensaje en el cliente). Interact\u00faa con el objeto de test que se defini\u00f3 anteriormente. En todos los casos, observa que, efectivamente, el tr\u00e1fico generado corresponde al esperado. Para replicar dicha instalaci\u00f3n en tu m\u00e1quina local, rescata la instalaci\u00f3n de Leshan que realizaste en la primera parte de la pr\u00e1ctica, y arranca el servidor LWM2M usando la siguiente orden: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar Tarea entregable Arranca el servidor Leshan para que escuche en un puerto diferente al que est\u00e1 escuchando ya el servidor Wakaama, para que puedan convivir en la misma m\u00e1quina. Modifica tu proceso de provisionamiento para que el cliente o clientes se conecten a ambos servidores. Tarea entregable El principal objetivo de esta parte es que seas capaz de definir un objeto e instanciarlo, con una cantidad de recursos suficientemente rica como para observar y ejercitar las capacidades de LWM2M en general, y de Eclipse Wakaama en particular. Por ello, se pide que definas, en primer lugar, uno o m\u00faltiples objetos y sus recursos que podr\u00edan formar parte de un hipot\u00e9tico sensor IoT. En segundo lugar, se pide que, siguiendo las directivas del c\u00f3digo analizado, lo implementes en Eclipse Wakaama y seas capaz de interactuar con \u00e9l desde un servidor Leshan y/o Wakaama utilizando adem\u00e1s un proceso de provisionamiento o bootstrapping .","title":"Eclipse Leshan. Despliegue de un servidor local"},{"location":"Subjects/NP2/P9/","text":"Pr\u00e1ctica 9. Node-RED Introducci\u00f3n y objetivos Node-RED es una herramienta de c\u00f3digo abierto desarrollada inicialmente por IBM y que, estando orientada a flujos de datos, proporciona mecanismos para asociar dispositivos hardware, APIs y servicios online dentro de un ecosistema IoT. Node-RED es una herramienta gr\u00e1fica, utilizable desde cualquier navegador web, que permite la craci\u00f3n y edici\u00f3n de flujos de datos que tomen datos de entrada (mediante nodos de entrada), los procesen (mediante nodos de procesamiento) y proporcionen salidas (mediante nodos de salida). Todos los elementos, incluyendo flujos complejos definidos por el usuario, pueden almacenarse en formato JSON para ser importados a continuaci\u00f3n en otras instalaciones. Node-RED permite la interconexi\u00f3n de elementos software y hardware mediante virtualmente cualquier protocolo conocido, facilitando el despliegue de infraestructuras IoT. El desarrollo de la pr\u00e1ctica difiere sobre el utilizado en pr\u00e1cticas anteriores. En este caso, el presente bolet\u00edn \u00fanicamente incluye informaci\u00f3n e instrucciones para la instalaci\u00f3n de la herramienta Node-RED en la m\u00e1quina virtual del curso (alternativamente, es posible instalar Node-RED en cualquier m\u00e1quina f\u00edsica), as\u00ed como la propuesta de ejercicio entregable a dise\u00f1ar e implementar. Se proporcionar\u00e1n las explicaciones y demostraciones necesarias durante la sesi\u00f3n de laboratorio para entender los conceptos b\u00e1sicos relativos a la instalaci\u00f3n y uso b\u00e1sico de la herramienta Node-RED. Instalaci\u00f3n y puesta en marcha Para instalar Node-RED en la m\u00e1quina virtual del curso, es suficiente con utilizar el gestor npm : sudo npm install -g --unsafe-perm node-red Al finalzar, si todo ha ido bien, deber\u00edas observar una salida similar a la siguiente: + node-red@1.1.0 added 332 packages from 341 contributors in 18.494s found 0 vulnerabilities Para ejecutar Node-RED, una vez instalado, es posible utilizar la orden node-red desde cualquier terminal. Para detener el proceso, es suficiente con utilizar Ctrl-C : $ node-red Welcome to Node-RED =================== 30 Jun 23:43:39 - [info] Node-RED version: v1.1.0 30 Jun 23:43:39 - [info] Node.js version: v10.21.0 30 Jun 23:43:39 - [info] Darwin 18.7.0 x64 LE 30 Jun 23:43:39 - [info] Loading palette nodes 30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive 30 Jun 23:43:44 - [info] Settings file : /Users/nol/.node-red/settings.js 30 Jun 23:43:44 - [info] HTTP Static : /Users/nol/node-red/web 30 Jun 23:43:44 - [info] Context store : 'default' [module=localfilesystem] 30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red 30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable 30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json 30 Jun 23:43:44 - [info] Starting flows 30 Jun 23:43:44 - [info] Started flows 30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/ Con el software arrancado, es posible acceder al editor Node-RED a trav\u00e9s de la direcci\u00f3n http://localhost:1880 en cualquier navegador. Tras arrancarlo, observar\u00e1s cuatro \u00e1reas en el editor: Barra principal , en la parte superior, con los botones Deploy y de Men\u00fa principal . Panel de nodos , en la parte izquierda, que proporciona acceso directo a todos los nodos disponibles en Node-RED. Es posible instalar nuevos nodos a trav\u00e9s de la Paleta de Nodos, disponible a trav\u00e9s del men\u00fa principal ( Manage Palette ). Estos nodos pueden ser arrastrados al editor para conformar nuevos flujos de datos. Panel de edici\u00f3n o espacio de trabajo , en la parte central de la pantalla, donde podr\u00e1s arrastrar y unir nuevos nodos. Es posible crear nuevos flujos en pesta\u00f1as independientes. Panel de informaci\u00f3n , en la parte derecha de la pantalla, donde destaca el bot\u00f3n Debug , mediante el cual veremos la salida de los nodos de tipo Debug en nuestros flujos. Ejemplo 1 Se muestra a continuaci\u00f3n un breve ejemplo b\u00e1sico de utilizaci\u00f3n del editor Node-RED, que incluye el uso de nodos Inject , Debug y Function . Nodo Inject El nodo Inject permite inyectar mensajes en un flujo, bien pulsando en el bot\u00f3n asociado al nodo, o estableciendo un intervalo de tiempo entre inyecciones. Busca en el panel izquierdo un nodo de tipo Inject y arr\u00e1stralo al espacio de trabajo. En el panel de informaci\u00f3n podr\u00e1s consultar los datos asociados al nodo, as\u00ed como informaci\u00f3n de ayuda para utilizarlo. Nodo Debug El nodo Debug permite que cualquier mensaje entrante se muestre en el panel de depuraci\u00f3n, en la parte derecha de la pantalla. Por defecto, \u00fanicamente muestra el payload del mensaje, aunque puede configurarse para mostrar el objeto completo. Arrastra un nodo de tipo Debug al espacio de trabajo. Uni\u00f3n y despliegue ( Deploy ) Conecta los nodos Inject y Debug estableciendo un enlace ( Wire ) entre ambos. Despliega el flujo usando el bot\u00f3n Deploy en la barra principal de Node-RED. Esto desplegar\u00e1 el fujo en el servidor. Selecciona la opci\u00f3n Debug en el panel de informaci\u00f3n, y presiona el bot\u00f3n del nodo Inject . Deber\u00edas ver n\u00fameros aparecer en el panel. Por defecto, el nodo Inject emite el n\u00famero de milisegundos desde el 1 de enero de 1970 como payload . Modifica (temporalmente) el nodo Debug para que muestre todo el mensaje en lugar del payload . Despliega de nuevo el flujo y observa las diferencias. Vuelve a configurar el nodo Debug tal y como estaba cuando lo insertaste. Nodo Function El nodo Function permite procesar el mensaje de entrada mediante una funci\u00f3n JavaScript. Borra el Wire existente y a\u00f1ade un nodo Function entre los nodos Inject y Debug . Haz doble clic en el nuevo nodo para abrir el di\u00e1logo de edici\u00f3n. Copia el siguiente c\u00f3digo en el campo Function : // Create a Date object from the payload var date = new Date(msg.payload); // Change the payload to be a formatted Date string msg.payload = date.toString(); // Return the message so it can be sent on return msg; Clica en Done y despliega el flujo. Observa que, ahora, los mensajes de depuraci\u00f3n muestran marcas de tiempo en formato visible. Ten en cuenta que un nodo siempre recibe un mensaje ( msg ) de entrada y devuelve un mensaje ( msg ) de salida. Ambos objetos contienen, por convenio, un campo payload . Para m\u00e1s informaci\u00f3n sobre el uso de funciones y trabajo con mensajes, incluyendo m\u00faltiples valores de retorno y trabajo con valores globales a todo el entorno, se recomienda estudiar la siguiente documentaci\u00f3n: Trabajo con mensajes : enlace a documentaci\u00f3n . Trabajo con funciones : enlace a documentaci\u00f3n . Ejemplo 2 Nodo Inject En el anterior ejemplo, vimos c\u00f3mo crear un nodo Inject para activar el flujo cuando se pulsaba su bot\u00f3n asociado. En este ejemplo, vamos a configurar el nodo Inject para que active el flujo en intervalos regulares. Arrastra un nuevo nodo Inject en el espacio de trabajo. Clica en \u00e9l dos veces y, en el di\u00e1logo de edici\u00f3n, usala opci\u00f3n Repeat interval , fij\u00e1ndolo en un intervalo regular. Cierra el di\u00e1logo de edici\u00f3n. Nodo HTTP Request El nodo de tipo HTTP Request puede utilizarse para descargar una p\u00e1gina web o recurso HTTP. A\u00f1ade uno al espacio de trabajo, y ed\u00edtalo para que su propiedad URL apunte a https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv . Esta URL es un repositorio de terremotos en el \u00faltimo mes, pulicado por el organismo oficial correspondiente, devueltos en formato CSV. Nodo CSV A\u00f1ade un nuevo nodo CSV y edita sus propiedades. Activa la opci\u00f3n First row contains column names y finaliza la edici\u00f3n. Nodo Debug y cableado A\u00f1ade un nodo Debug y une los nodos creados: Conecta la salida del nodo Inject a la entrada del nodo HTTP Request . Conecta la salida del nodo HTTP Request a la entrada del nodo CSV . Conecta la salida del nodo CSV a la entrada del nodo Debug . Nodo Switch A\u00f1ade un nodo Switch al espacio de trabajo. Edita sus propiedades y configuralo para comprobar la propiedad msg.payload.mag , usando la operaci\u00f3n >= sobre un valor num\u00e9rico y el valor 6.2 , por ejemplo. A\u00f1ade un segundo Wire entre el nodo CSV y el nodo Switch . Nodo Change A\u00f1ade un nodo Change , conectado a la salida del nodo Switch . Configuralo para establecer el valor de msg.payload a ALARMA . Nodo Debug A\u00f1ade un nodo Debug y despliega el flujo. En el panel de Debug , deber\u00e1s obsevar, para cada activaci\u00f3n del nodo Inject , una salida similar a esta: msg.payload : Object {\"time\":\"2017-11-19T15:09:03.120Z\",\"latitude\":-21.5167,\"longitude\":168.5426,\"depth\":14.19,\"mag\":6.6,\"magType\":\"mww\",\"gap\":21,\"dmin\":0.478,\"rms\":0.86,\"net\":\"us\",\"id\":\"us2000brgk\",\"updated\":\"2017-11-19T17:10:58.449Z\",\"place\":\"68km E of Tadine, New Caledonia\",\"type\":\"earthquake\",\"horizontalError\":6.2,\"depthError\":2.8,\"magError\":0.037,\"magNst\":72,\"status\":\"reviewed\",\"locationSource\":\"us\",\"magSource\":\"us\"} Puedes clicar en la peque\u00f1a flecha a la izquierda de cada propiedad para expandirla y examinar sus contenidos. Si existe cualquier terremoto de magnitud mayor a 6.2 , observar\u00e1s una salida adicional: msg.payload : string(6) \"ALARMA\" Para m\u00e1s informaci\u00f3n sobre los nodos b\u00e1sicos en Node-RED, puedes consultar: The Core Nodes : enlace a documentaci\u00f3n . Cliente MQTT y despliegue de un panel de control El nodo MQTT in permite realizar suscripciones a topics determinados en brokers MQTT. Arrastra un nuevo nodo MQTT in en tu espacio de trabajo y configura el broker asociado a localhost , puerto por defecto. Establece un topic de inter\u00e9s. Conecta un nodo Debug y despliega el flujo. Desde tu consola, publica mensajes v\u00eda mosquitto_pub y comprueba que, efectivamente, son visibles en Node-RED. A continuaci\u00f3n, crearemos un peque\u00f1o panel de control para la representaci\u00f3n gr\u00e1fica del valor publicado. En primer lugar, deber\u00e1s instalar el nodo node-red-dashboard desde el men\u00fa principal, opci\u00f3n Manage palette . Tras su instalaci\u00f3n, ver\u00e1s que aparecen nuevos nodos en el panel de nodos; \u00e9stos nos permitir\u00e1n dise\u00f1ar e implementar un panel de control b\u00e1sico basado en Widgets . Arrastra un nodo de tipo Gauge al espacio de trabajo, y configura sus valores por defecto. Conecta la salida de tu nodo MQTT in a la entrada del nuevo nodo Gauge . Despliega el flujo, y navega hasta http://localhost:1880/ui , donde deber\u00e1s observar el panel de control con el widget que has creado. Interact\u00faa con \u00e9l publicando mensajes v\u00eda MQTT. Para m\u00e1s informaci\u00f3n sobre el despliegue de paneles de control, puedes consultar: Node-Red-Dashboard : enlace a documentaci\u00f3n . Documentaci\u00f3n adicional Las gu\u00edas de usuario oficiales de Node-RED son un buen punto de partida para profundizar en el uso de la infraestructura. De entre ellas, la parte m\u00e1s importante para comenzar es la que introduce los conceptos b\u00e1sicos de Node-RED, incluyendo el trabajo con nodos, flujos, contexto (importante para trabajar con valores globales y compartidos por todos los nodos en un flujo, por ejemplo), mensajes, wires , etc.: Node-RED Concepts : enlace a documentaci\u00f3n . La gu\u00eda Node-RED Guide contiene interesante documentaci\u00f3n adicional/avanzada tanto en el despliegue de flujos como en el uso de paneles de control locales o usando servicios remotos (por ejemplo, Freeboard ): Node-RED Guide : enlace a documentaci\u00f3n . Ejercicio entregable Se pide estudiar la documentaci\u00f3n asociada a Node-RED, tanto en su web oficial como en la gu\u00eda de programaci\u00f3n Node-RED Guide (espec\u00edficamente sus cuatro primeras partes. Junto con la explicaci\u00f3n proporcionada por el profesor y los anteriores ejemplos, este estudio permitir\u00e1 el desarrollo de la pr\u00e1ctica. Tarea entregable La pr\u00e1ctica consiste en el dise\u00f1o y desarrollo de un sistema basado en flujos de datos construido sobre Node-RED, que implemente un mecanismo de monitorizaci\u00f3n de par\u00e1metros ambientales (por ejemplo, temperatura) y notificaci\u00f3n (alarmas) ante ciertas circunstancias (por ejemplo, superar una determinada temperatura fijada como umbral). Los alumnos dise\u00f1ar\u00e1n el sistema y lo implementar\u00e1n, cumpliendo las siguientes premisas: (2 puntos) . El sistema utilizar\u00e1, al menos , un dispositivo externo (ESP32, SensorTag, Tel\u00e9fono M\u00f3vil, ...) para la recolecci\u00f3n de datos. Se valorar\u00e1 el uso de m\u00e1s de un dispositivo. (2 puntos) . El sistema depositar\u00e1 o interactuar\u00e1 con, al menos , un sistema externo (servidor de correo, Twitter, Telegram, IBM Bluemix, ...). (2 puntos) . El sistema depositar\u00e1 los datos observados en alg\u00fan medio persistente (Base de Datos no relacional, ficheros, ...) para permitir su posterior an\u00e1lisis y en un panel de control. (2 puntos) . El sistema actuar\u00e1 como un sistema de alarma \u00fanicamente ante ciertas condiciones de entrada (por ejemplo, al recibir un valor desde un sensor superior a un umbral establecido; dicho valor podr\u00eda, por ejemplo, configurarse v\u00eda MQTT o a trav\u00e9s de un panel de control). (2 puntos) . El sistema utilizar\u00e1, al menos, un tipo de nodo no instalado por defecto en la instalaci\u00f3n b\u00e1sica de Node-RED. Se entregar\u00e1 el fichero o ficheros JSON que describen los nodos, as\u00ed como una breve memoria que describa el sistema dise\u00f1ado y el trabajo realizado, haciendo hincapi\u00e9 en las dificultades encontradas y aquellos aspectos que se consideren de inter\u00e9s por parte del alumno/a.","title":"Pr\u00e1ctica 9. Node-RED"},{"location":"Subjects/NP2/P9/#practica-9-node-red","text":"","title":"Pr\u00e1ctica 9. Node-RED"},{"location":"Subjects/NP2/P9/#introduccion-y-objetivos","text":"Node-RED es una herramienta de c\u00f3digo abierto desarrollada inicialmente por IBM y que, estando orientada a flujos de datos, proporciona mecanismos para asociar dispositivos hardware, APIs y servicios online dentro de un ecosistema IoT. Node-RED es una herramienta gr\u00e1fica, utilizable desde cualquier navegador web, que permite la craci\u00f3n y edici\u00f3n de flujos de datos que tomen datos de entrada (mediante nodos de entrada), los procesen (mediante nodos de procesamiento) y proporcionen salidas (mediante nodos de salida). Todos los elementos, incluyendo flujos complejos definidos por el usuario, pueden almacenarse en formato JSON para ser importados a continuaci\u00f3n en otras instalaciones. Node-RED permite la interconexi\u00f3n de elementos software y hardware mediante virtualmente cualquier protocolo conocido, facilitando el despliegue de infraestructuras IoT. El desarrollo de la pr\u00e1ctica difiere sobre el utilizado en pr\u00e1cticas anteriores. En este caso, el presente bolet\u00edn \u00fanicamente incluye informaci\u00f3n e instrucciones para la instalaci\u00f3n de la herramienta Node-RED en la m\u00e1quina virtual del curso (alternativamente, es posible instalar Node-RED en cualquier m\u00e1quina f\u00edsica), as\u00ed como la propuesta de ejercicio entregable a dise\u00f1ar e implementar. Se proporcionar\u00e1n las explicaciones y demostraciones necesarias durante la sesi\u00f3n de laboratorio para entender los conceptos b\u00e1sicos relativos a la instalaci\u00f3n y uso b\u00e1sico de la herramienta Node-RED.","title":"Introducci\u00f3n y objetivos"},{"location":"Subjects/NP2/P9/#instalacion-y-puesta-en-marcha","text":"Para instalar Node-RED en la m\u00e1quina virtual del curso, es suficiente con utilizar el gestor npm : sudo npm install -g --unsafe-perm node-red Al finalzar, si todo ha ido bien, deber\u00edas observar una salida similar a la siguiente: + node-red@1.1.0 added 332 packages from 341 contributors in 18.494s found 0 vulnerabilities Para ejecutar Node-RED, una vez instalado, es posible utilizar la orden node-red desde cualquier terminal. Para detener el proceso, es suficiente con utilizar Ctrl-C : $ node-red Welcome to Node-RED =================== 30 Jun 23:43:39 - [info] Node-RED version: v1.1.0 30 Jun 23:43:39 - [info] Node.js version: v10.21.0 30 Jun 23:43:39 - [info] Darwin 18.7.0 x64 LE 30 Jun 23:43:39 - [info] Loading palette nodes 30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive 30 Jun 23:43:44 - [info] Settings file : /Users/nol/.node-red/settings.js 30 Jun 23:43:44 - [info] HTTP Static : /Users/nol/node-red/web 30 Jun 23:43:44 - [info] Context store : 'default' [module=localfilesystem] 30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red 30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable 30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json 30 Jun 23:43:44 - [info] Starting flows 30 Jun 23:43:44 - [info] Started flows 30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/ Con el software arrancado, es posible acceder al editor Node-RED a trav\u00e9s de la direcci\u00f3n http://localhost:1880 en cualquier navegador. Tras arrancarlo, observar\u00e1s cuatro \u00e1reas en el editor: Barra principal , en la parte superior, con los botones Deploy y de Men\u00fa principal . Panel de nodos , en la parte izquierda, que proporciona acceso directo a todos los nodos disponibles en Node-RED. Es posible instalar nuevos nodos a trav\u00e9s de la Paleta de Nodos, disponible a trav\u00e9s del men\u00fa principal ( Manage Palette ). Estos nodos pueden ser arrastrados al editor para conformar nuevos flujos de datos. Panel de edici\u00f3n o espacio de trabajo , en la parte central de la pantalla, donde podr\u00e1s arrastrar y unir nuevos nodos. Es posible crear nuevos flujos en pesta\u00f1as independientes. Panel de informaci\u00f3n , en la parte derecha de la pantalla, donde destaca el bot\u00f3n Debug , mediante el cual veremos la salida de los nodos de tipo Debug en nuestros flujos.","title":"Instalaci\u00f3n y puesta en marcha"},{"location":"Subjects/NP2/P9/#ejemplo-1","text":"Se muestra a continuaci\u00f3n un breve ejemplo b\u00e1sico de utilizaci\u00f3n del editor Node-RED, que incluye el uso de nodos Inject , Debug y Function .","title":"Ejemplo 1"},{"location":"Subjects/NP2/P9/#nodo-inject","text":"El nodo Inject permite inyectar mensajes en un flujo, bien pulsando en el bot\u00f3n asociado al nodo, o estableciendo un intervalo de tiempo entre inyecciones. Busca en el panel izquierdo un nodo de tipo Inject y arr\u00e1stralo al espacio de trabajo. En el panel de informaci\u00f3n podr\u00e1s consultar los datos asociados al nodo, as\u00ed como informaci\u00f3n de ayuda para utilizarlo.","title":"Nodo Inject"},{"location":"Subjects/NP2/P9/#nodo-debug","text":"El nodo Debug permite que cualquier mensaje entrante se muestre en el panel de depuraci\u00f3n, en la parte derecha de la pantalla. Por defecto, \u00fanicamente muestra el payload del mensaje, aunque puede configurarse para mostrar el objeto completo. Arrastra un nodo de tipo Debug al espacio de trabajo.","title":"Nodo Debug"},{"location":"Subjects/NP2/P9/#union-y-despliegue-deploy","text":"Conecta los nodos Inject y Debug estableciendo un enlace ( Wire ) entre ambos. Despliega el flujo usando el bot\u00f3n Deploy en la barra principal de Node-RED. Esto desplegar\u00e1 el fujo en el servidor. Selecciona la opci\u00f3n Debug en el panel de informaci\u00f3n, y presiona el bot\u00f3n del nodo Inject . Deber\u00edas ver n\u00fameros aparecer en el panel. Por defecto, el nodo Inject emite el n\u00famero de milisegundos desde el 1 de enero de 1970 como payload . Modifica (temporalmente) el nodo Debug para que muestre todo el mensaje en lugar del payload . Despliega de nuevo el flujo y observa las diferencias. Vuelve a configurar el nodo Debug tal y como estaba cuando lo insertaste.","title":"Uni\u00f3n y despliegue (Deploy)"},{"location":"Subjects/NP2/P9/#nodo-function","text":"El nodo Function permite procesar el mensaje de entrada mediante una funci\u00f3n JavaScript. Borra el Wire existente y a\u00f1ade un nodo Function entre los nodos Inject y Debug . Haz doble clic en el nuevo nodo para abrir el di\u00e1logo de edici\u00f3n. Copia el siguiente c\u00f3digo en el campo Function : // Create a Date object from the payload var date = new Date(msg.payload); // Change the payload to be a formatted Date string msg.payload = date.toString(); // Return the message so it can be sent on return msg; Clica en Done y despliega el flujo. Observa que, ahora, los mensajes de depuraci\u00f3n muestran marcas de tiempo en formato visible. Ten en cuenta que un nodo siempre recibe un mensaje ( msg ) de entrada y devuelve un mensaje ( msg ) de salida. Ambos objetos contienen, por convenio, un campo payload . Para m\u00e1s informaci\u00f3n sobre el uso de funciones y trabajo con mensajes, incluyendo m\u00faltiples valores de retorno y trabajo con valores globales a todo el entorno, se recomienda estudiar la siguiente documentaci\u00f3n: Trabajo con mensajes : enlace a documentaci\u00f3n . Trabajo con funciones : enlace a documentaci\u00f3n .","title":"Nodo Function"},{"location":"Subjects/NP2/P9/#ejemplo-2","text":"","title":"Ejemplo 2"},{"location":"Subjects/NP2/P9/#nodo-inject_1","text":"En el anterior ejemplo, vimos c\u00f3mo crear un nodo Inject para activar el flujo cuando se pulsaba su bot\u00f3n asociado. En este ejemplo, vamos a configurar el nodo Inject para que active el flujo en intervalos regulares. Arrastra un nuevo nodo Inject en el espacio de trabajo. Clica en \u00e9l dos veces y, en el di\u00e1logo de edici\u00f3n, usala opci\u00f3n Repeat interval , fij\u00e1ndolo en un intervalo regular. Cierra el di\u00e1logo de edici\u00f3n.","title":"Nodo Inject"},{"location":"Subjects/NP2/P9/#nodo-http-request","text":"El nodo de tipo HTTP Request puede utilizarse para descargar una p\u00e1gina web o recurso HTTP. A\u00f1ade uno al espacio de trabajo, y ed\u00edtalo para que su propiedad URL apunte a https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv . Esta URL es un repositorio de terremotos en el \u00faltimo mes, pulicado por el organismo oficial correspondiente, devueltos en formato CSV.","title":"Nodo HTTP Request"},{"location":"Subjects/NP2/P9/#nodo-csv","text":"A\u00f1ade un nuevo nodo CSV y edita sus propiedades. Activa la opci\u00f3n First row contains column names y finaliza la edici\u00f3n.","title":"Nodo CSV"},{"location":"Subjects/NP2/P9/#nodo-debug-y-cableado","text":"A\u00f1ade un nodo Debug y une los nodos creados: Conecta la salida del nodo Inject a la entrada del nodo HTTP Request . Conecta la salida del nodo HTTP Request a la entrada del nodo CSV . Conecta la salida del nodo CSV a la entrada del nodo Debug .","title":"Nodo Debug y cableado"},{"location":"Subjects/NP2/P9/#nodo-switch","text":"A\u00f1ade un nodo Switch al espacio de trabajo. Edita sus propiedades y configuralo para comprobar la propiedad msg.payload.mag , usando la operaci\u00f3n >= sobre un valor num\u00e9rico y el valor 6.2 , por ejemplo. A\u00f1ade un segundo Wire entre el nodo CSV y el nodo Switch .","title":"Nodo Switch"},{"location":"Subjects/NP2/P9/#nodo-change","text":"A\u00f1ade un nodo Change , conectado a la salida del nodo Switch . Configuralo para establecer el valor de msg.payload a ALARMA .","title":"Nodo Change"},{"location":"Subjects/NP2/P9/#nodo-debug_1","text":"A\u00f1ade un nodo Debug y despliega el flujo. En el panel de Debug , deber\u00e1s obsevar, para cada activaci\u00f3n del nodo Inject , una salida similar a esta: msg.payload : Object {\"time\":\"2017-11-19T15:09:03.120Z\",\"latitude\":-21.5167,\"longitude\":168.5426,\"depth\":14.19,\"mag\":6.6,\"magType\":\"mww\",\"gap\":21,\"dmin\":0.478,\"rms\":0.86,\"net\":\"us\",\"id\":\"us2000brgk\",\"updated\":\"2017-11-19T17:10:58.449Z\",\"place\":\"68km E of Tadine, New Caledonia\",\"type\":\"earthquake\",\"horizontalError\":6.2,\"depthError\":2.8,\"magError\":0.037,\"magNst\":72,\"status\":\"reviewed\",\"locationSource\":\"us\",\"magSource\":\"us\"} Puedes clicar en la peque\u00f1a flecha a la izquierda de cada propiedad para expandirla y examinar sus contenidos. Si existe cualquier terremoto de magnitud mayor a 6.2 , observar\u00e1s una salida adicional: msg.payload : string(6) \"ALARMA\" Para m\u00e1s informaci\u00f3n sobre los nodos b\u00e1sicos en Node-RED, puedes consultar: The Core Nodes : enlace a documentaci\u00f3n .","title":"Nodo Debug"},{"location":"Subjects/NP2/P9/#cliente-mqtt-y-despliegue-de-un-panel-de-control","text":"El nodo MQTT in permite realizar suscripciones a topics determinados en brokers MQTT. Arrastra un nuevo nodo MQTT in en tu espacio de trabajo y configura el broker asociado a localhost , puerto por defecto. Establece un topic de inter\u00e9s. Conecta un nodo Debug y despliega el flujo. Desde tu consola, publica mensajes v\u00eda mosquitto_pub y comprueba que, efectivamente, son visibles en Node-RED. A continuaci\u00f3n, crearemos un peque\u00f1o panel de control para la representaci\u00f3n gr\u00e1fica del valor publicado. En primer lugar, deber\u00e1s instalar el nodo node-red-dashboard desde el men\u00fa principal, opci\u00f3n Manage palette . Tras su instalaci\u00f3n, ver\u00e1s que aparecen nuevos nodos en el panel de nodos; \u00e9stos nos permitir\u00e1n dise\u00f1ar e implementar un panel de control b\u00e1sico basado en Widgets . Arrastra un nodo de tipo Gauge al espacio de trabajo, y configura sus valores por defecto. Conecta la salida de tu nodo MQTT in a la entrada del nuevo nodo Gauge . Despliega el flujo, y navega hasta http://localhost:1880/ui , donde deber\u00e1s observar el panel de control con el widget que has creado. Interact\u00faa con \u00e9l publicando mensajes v\u00eda MQTT. Para m\u00e1s informaci\u00f3n sobre el despliegue de paneles de control, puedes consultar: Node-Red-Dashboard : enlace a documentaci\u00f3n .","title":"Cliente MQTT y despliegue de un panel de control"},{"location":"Subjects/NP2/P9/#documentacion-adicional","text":"Las gu\u00edas de usuario oficiales de Node-RED son un buen punto de partida para profundizar en el uso de la infraestructura. De entre ellas, la parte m\u00e1s importante para comenzar es la que introduce los conceptos b\u00e1sicos de Node-RED, incluyendo el trabajo con nodos, flujos, contexto (importante para trabajar con valores globales y compartidos por todos los nodos en un flujo, por ejemplo), mensajes, wires , etc.: Node-RED Concepts : enlace a documentaci\u00f3n . La gu\u00eda Node-RED Guide contiene interesante documentaci\u00f3n adicional/avanzada tanto en el despliegue de flujos como en el uso de paneles de control locales o usando servicios remotos (por ejemplo, Freeboard ): Node-RED Guide : enlace a documentaci\u00f3n .","title":"Documentaci\u00f3n adicional"},{"location":"Subjects/NP2/P9/#ejercicio-entregable","text":"Se pide estudiar la documentaci\u00f3n asociada a Node-RED, tanto en su web oficial como en la gu\u00eda de programaci\u00f3n Node-RED Guide (espec\u00edficamente sus cuatro primeras partes. Junto con la explicaci\u00f3n proporcionada por el profesor y los anteriores ejemplos, este estudio permitir\u00e1 el desarrollo de la pr\u00e1ctica. Tarea entregable La pr\u00e1ctica consiste en el dise\u00f1o y desarrollo de un sistema basado en flujos de datos construido sobre Node-RED, que implemente un mecanismo de monitorizaci\u00f3n de par\u00e1metros ambientales (por ejemplo, temperatura) y notificaci\u00f3n (alarmas) ante ciertas circunstancias (por ejemplo, superar una determinada temperatura fijada como umbral). Los alumnos dise\u00f1ar\u00e1n el sistema y lo implementar\u00e1n, cumpliendo las siguientes premisas: (2 puntos) . El sistema utilizar\u00e1, al menos , un dispositivo externo (ESP32, SensorTag, Tel\u00e9fono M\u00f3vil, ...) para la recolecci\u00f3n de datos. Se valorar\u00e1 el uso de m\u00e1s de un dispositivo. (2 puntos) . El sistema depositar\u00e1 o interactuar\u00e1 con, al menos , un sistema externo (servidor de correo, Twitter, Telegram, IBM Bluemix, ...). (2 puntos) . El sistema depositar\u00e1 los datos observados en alg\u00fan medio persistente (Base de Datos no relacional, ficheros, ...) para permitir su posterior an\u00e1lisis y en un panel de control. (2 puntos) . El sistema actuar\u00e1 como un sistema de alarma \u00fanicamente ante ciertas condiciones de entrada (por ejemplo, al recibir un valor desde un sensor superior a un umbral establecido; dicho valor podr\u00eda, por ejemplo, configurarse v\u00eda MQTT o a trav\u00e9s de un panel de control). (2 puntos) . El sistema utilizar\u00e1, al menos, un tipo de nodo no instalado por defecto en la instalaci\u00f3n b\u00e1sica de Node-RED. Se entregar\u00e1 el fichero o ficheros JSON que describen los nodos, as\u00ed como una breve memoria que describa el sistema dise\u00f1ado y el trabajo realizado, haciendo hincapi\u00e9 en las dificultades encontradas y aquellos aspectos que se consideren de inter\u00e9s por parte del alumno/a.","title":"Ejercicio entregable"},{"location":"Subjects/SEC/","text":"SEC","title":"SEC"},{"location":"Subjects/SID/","text":"Smart Infrastructure Design All the information and documentation about Smart Infrastructure Design (SID) can be found in this link","title":"SID"},{"location":"Subjects/SID/#smart-infrastructure-design","text":"All the information and documentation about Smart Infrastructure Design (SID) can be found in this link","title":"Smart Infrastructure Design"}]}