{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Internet of Things and Data Analytics Welcome to the Master Propio on IoT and Data Analytics. Lectures are starting the 19th October. We will be using Zoom and you can find the links in the schedule shown below. Looking forward to meet you all! 2nd term - 18th Jan. 2022 till 7th Apr. 2022 From 28th March, Spanish time will become UTC+2 again. Most of the courses of this term will take place at 19:00h in China Standard Time. But, the LAST WEEK will be starting at 18:00h in China Standard Time. CHINESE NEW YEAR HOLIDAYS: from 31st Jan to 7th Feb 2022 Hours (Spanish time) Tuesday Wednesday Thursday Zoom Link 12:00-13:55 NP2 IA NP1 Zoom link Meeting number: 885 4236 5522. Passcode: 641877 14:05-16:00 IA NP1 NP2 Zoom link Meeting number: 892 8466 4167 Passcode: 477109 NP1 : Networks and Protocols I . NP2 : Networks and Protocols II . IA : Artificial Intelligence . Final project For detailed information about the final project, refer to this link Subjects MDM : Massive Data Management . SID : Smart Infrastructures Design . IOTNA : IoT Node Architecture . NP1 : Networks and Protocols I . NP2 : Networks and Protocols II . IA : Artificial Intelligence . EDGE : Edge Computing . SEC : Security . Professors and staff Subject Professor Mail Other IOTNA Jos\u00e9 Ignacio G\u00f3mez jigomez@ucm.es Director MDM Rafael Caballero rafa@sip.ucm.es - SID Iv\u00e1n Garc\u00eda igarciam@ucm.es - NP1 Christian Tenllado tenllado@ucm.es - NP2 Francisco Igual figual@ucm.es - AI H\u00e9ctor Garc\u00eda de Marina hgarciad@ucm.es - SEC Joaqu\u00edn Recas recas@ucm.es - SEC Guillermo Botella gbotella@ucm.es - EDGE Carlos Garc\u00eda garsanca@ucm.es - EDGE Luis Pi\u00f1uel lpinuel@ucm.es -","title":"Home"},{"location":"#internet-of-things-and-data-analytics","text":"Welcome to the Master Propio on IoT and Data Analytics. Lectures are starting the 19th October. We will be using Zoom and you can find the links in the schedule shown below. Looking forward to meet you all!","title":"Internet of Things and Data Analytics"},{"location":"#2nd-term-18th-jan-2022-till-7th-apr-2022","text":"From 28th March, Spanish time will become UTC+2 again. Most of the courses of this term will take place at 19:00h in China Standard Time. But, the LAST WEEK will be starting at 18:00h in China Standard Time. CHINESE NEW YEAR HOLIDAYS: from 31st Jan to 7th Feb 2022 Hours (Spanish time) Tuesday Wednesday Thursday Zoom Link 12:00-13:55 NP2 IA NP1 Zoom link Meeting number: 885 4236 5522. Passcode: 641877 14:05-16:00 IA NP1 NP2 Zoom link Meeting number: 892 8466 4167 Passcode: 477109 NP1 : Networks and Protocols I . NP2 : Networks and Protocols II . IA : Artificial Intelligence .","title":"2nd term - 18th Jan. 2022 till 7th Apr. 2022"},{"location":"#final-project","text":"For detailed information about the final project, refer to this link","title":"Final project"},{"location":"#subjects","text":"MDM : Massive Data Management . SID : Smart Infrastructures Design . IOTNA : IoT Node Architecture . NP1 : Networks and Protocols I . NP2 : Networks and Protocols II . IA : Artificial Intelligence . EDGE : Edge Computing . SEC : Security .","title":"Subjects"},{"location":"#professors-and-staff","text":"Subject Professor Mail Other IOTNA Jos\u00e9 Ignacio G\u00f3mez jigomez@ucm.es Director MDM Rafael Caballero rafa@sip.ucm.es - SID Iv\u00e1n Garc\u00eda igarciam@ucm.es - NP1 Christian Tenllado tenllado@ucm.es - NP2 Francisco Igual figual@ucm.es - AI H\u00e9ctor Garc\u00eda de Marina hgarciad@ucm.es - SEC Joaqu\u00edn Recas recas@ucm.es - SEC Guillermo Botella gbotella@ucm.es - EDGE Carlos Garc\u00eda garsanca@ucm.es - EDGE Luis Pi\u00f1uel lpinuel@ucm.es -","title":"Professors and staff"},{"location":"Contact/","text":"Contact information Director: XX Administrative staff: XX","title":"Contact"},{"location":"Contact/#contact-information","text":"Director: XX Administrative staff: XX","title":"Contact information"},{"location":"General/","text":"General information 1st term - 19th Oct. 2021 till 13th Jan 2022 Until 31st October, Spanish time is UTC+2, so the FIRST TWO WEEKS courses will be starting at 18:00h in China Standard Time. Starting November, Spanish time will be UTC+1, so courses will be starting at 19:00h in China Standard Time. Hours (Spanish time) Tuesday Wednesday Thursday 12:00-13:55 MDM IOTNA MDM 14:05-16:00 SID SID IOTNA MDM : Massive Data Management . SID : Smart Infrastructures Design . IOTNA : IoT Node Architecture . 2nd term - 18th Jan. 2022 till 7th Apr. 2022 From 28th March, Spanish time will become UTC+2 again. Most of the courses of this term will take place at 19:00h in China Standard Time. But, the LAST WEEK will be starting at 18:00h in China Standard Time. Hours (Spanish time) Tuesday Wednesday Thursday 12:00-13:55 NP2 IA NP1 14:05-16:00 IA NP1 NP2 NP1 : Networks and Protocols I . NP2 : Networks and Protocols II . IA : Artificial Intelligence . 3rd term - 19 Apr. till 3 Jun. All courses will be starting at 19:00h in China Standard Time Hours (UTC+2) Tuesday Wednesday Thursday 13:00-14:55 EDGE EDGE EDGE 15:05-17:00 SEC SEC SEC EDGE : Edge Computing . SEC : Security .","title":"General info."},{"location":"General/#general-information","text":"","title":"General information"},{"location":"General/#1st-term-19th-oct-2021-till-13th-jan-2022","text":"Until 31st October, Spanish time is UTC+2, so the FIRST TWO WEEKS courses will be starting at 18:00h in China Standard Time. Starting November, Spanish time will be UTC+1, so courses will be starting at 19:00h in China Standard Time. Hours (Spanish time) Tuesday Wednesday Thursday 12:00-13:55 MDM IOTNA MDM 14:05-16:00 SID SID IOTNA MDM : Massive Data Management . SID : Smart Infrastructures Design . IOTNA : IoT Node Architecture .","title":"1st term - 19th Oct. 2021  till  13th Jan 2022"},{"location":"General/#2nd-term-18th-jan-2022-till-7th-apr-2022","text":"From 28th March, Spanish time will become UTC+2 again. Most of the courses of this term will take place at 19:00h in China Standard Time. But, the LAST WEEK will be starting at 18:00h in China Standard Time. Hours (Spanish time) Tuesday Wednesday Thursday 12:00-13:55 NP2 IA NP1 14:05-16:00 IA NP1 NP2 NP1 : Networks and Protocols I . NP2 : Networks and Protocols II . IA : Artificial Intelligence .","title":"2nd term  - 18th Jan. 2022 till 7th Apr. 2022"},{"location":"General/#3rd-term-19-apr-till-3-jun","text":"All courses will be starting at 19:00h in China Standard Time Hours (UTC+2) Tuesday Wednesday Thursday 13:00-14:55 EDGE EDGE EDGE 15:05-17:00 SEC SEC SEC EDGE : Edge Computing . SEC : Security .","title":"3rd term - 19 Apr. till 3 Jun."},{"location":"General/TFM/","text":"Final project proposals Important dates Deadline for proposal selection: February 10 Deadline for proposal notifications: February 17 Deadline for final deliverables (PDF report, video presentation and supplementary material): June 27 Final defenses: July 11-15 Description and rules The Final Project is a research or development work that aims at demonstrating that the student has acquired the necessary knowledge and skills associated to the Master's Degree, and it will be developed in groups of three students under the supervision of one or more professors. The contents to develop for each project proposal will depend on the specific selected topic, and they will range from designing and developing a specific IoT application/deployment, service or system within the field of Internet of Things, or theoretical in-depth studies of state-of-the-art topics related with IoT. In all cases, the contents will extend and integrate knowledge and skills studied throughout the different subjects. The project will allow the students to relate practical aspects and professional issues with the topics covered within the development of one or more of the subjects covered in the Master, adapted to the interests of the student. The Advisor will define the topic and tasks to fulfill, and will guide the students throughout the development of the work and the goals to achieve. He/she will organize activities to control the correct development of the work. The estimated amount of time for each student is 300 hours of personal work . Evaluation The evaluation of the Project will be carried out by a Committee that will be composed by professors of the different subjects. In order to defend the work, the students will need to pass all the subjects in the Master, and he/she will need a signed agreement from the Advisor stating his/her consent to proceed with the defense. This consent report will include all the considerations necessary to assist the Committee in the evaluation of the work. The students will present a report written in English, that will include, at least, an introduction, goal description and work plan (including a task distribution among members of the group), together with a critical discussion of the develped work and results, conclusions and related bibliography. The suggested length of the report is 50 pages . The defense of the work will be carried out in two stages: Video presentation delivered before the final deadline. Public live session in which the members of the Committe will share with the students the necessary questions and comments that help evaluating the developed work. Questions will be addressed in general to all members of the group, and also specifically to each member of the group. In the following, we propose a number of topics proposed by professors covering topics of interest. Up to two groups of 3 students can select each project. This selection will be communicated to Jos\u00e9 Ignacio G\u00f3mez (jigomez@ucm.es) and Francisco Igual (figual@ucm.es) by mail before February 10 . The work needs to be original and developed in groups of 3 students, clearly defining the tasks to develop by each member of the group, in a balanced fashion. Plagiarism (from other students or third parties) will determine a fail in the final grade of the work for all members of the group. Deliverables Each group will deliver three evidences of the developed work before the final deadline: Report in PDF format. Presentation video of up to 30 mins. of duration. Developed code (if applicable). The dates and mechanisms to deliver the final report and to proceed with the defense will be announced with enough time before the deadline. Proposals Proposal 1 Title: Relation between air pollution, weather and traffic Requirements: good programming skills. Professor: Rafael Caballero Rold\u00e1n (rafacr@ucm.es) Available slots: 2 groups Description: The goal is to predict the pollution in a particular point of a city for the next few hours. The prediction will take as input from the data collected by sensors of air pollution and number of vehicles. We will train different models and evaluate the results to choose the best predictions in each case. The project includes: Basic data management to prepare the data Basic statistics to understand the data and detect outliers Clustering for selecting days with similar pollution/traffic conditions Feature selection Hiperparameter tunning Model Selection Proposal 2 Title: Machine Learning Ensamble Methods Requirements: good programming skills. Professor: Rafael Caballero Rold\u00e1n (rafacr@ucm.es) Available slots: 2 groups Description: The ensemble Methods combine several weak learners to build a more efficient method. The main goal is to implement in Spark the three main Methods (bagging, stacking and Boosting). On particular the project will include: A complete description of the tecniques A Spark function implementing them A benchmark using some datasets of the course to compare their efficiency Proposal 3 Title: IoT devices or services for well-being Professor: Iv\u00e1n Garc\u00eda-Magari\u00f1o Garc\u00eda (igarciam@ucm.es) Available slots: 2 groups Description: Well-being is usually desired by most people, and smart watches and smart bands are growing in popularity for such purpose. However, other IoT devices and services can help users to provide accurate perspectives of certain well-being aspects in order to provide personalized advices for increasing the well-being. For example, smart beds can help you in tracking you sleeping, door sensors could measure the time spent in outdoor activities or the times you eat meals at home. All this information related with emotional information could feed an intelligent system to output the right advices for increasing the well-being. This work could be conducted from either (1) a research perspective being relevant the analysis of existing works in this topic and the proposal of novel ideas, or (2) from a technical perspective addressing to program some intelligent system for providing well- being advices based on information from IoT devices. Proposal 4 Title: IoT devices or services for healthcare Professor: Iv\u00e1n Garc\u00eda-Magari\u00f1o Garc\u00eda (igarciam@ucm.es) Available slots: 2 groups Description: Healthcare is benefiting from the growing of IoT. For instance, smart homes could track the progress of certain symptoms. Smart IoT dispensers can help patients in reminding their medication to avoid both missing it and forgetting whether certain medication has been taken. This work could be conducted from either (1) a research perspective being relevant the analysis of existing works in this topic and the proposal of novel ideas, or (2) from a technical perspective addressing to prototype a certain IoT device or service and program the necessary software for providing a system that could help in some aspect of healthcare. Proposal 5 Title: OpenData iniciatives in China: situation, perspectives and use cases Professors: Francisco Igual and J. Ignacio G\u00f3mez (figual@ucm.es and jigomez@ucm.es) Requirements: recommended, but not mandatory, basic programming skills. Available slots: 2 groups Description: OpenData initiatives pursue offering data sources in an open, royalty-free and accessible manner. It follows a similar philosophy as that of Open Source or Open Hardware, and aims at facilitating data analysis to the community taken from official channels, both from Local or National Goverments, or from companies. The goal of the project is two-fold: first, to provide a global, in-depth study and discussion of the OpenData initiatives in China, both from the Government and from Private Companies; second, to select a set of realistic use cases to perform specific data analysis oriented to real-world applications, mainly based on or with application to the IoT paradigm. Proposal 6 Title: SmartCities: requirements, infrastructure and use cases Professors: Francisco Igual and J. Ignacio G\u00f3mez (figual@ucm.es and jigomez@ucm.es) Requirements: no programming skills necessary. Available slots: 2 groups Description: We have been using the term Smart Cities for many years now, but it still looks like a to be defined concept. There are many flavours in Smart Cities initiatives and many actors that play different roles in the process of implementing them. Focusing on IoT, there is always a need to deploy an infrastructure that may represent a huge economical investment with some return expected (economic, social...). The goal of this project is to deep into the idea of Smart Cities, starting with a general description of its typical topics: smart mobility, smart buildings, smart grid (energy distribution and savings), smart health, water supply, waste disposal facilities... The students will choose two of those topic and provide an in-depth study of the requirements (sensors, nodes, edge computing, servers...) including the deployment and maintenance process. The study must include at least two examples of existing cities implementing initiatives in the topics chosen (one Chinese and one European city, if possible). There are many questions this study may answer: how is a given project improving the quality of life of the citizens? Who is paying the cost of the infrastructure? What is the expected \"Return Of Investment\" (ROI)? Will there be shared infrastructures? (i.e. companies that deploy a sensor network and rent it to other companies/public organisations as a \"service\") Proposal 7 Title: Building meshes with WiFi Professors: Francisco Igual and J. Ignacio G\u00f3mez (figual@ucm.es and jigomez@ucm.es) Requirements: good programming skills necessary. Available slots: 2 groups Description: ESP-IDF provides a proprietary protocol, called ESP-WIFI-MESH , that allows numerous devices spread over a large physical area (both indoors and outdoors) to be interconnected under a single WLAN (Wireless Local-Area Network). ESP-WIFI-MESH is self-organizing and self-healing meaning the network can be built and maintained autonomously. You can find information about ESP-WIFI-MESH in this link . Some of those nodes (but not necessarily all of them) may have access to a router (border router) that provides access to the internet. The far-away nodes (those outside the range of the router) may still connect to the internet asking the intermediate nodes to relay their transmissions. ESP-IDF also provides an API to access Thread , an IPv6-based mesh networking technology for IoT. Once again, it allows a mesh of nodes to gain access to the internet even if they are not close to a border router. More information about Thread can be found in this link . The goal of this project is to build a mesh of ESP32 nodes using both technologies to comparte their APIs, capabilities and performance. The nodes will run simple applications (sensing temperature, for example) and will try to send the information to an external server using MQTT. Some of the nodes will be close to a router providing access to the internet (and thus, to the external server), while some others will be out of the range of the router signal. The study should compare both implementations, trying to figure out the overheads of each implementation, relative performance, ease of use... IMPORTANT : to perform this project, you will need more than 2 ESP32 boards, so the team partners should live close enough to physically meet to make tests. Proposal 8 Title: Lightweight Cryptography Applicable to IoT Devices Professors: Joaquin Recas (recas@ucm.es) and Guillermo Botella (gbotella@ucm.es) Requirements: good programming skills necessary. Available slots: 2 groups Description: Cryptography in IoT requires a compromise between security, performance and cost. Performance refers to power consumption, latency, and throughput; the cost, to memory and CPU. The more secure an algorithm or protocol is, the more negative impact it will have on cost and performance. Similarly, if you want to improve performance or lower cost, you will have a negative impact on security. The objective of this project is to test different publicly accessible encryption implementations that can be used in IoT systems and to make a comparative study on the three factors described above: security, performance and cost. Proposal 9 Title: SDR and GNU Radio to explore IoT vulnerabilities Professors: Joaquin Recas (recas@ucm.es) and Guillermo Botella (gbotella@ucm.es) Requirements: good programming skills necessary. Available slots: 2 groups Description: Wireless communications still keep growing, becoming part of our daily lives with the aim of making it easier. For example through the use of wireless devices, home automation, industrial environments, among others that make up the Internet of Things. Sometimes, manufacturers of IoT devices focus to improve their functionality and make them more competitive in the market and do not pay sufficient attention to the security issue. Normally, the common user is not aware of the vulnerabilities of communications that are propagated by the air as used by IoT devices. This work pretends to show the use of SDR and GNU Radio as tools to study and analyzing vulnerabilities over IoT communications through Radio Frequencies protocols (RF), getting interesting information such as operation frequency, modulation, applying reverse engineering and replay attack. Proposal 10 Title: Exploring Open Source IoT frameworks: Eclipse IoT and Zephyr OS Professors: Christian Tenllado (tenllado@ucm.es) Requirements: no programming skills necessary. Available slots: 2 groups Description: The fast growth of IoT in recent years has lead to massive publications of tools and frameworks developed to work at different levels of the IoT ecosystem. A relevant part of them have ben released as Open Source, so they are specially interesting for small companies and start-ups wanting to contribute in this domain. Eclipse IoT is an initiative to gather a huge plethora of IoT technologies, backed up by the most relevant companies in this sector. Zephyr is a Linux Foundation project releasing an open-source, product-ready RTOS (real-time operating system) for embedded systems (sensor nodes). This project will extensively document the Eclipse IoT project, enumerating the existing projects and locating them in their target IoT system level: sensor node, gateway, edge, fog or cloud. Zephyr will be also considered in the studay, to explore how it fits the other existing projects. Once the most relevant are described, several use cases will be considered, illustrating how a combination of different projects may help to develop a full IoT application, from sensor node programming, deployment, management, data collection and processing. Proposal 11 Title: Accelerators in Edge Computing Professors: Carlos Garc\u00eda (cgarcia@ucm.es) Requirements: no programming skills necessary. Available slots: 2 groups Description: On one hand, the use of accelerators has been gaining importance in the context of the High Performance Computing arena to improve workload performance. On the other hand, with the exponential growth of data generation joint to the irruption of IoT devices at the edge, has meant the consideration of the use of accelerators in another context where accelerators were not initially designed. The future of computing is driven by the need to process data cost-effectively close to the data production. A single example of this tendency is the design and commercialization of specific ASICs to process powerful IA algorithms to speedup the response times with less power requirements. This project proposal will research the use of accelerators such as GPUs, FPGAs, SMART-NICs in an IoT ecosystem. The project will not only focus on the diversity of hardware devices but also deepen on other aspects such as programmability, efficient execution workloads, real cases adoptions, and infrastructure integration among others. Software aspects as frameworks and toolchain infrastructure for deploying a solution should be also evaluated, as well as the integration on the IoT dashboards for collection and analyzing","title":"Final project proposals"},{"location":"General/TFM/#final-project-proposals","text":"","title":"Final project proposals"},{"location":"General/TFM/#important-dates","text":"Deadline for proposal selection: February 10 Deadline for proposal notifications: February 17 Deadline for final deliverables (PDF report, video presentation and supplementary material): June 27 Final defenses: July 11-15","title":"Important dates"},{"location":"General/TFM/#description-and-rules","text":"The Final Project is a research or development work that aims at demonstrating that the student has acquired the necessary knowledge and skills associated to the Master's Degree, and it will be developed in groups of three students under the supervision of one or more professors. The contents to develop for each project proposal will depend on the specific selected topic, and they will range from designing and developing a specific IoT application/deployment, service or system within the field of Internet of Things, or theoretical in-depth studies of state-of-the-art topics related with IoT. In all cases, the contents will extend and integrate knowledge and skills studied throughout the different subjects. The project will allow the students to relate practical aspects and professional issues with the topics covered within the development of one or more of the subjects covered in the Master, adapted to the interests of the student. The Advisor will define the topic and tasks to fulfill, and will guide the students throughout the development of the work and the goals to achieve. He/she will organize activities to control the correct development of the work. The estimated amount of time for each student is 300 hours of personal work .","title":"Description and rules"},{"location":"General/TFM/#evaluation","text":"The evaluation of the Project will be carried out by a Committee that will be composed by professors of the different subjects. In order to defend the work, the students will need to pass all the subjects in the Master, and he/she will need a signed agreement from the Advisor stating his/her consent to proceed with the defense. This consent report will include all the considerations necessary to assist the Committee in the evaluation of the work. The students will present a report written in English, that will include, at least, an introduction, goal description and work plan (including a task distribution among members of the group), together with a critical discussion of the develped work and results, conclusions and related bibliography. The suggested length of the report is 50 pages . The defense of the work will be carried out in two stages: Video presentation delivered before the final deadline. Public live session in which the members of the Committe will share with the students the necessary questions and comments that help evaluating the developed work. Questions will be addressed in general to all members of the group, and also specifically to each member of the group. In the following, we propose a number of topics proposed by professors covering topics of interest. Up to two groups of 3 students can select each project. This selection will be communicated to Jos\u00e9 Ignacio G\u00f3mez (jigomez@ucm.es) and Francisco Igual (figual@ucm.es) by mail before February 10 . The work needs to be original and developed in groups of 3 students, clearly defining the tasks to develop by each member of the group, in a balanced fashion. Plagiarism (from other students or third parties) will determine a fail in the final grade of the work for all members of the group.","title":"Evaluation"},{"location":"General/TFM/#deliverables","text":"Each group will deliver three evidences of the developed work before the final deadline: Report in PDF format. Presentation video of up to 30 mins. of duration. Developed code (if applicable). The dates and mechanisms to deliver the final report and to proceed with the defense will be announced with enough time before the deadline.","title":"Deliverables"},{"location":"General/TFM/#proposals","text":"","title":"Proposals"},{"location":"General/TFM/#proposal-1","text":"Title: Relation between air pollution, weather and traffic Requirements: good programming skills. Professor: Rafael Caballero Rold\u00e1n (rafacr@ucm.es) Available slots: 2 groups Description: The goal is to predict the pollution in a particular point of a city for the next few hours. The prediction will take as input from the data collected by sensors of air pollution and number of vehicles. We will train different models and evaluate the results to choose the best predictions in each case. The project includes: Basic data management to prepare the data Basic statistics to understand the data and detect outliers Clustering for selecting days with similar pollution/traffic conditions Feature selection Hiperparameter tunning Model Selection","title":"Proposal 1"},{"location":"General/TFM/#proposal-2","text":"Title: Machine Learning Ensamble Methods Requirements: good programming skills. Professor: Rafael Caballero Rold\u00e1n (rafacr@ucm.es) Available slots: 2 groups Description: The ensemble Methods combine several weak learners to build a more efficient method. The main goal is to implement in Spark the three main Methods (bagging, stacking and Boosting). On particular the project will include: A complete description of the tecniques A Spark function implementing them A benchmark using some datasets of the course to compare their efficiency","title":"Proposal 2"},{"location":"General/TFM/#proposal-3","text":"Title: IoT devices or services for well-being Professor: Iv\u00e1n Garc\u00eda-Magari\u00f1o Garc\u00eda (igarciam@ucm.es) Available slots: 2 groups Description: Well-being is usually desired by most people, and smart watches and smart bands are growing in popularity for such purpose. However, other IoT devices and services can help users to provide accurate perspectives of certain well-being aspects in order to provide personalized advices for increasing the well-being. For example, smart beds can help you in tracking you sleeping, door sensors could measure the time spent in outdoor activities or the times you eat meals at home. All this information related with emotional information could feed an intelligent system to output the right advices for increasing the well-being. This work could be conducted from either (1) a research perspective being relevant the analysis of existing works in this topic and the proposal of novel ideas, or (2) from a technical perspective addressing to program some intelligent system for providing well- being advices based on information from IoT devices.","title":"Proposal 3"},{"location":"General/TFM/#proposal-4","text":"Title: IoT devices or services for healthcare Professor: Iv\u00e1n Garc\u00eda-Magari\u00f1o Garc\u00eda (igarciam@ucm.es) Available slots: 2 groups Description: Healthcare is benefiting from the growing of IoT. For instance, smart homes could track the progress of certain symptoms. Smart IoT dispensers can help patients in reminding their medication to avoid both missing it and forgetting whether certain medication has been taken. This work could be conducted from either (1) a research perspective being relevant the analysis of existing works in this topic and the proposal of novel ideas, or (2) from a technical perspective addressing to prototype a certain IoT device or service and program the necessary software for providing a system that could help in some aspect of healthcare.","title":"Proposal 4"},{"location":"General/TFM/#proposal-5","text":"Title: OpenData iniciatives in China: situation, perspectives and use cases Professors: Francisco Igual and J. Ignacio G\u00f3mez (figual@ucm.es and jigomez@ucm.es) Requirements: recommended, but not mandatory, basic programming skills. Available slots: 2 groups Description: OpenData initiatives pursue offering data sources in an open, royalty-free and accessible manner. It follows a similar philosophy as that of Open Source or Open Hardware, and aims at facilitating data analysis to the community taken from official channels, both from Local or National Goverments, or from companies. The goal of the project is two-fold: first, to provide a global, in-depth study and discussion of the OpenData initiatives in China, both from the Government and from Private Companies; second, to select a set of realistic use cases to perform specific data analysis oriented to real-world applications, mainly based on or with application to the IoT paradigm.","title":"Proposal 5"},{"location":"General/TFM/#proposal-6","text":"Title: SmartCities: requirements, infrastructure and use cases Professors: Francisco Igual and J. Ignacio G\u00f3mez (figual@ucm.es and jigomez@ucm.es) Requirements: no programming skills necessary. Available slots: 2 groups Description: We have been using the term Smart Cities for many years now, but it still looks like a to be defined concept. There are many flavours in Smart Cities initiatives and many actors that play different roles in the process of implementing them. Focusing on IoT, there is always a need to deploy an infrastructure that may represent a huge economical investment with some return expected (economic, social...). The goal of this project is to deep into the idea of Smart Cities, starting with a general description of its typical topics: smart mobility, smart buildings, smart grid (energy distribution and savings), smart health, water supply, waste disposal facilities... The students will choose two of those topic and provide an in-depth study of the requirements (sensors, nodes, edge computing, servers...) including the deployment and maintenance process. The study must include at least two examples of existing cities implementing initiatives in the topics chosen (one Chinese and one European city, if possible). There are many questions this study may answer: how is a given project improving the quality of life of the citizens? Who is paying the cost of the infrastructure? What is the expected \"Return Of Investment\" (ROI)? Will there be shared infrastructures? (i.e. companies that deploy a sensor network and rent it to other companies/public organisations as a \"service\")","title":"Proposal 6"},{"location":"General/TFM/#proposal-7","text":"Title: Building meshes with WiFi Professors: Francisco Igual and J. Ignacio G\u00f3mez (figual@ucm.es and jigomez@ucm.es) Requirements: good programming skills necessary. Available slots: 2 groups Description: ESP-IDF provides a proprietary protocol, called ESP-WIFI-MESH , that allows numerous devices spread over a large physical area (both indoors and outdoors) to be interconnected under a single WLAN (Wireless Local-Area Network). ESP-WIFI-MESH is self-organizing and self-healing meaning the network can be built and maintained autonomously. You can find information about ESP-WIFI-MESH in this link . Some of those nodes (but not necessarily all of them) may have access to a router (border router) that provides access to the internet. The far-away nodes (those outside the range of the router) may still connect to the internet asking the intermediate nodes to relay their transmissions. ESP-IDF also provides an API to access Thread , an IPv6-based mesh networking technology for IoT. Once again, it allows a mesh of nodes to gain access to the internet even if they are not close to a border router. More information about Thread can be found in this link . The goal of this project is to build a mesh of ESP32 nodes using both technologies to comparte their APIs, capabilities and performance. The nodes will run simple applications (sensing temperature, for example) and will try to send the information to an external server using MQTT. Some of the nodes will be close to a router providing access to the internet (and thus, to the external server), while some others will be out of the range of the router signal. The study should compare both implementations, trying to figure out the overheads of each implementation, relative performance, ease of use... IMPORTANT : to perform this project, you will need more than 2 ESP32 boards, so the team partners should live close enough to physically meet to make tests.","title":"Proposal 7"},{"location":"General/TFM/#proposal-8","text":"Title: Lightweight Cryptography Applicable to IoT Devices Professors: Joaquin Recas (recas@ucm.es) and Guillermo Botella (gbotella@ucm.es) Requirements: good programming skills necessary. Available slots: 2 groups Description: Cryptography in IoT requires a compromise between security, performance and cost. Performance refers to power consumption, latency, and throughput; the cost, to memory and CPU. The more secure an algorithm or protocol is, the more negative impact it will have on cost and performance. Similarly, if you want to improve performance or lower cost, you will have a negative impact on security. The objective of this project is to test different publicly accessible encryption implementations that can be used in IoT systems and to make a comparative study on the three factors described above: security, performance and cost.","title":"Proposal 8"},{"location":"General/TFM/#proposal-9","text":"Title: SDR and GNU Radio to explore IoT vulnerabilities Professors: Joaquin Recas (recas@ucm.es) and Guillermo Botella (gbotella@ucm.es) Requirements: good programming skills necessary. Available slots: 2 groups Description: Wireless communications still keep growing, becoming part of our daily lives with the aim of making it easier. For example through the use of wireless devices, home automation, industrial environments, among others that make up the Internet of Things. Sometimes, manufacturers of IoT devices focus to improve their functionality and make them more competitive in the market and do not pay sufficient attention to the security issue. Normally, the common user is not aware of the vulnerabilities of communications that are propagated by the air as used by IoT devices. This work pretends to show the use of SDR and GNU Radio as tools to study and analyzing vulnerabilities over IoT communications through Radio Frequencies protocols (RF), getting interesting information such as operation frequency, modulation, applying reverse engineering and replay attack.","title":"Proposal 9"},{"location":"General/TFM/#proposal-10","text":"Title: Exploring Open Source IoT frameworks: Eclipse IoT and Zephyr OS Professors: Christian Tenllado (tenllado@ucm.es) Requirements: no programming skills necessary. Available slots: 2 groups Description: The fast growth of IoT in recent years has lead to massive publications of tools and frameworks developed to work at different levels of the IoT ecosystem. A relevant part of them have ben released as Open Source, so they are specially interesting for small companies and start-ups wanting to contribute in this domain. Eclipse IoT is an initiative to gather a huge plethora of IoT technologies, backed up by the most relevant companies in this sector. Zephyr is a Linux Foundation project releasing an open-source, product-ready RTOS (real-time operating system) for embedded systems (sensor nodes). This project will extensively document the Eclipse IoT project, enumerating the existing projects and locating them in their target IoT system level: sensor node, gateway, edge, fog or cloud. Zephyr will be also considered in the studay, to explore how it fits the other existing projects. Once the most relevant are described, several use cases will be considered, illustrating how a combination of different projects may help to develop a full IoT application, from sensor node programming, deployment, management, data collection and processing.","title":"Proposal 10"},{"location":"General/TFM/#proposal-11","text":"Title: Accelerators in Edge Computing Professors: Carlos Garc\u00eda (cgarcia@ucm.es) Requirements: no programming skills necessary. Available slots: 2 groups Description: On one hand, the use of accelerators has been gaining importance in the context of the High Performance Computing arena to improve workload performance. On the other hand, with the exponential growth of data generation joint to the irruption of IoT devices at the edge, has meant the consideration of the use of accelerators in another context where accelerators were not initially designed. The future of computing is driven by the need to process data cost-effectively close to the data production. A single example of this tendency is the design and commercialization of specific ASICs to process powerful IA algorithms to speedup the response times with less power requirements. This project proposal will research the use of accelerators such as GPUs, FPGAs, SMART-NICs in an IoT ecosystem. The project will not only focus on the diversity of hardware devices but also deepen on other aspects such as programmability, efficient execution workloads, real cases adoptions, and infrastructure integration among others. Software aspects as frameworks and toolchain infrastructure for deploying a solution should be also evaluated, as well as the integration on the IoT dashboards for collection and analyzing","title":"Proposal 11"},{"location":"News/","text":"News and announcements Test announcement - Jan 1st This is a test announcement. Test alert - Jan 1st This is a test alert.","title":"News"},{"location":"News/#news-and-announcements","text":"Test announcement - Jan 1st This is a test announcement. Test alert - Jan 1st This is a test alert.","title":"News and announcements"},{"location":"Subjects/EDGE/","text":"EDGE","title":"EDGE"},{"location":"Subjects/IA/","text":"ARTIFICIAL INTELLIGENCE General Information This subject will introduce you to artificial intelligence techniques, mostly from a practical point of view. Professor Hector Garcia de Marina (hgarciad@ucm.es) Evaluation The final grade will consist of a number of quizzes during the the course, and a final project during the last two weeks of the course. Software requirements Ubuntu 20.04 & Python Instructions to set up the required software requirements.txt Work groups The groups are the same as for NP1, please check them here Schedule Day/Month Topic Deliverable Quizz 18/01 Introduction 19/01 Math recap for AI and NumPy, Jupyter excercises , Sample image , Jupyter classroom notes 25/01 Neural Networks from scratch 26/01 Neural Networks from scratch 2 08/02 Neural Networks with pyTorch Exercise on Neural Networks from Scratch Quizz on Neural Networks from scratch 09/02 Neural Network exercise with pyTorch 15/02 Neural Network regression with pyTorch 16/02 22/02 23/02 01/03 02/03 08/03 09/03 15/03 16/03 22/03 23/03 29/03 Work on Final Project 30/03 Work on Final Project 05/03 Work on Final Project 06/03 Work on Final Project","title":"IA"},{"location":"Subjects/IA/#artificial-intelligence","text":"","title":"ARTIFICIAL INTELLIGENCE"},{"location":"Subjects/IA/#general-information","text":"This subject will introduce you to artificial intelligence techniques, mostly from a practical point of view.","title":"General Information"},{"location":"Subjects/IA/#professor","text":"Hector Garcia de Marina (hgarciad@ucm.es)","title":"Professor"},{"location":"Subjects/IA/#evaluation","text":"The final grade will consist of a number of quizzes during the the course, and a final project during the last two weeks of the course.","title":"Evaluation"},{"location":"Subjects/IA/#software-requirements","text":"Ubuntu 20.04 & Python Instructions to set up the required software requirements.txt","title":"Software requirements"},{"location":"Subjects/IA/#work-groups","text":"The groups are the same as for NP1, please check them here","title":"Work groups"},{"location":"Subjects/IA/#schedule","text":"Day/Month Topic Deliverable Quizz 18/01 Introduction 19/01 Math recap for AI and NumPy, Jupyter excercises , Sample image , Jupyter classroom notes 25/01 Neural Networks from scratch 26/01 Neural Networks from scratch 2 08/02 Neural Networks with pyTorch Exercise on Neural Networks from Scratch Quizz on Neural Networks from scratch 09/02 Neural Network exercise with pyTorch 15/02 Neural Network regression with pyTorch 16/02 22/02 23/02 01/03 02/03 08/03 09/03 15/03 16/03 22/03 23/03 29/03 Work on Final Project 30/03 Work on Final Project 05/03 Work on Final Project 06/03 Work on Final Project","title":"Schedule"},{"location":"Subjects/IA/groups/","text":"Groups for lecture assignments We will be using the stable groups from NP1 to work during lectures (and after class). Group 1 Rol Full name Speaker BIN ZHANG Recorder FENGFENG GU Auditor GONGLU ZOU Contributor WENYAN LIAO Group 2 Rol Full name Speaker Duan Zhen Recorder Hu Haho Auditor Liu Jinhua Contributor Youran Tian Contributor Weilin Zhang Contributor Huang Yujuan Contributor Jun Shou Group 3 Rol Full name Speaker GuanJIE Xiao Speaker (2) DongYang Xu Recorder ShaYuan Shuang Auditor Junyan Guo Contributor Zhijun Hao Contributor Xueqing Zhao Contributor Jiali Gao Group 4 Rol Full name Speaker JIEPING YOU Recorder QINGHONG YU Auditor SUIZHI LIU Contributor TIANFENG LI Contributor WEI REN Contributor XIAZU HU Group 5 Rol Full name Speaker ZHOU Ping Speaker (2) LIAO Yinghua Recorder PAN Jiayun Auditor ZHANG Yi Contributor Shuishi Zhou Contributor Yang Chu Contributor Hongbiao Cao Group 6 Rol Full name Speaker Xiaolan Li Recorder Xionglan Luo Auditor Qiuji Chen Contributor Jianchuang Zhang Contributor Yan Zhao Contributor Yongtao He Contributor Zhao Hu","title":"Groups for lecture assignments"},{"location":"Subjects/IA/groups/#groups-for-lecture-assignments","text":"We will be using the stable groups from NP1 to work during lectures (and after class).","title":"Groups for lecture assignments"},{"location":"Subjects/IA/groups/#group-1","text":"Rol Full name Speaker BIN ZHANG Recorder FENGFENG GU Auditor GONGLU ZOU Contributor WENYAN LIAO","title":"Group 1"},{"location":"Subjects/IA/groups/#group-2","text":"Rol Full name Speaker Duan Zhen Recorder Hu Haho Auditor Liu Jinhua Contributor Youran Tian Contributor Weilin Zhang Contributor Huang Yujuan Contributor Jun Shou","title":"Group 2"},{"location":"Subjects/IA/groups/#group-3","text":"Rol Full name Speaker GuanJIE Xiao Speaker (2) DongYang Xu Recorder ShaYuan Shuang Auditor Junyan Guo Contributor Zhijun Hao Contributor Xueqing Zhao Contributor Jiali Gao","title":"Group 3"},{"location":"Subjects/IA/groups/#group-4","text":"Rol Full name Speaker JIEPING YOU Recorder QINGHONG YU Auditor SUIZHI LIU Contributor TIANFENG LI Contributor WEI REN Contributor XIAZU HU","title":"Group 4"},{"location":"Subjects/IA/groups/#group-5","text":"Rol Full name Speaker ZHOU Ping Speaker (2) LIAO Yinghua Recorder PAN Jiayun Auditor ZHANG Yi Contributor Shuishi Zhou Contributor Yang Chu Contributor Hongbiao Cao","title":"Group 5"},{"location":"Subjects/IA/groups/#group-6","text":"Rol Full name Speaker Xiaolan Li Recorder Xionglan Luo Auditor Qiuji Chen Contributor Jianchuang Zhang Contributor Yan Zhao Contributor Yongtao He Contributor Zhao Hu","title":"Group 6"},{"location":"Subjects/IOTNA/","text":"IoT Node Architecture General information This subject will cover several topics regarding embedded system programmings. Specifically, we will learn to develop IoT projects using ESP-IDF , a framework built onto FreeRTOS . Some specific goals if this subject are: Get a global view of a safe application development cycle. Meet the main components of an IoT device Learn basic components of Real Time Operating Systems (RTOS) Work with sensors and learn the most common interfaces Subject program and evaluation methodology Program and evaluation Professors Jose Ignacio Gomez (jigomez@ucm.es) and Katzalin Olcoz (katzalin@ucm.es ) Work groups (for regular lab assignments) Here you can find the current work groups Personal paper project assignment Here you can find description about this individual assignment Final programming project (teams of 2 people) Here you can find description about this assignment Quizzes All quizzes will be done in this link . The name of the room is IOTUCM. You MUST enter your email to answer the quizzes (the email address where you received mails from me). Schedule Day Topic Lab instructions Deliverable 20/10 Introduction: boards, SoC C Exercises 21/10 ESP-IDF environment Online DEMO 27/10 ESP-IDF 1. Starting ESP-IDF 28/10 ESP32 Memory map 1. Starting ESP-IDF 03/11 ESP-IDF Tasks Scheduler 2. Tasks: matrix multiply 04/11 ESP-IDF Tasks Scheduler 2. Tasks: matrix multiply 10/11 Events and task notifications 2. Tasks: matrix multiply 11/11 Input/Output - Polling/Interrupts - GPIO 3. Chronometer 17/11 Timers 3. Chronometer 18/11 Event based programming 3. Chronometer Lab 2 deadline 24/11 Event based programming. NAND/NOR Flash 3. Chronometer 25/11 File system . System Log 4. Log in flash 01/12 Watchdog 4. Log in flash Lab 3 deadline 02/12 Sensors . 4. Log in flash 08/12 NO LECTURE (non working day) Spain National Holiday 09/12 Serial buses: I2C, SPI, UART 4. Log in flash 15/12 QUIZ . ESP-IDF I2C API 5. Built-in sensors . HTS221 Datasheet Lab4 deadline 16/12 I2C 5. Built-in sensors . HTS221 Datasheet 22/12 Energy consumption . Powering the system 5. Built-in sensors 23/12 QUIZ . ESP32 power modes 6. Low power modes Labs 5 deadline 12/01 Final Programming project (groups of 2) 7. Final Project Paper project deadline 13/01 QUIZ . Final Programming project 7. Final Project Lab 6 deadline The final programming project, will be due before 24th Jan. 2022","title":"IOTNA"},{"location":"Subjects/IOTNA/#iot-node-architecture","text":"","title":"IoT Node Architecture"},{"location":"Subjects/IOTNA/#general-information","text":"This subject will cover several topics regarding embedded system programmings. Specifically, we will learn to develop IoT projects using ESP-IDF , a framework built onto FreeRTOS . Some specific goals if this subject are: Get a global view of a safe application development cycle. Meet the main components of an IoT device Learn basic components of Real Time Operating Systems (RTOS) Work with sensors and learn the most common interfaces","title":"General information"},{"location":"Subjects/IOTNA/#subject-program-and-evaluation-methodology","text":"Program and evaluation","title":"Subject program and evaluation methodology"},{"location":"Subjects/IOTNA/#professors","text":"Jose Ignacio Gomez (jigomez@ucm.es) and Katzalin Olcoz (katzalin@ucm.es )","title":"Professors"},{"location":"Subjects/IOTNA/#work-groups-for-regular-lab-assignments","text":"Here you can find the current work groups","title":"Work groups (for regular lab assignments)"},{"location":"Subjects/IOTNA/#personal-paper-project-assignment","text":"Here you can find description about this individual assignment","title":"Personal paper project assignment"},{"location":"Subjects/IOTNA/#final-programming-project-teams-of-2-people","text":"Here you can find description about this assignment","title":"Final programming project (teams of 2 people)"},{"location":"Subjects/IOTNA/#quizzes","text":"All quizzes will be done in this link . The name of the room is IOTUCM. You MUST enter your email to answer the quizzes (the email address where you received mails from me).","title":"Quizzes"},{"location":"Subjects/IOTNA/#schedule","text":"Day Topic Lab instructions Deliverable 20/10 Introduction: boards, SoC C Exercises 21/10 ESP-IDF environment Online DEMO 27/10 ESP-IDF 1. Starting ESP-IDF 28/10 ESP32 Memory map 1. Starting ESP-IDF 03/11 ESP-IDF Tasks Scheduler 2. Tasks: matrix multiply 04/11 ESP-IDF Tasks Scheduler 2. Tasks: matrix multiply 10/11 Events and task notifications 2. Tasks: matrix multiply 11/11 Input/Output - Polling/Interrupts - GPIO 3. Chronometer 17/11 Timers 3. Chronometer 18/11 Event based programming 3. Chronometer Lab 2 deadline 24/11 Event based programming. NAND/NOR Flash 3. Chronometer 25/11 File system . System Log 4. Log in flash 01/12 Watchdog 4. Log in flash Lab 3 deadline 02/12 Sensors . 4. Log in flash 08/12 NO LECTURE (non working day) Spain National Holiday 09/12 Serial buses: I2C, SPI, UART 4. Log in flash 15/12 QUIZ . ESP-IDF I2C API 5. Built-in sensors . HTS221 Datasheet Lab4 deadline 16/12 I2C 5. Built-in sensors . HTS221 Datasheet 22/12 Energy consumption . Powering the system 5. Built-in sensors 23/12 QUIZ . ESP32 power modes 6. Low power modes Labs 5 deadline 12/01 Final Programming project (groups of 2) 7. Final Project Paper project deadline 13/01 QUIZ . Final Programming project 7. Final Project Lab 6 deadline The final programming project, will be due before 24th Jan. 2022","title":"Schedule"},{"location":"Subjects/IOTNA/groups/","text":"Groups for lecture assignments As explained during last lectures, we will be forming stable groups to work during lectures (and after class). Group 1 Rol Full name Speaker Ayiqiqieke Kaisaier Speaker (2) Youran Tian Recorder Jun Shou Auditor TangRenJie Contributor Yang Chu Contributor Shuishi Zhou Group 2 This group is randomly assigned, since I had no notice from any of the integrants. Rol Full name Speaker BIN ZHANG Recorder FENGFENG GU Auditor GONGLU ZOU Contributor HONGBIAO CAO Contributor WENYAN LIAO Group 3 Rol Full name Speaker Duan Zhen Recorder Hu Haho Auditor Liu Jinhua Contributor Weilin Zhang Contributor Huang Yujuan Group 4 Rol Full name Speaker GuanJIE Xiao Speaker (2) DongYang Xu Recorder ShaYuan Shuang Auditor Junyan Guo Contributor Zhijun Hao Contributor Xueqing Zhao Contributor Jiali Gao Group 5 This group is randomly assigned, since I had no notice from any of the integrants. Rol Full name Speaker JIEPING YOU Recorder QINGHONG YU Auditor SUIZHI LIU Contributor TIANFENG LI Contributor WEI REN Contributor XIAZU HU Group 6 Rol Full name Speaker ZHOU Ping Speaker (2) LIAO Yinghua Recorder ZHAO Yan Auditor HE Yongtao Contributor PAN Jiayun Contributor Zhao Hu Contributor ZHANG Yi Group 7 This group is canceled. Previous members have been distributed in other groups. Group 8 Rol Full name Speaker Xiaolan Li Recorder Qiuji Chen Auditor Xionglan Luo Contributor Jianchuang Zhang","title":"Groups for lecture assignments"},{"location":"Subjects/IOTNA/groups/#groups-for-lecture-assignments","text":"As explained during last lectures, we will be forming stable groups to work during lectures (and after class).","title":"Groups for lecture assignments"},{"location":"Subjects/IOTNA/groups/#group-1","text":"Rol Full name Speaker Ayiqiqieke Kaisaier Speaker (2) Youran Tian Recorder Jun Shou Auditor TangRenJie Contributor Yang Chu Contributor Shuishi Zhou","title":"Group 1"},{"location":"Subjects/IOTNA/groups/#group-2","text":"This group is randomly assigned, since I had no notice from any of the integrants. Rol Full name Speaker BIN ZHANG Recorder FENGFENG GU Auditor GONGLU ZOU Contributor HONGBIAO CAO Contributor WENYAN LIAO","title":"Group 2"},{"location":"Subjects/IOTNA/groups/#group-3","text":"Rol Full name Speaker Duan Zhen Recorder Hu Haho Auditor Liu Jinhua Contributor Weilin Zhang Contributor Huang Yujuan","title":"Group 3"},{"location":"Subjects/IOTNA/groups/#group-4","text":"Rol Full name Speaker GuanJIE Xiao Speaker (2) DongYang Xu Recorder ShaYuan Shuang Auditor Junyan Guo Contributor Zhijun Hao Contributor Xueqing Zhao Contributor Jiali Gao","title":"Group 4"},{"location":"Subjects/IOTNA/groups/#group-5","text":"This group is randomly assigned, since I had no notice from any of the integrants. Rol Full name Speaker JIEPING YOU Recorder QINGHONG YU Auditor SUIZHI LIU Contributor TIANFENG LI Contributor WEI REN Contributor XIAZU HU","title":"Group 5"},{"location":"Subjects/IOTNA/groups/#group-6","text":"Rol Full name Speaker ZHOU Ping Speaker (2) LIAO Yinghua Recorder ZHAO Yan Auditor HE Yongtao Contributor PAN Jiayun Contributor Zhao Hu Contributor ZHANG Yi","title":"Group 6"},{"location":"Subjects/IOTNA/groups/#group-7","text":"This group is canceled. Previous members have been distributed in other groups.","title":"Group 7"},{"location":"Subjects/IOTNA/groups/#group-8","text":"Rol Full name Speaker Xiaolan Li Recorder Qiuji Chen Auditor Xionglan Luo Contributor Jianchuang Zhang","title":"Group 8"},{"location":"Subjects/IOTNA/paperProject/","text":"Personal paper project As I explained the first day of course (and you can find in the provided slides), you need to develop a personal (individual) paper project . Here I copy the guidelines that you can also find in the SoC slides Deadline Originally 20th Dec. EXTENDED deadline to 10th January 2022. Project description First, you need to imagine a specific scenario where IoT could help. Think on a small application of any typical IoT use case (smart cities, home automation, eHealth, smart agriculture...). Then you need to perform a theoretical study about the required hardware components, including: Which node would you buy? Which SoC? Which prototype board for the initial tests? Include several candidates in your study and motivate why you choose one of them Which sensors do you require? You need to specify which kind of sensor and also which exact model How much computation would you need to perform in the node? Which RTOS (Real Time Operating System)? Which IDE to develop? Which are the communication requirements? (how often do you communicate data, how much data...) Where will be energy spent? How are you powering the system? Think about the final packaging of the system (a plastic box built with a 3D printer? Any specific material?) Include the (approximate) total budget. Include links to online shops where you could buy the material IMPORTANTE: there is NO code to be develop. Only paper work. Work extension You need to motivate each decision (why do you choose a specific SoC and not another one?) but I do not expect the work to be extra-long. Definitely no more than 10 pages . Delivering the project Once finished, please send me an email (to jigomez@ucm.es)","title":"Personal paper project"},{"location":"Subjects/IOTNA/paperProject/#personal-paper-project","text":"As I explained the first day of course (and you can find in the provided slides), you need to develop a personal (individual) paper project . Here I copy the guidelines that you can also find in the SoC slides","title":"Personal paper project"},{"location":"Subjects/IOTNA/paperProject/#deadline","text":"Originally 20th Dec. EXTENDED deadline to 10th January 2022.","title":"Deadline"},{"location":"Subjects/IOTNA/paperProject/#project-description","text":"First, you need to imagine a specific scenario where IoT could help. Think on a small application of any typical IoT use case (smart cities, home automation, eHealth, smart agriculture...). Then you need to perform a theoretical study about the required hardware components, including: Which node would you buy? Which SoC? Which prototype board for the initial tests? Include several candidates in your study and motivate why you choose one of them Which sensors do you require? You need to specify which kind of sensor and also which exact model How much computation would you need to perform in the node? Which RTOS (Real Time Operating System)? Which IDE to develop? Which are the communication requirements? (how often do you communicate data, how much data...) Where will be energy spent? How are you powering the system? Think about the final packaging of the system (a plastic box built with a 3D printer? Any specific material?) Include the (approximate) total budget. Include links to online shops where you could buy the material IMPORTANTE: there is NO code to be develop. Only paper work.","title":"Project description"},{"location":"Subjects/IOTNA/paperProject/#work-extension","text":"You need to motivate each decision (why do you choose a specific SoC and not another one?) but I do not expect the work to be extra-long. Definitely no more than 10 pages .","title":"Work extension"},{"location":"Subjects/IOTNA/paperProject/#delivering-the-project","text":"Once finished, please send me an email (to jigomez@ucm.es)","title":"Delivering the project"},{"location":"Subjects/IOTNA/P1/","text":"Introduction to ESP-IDF and Platform IO. First project Goals Build your first project using PlatformIO Connect your ESP32 meshkit-sense board to the computer and upload a simple application Monitor your application using the serial port Create a PlatformIO project Whenever you want to create a new project, you can add it using the PlatformIO interface. First, click the PlatformIo Home icon: From the \"PIO Home\" tab, select \"New Project\" and the Project Wizard window will show up: In that window: Write your project name (do not use white spaces) Select Espressif ESP32 Dev Module as Board Select Espressif IoT Development framework as Framework If you want to choose an ad-hoc location for your project, unselect Use default location Press Finish You are done! Your first ESP-IDF project in PlatformIO is already created. Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know. Project configuration Before proceeding with the application coding, you should configure the project so the framework knows where to find the device and how to communicate with it. There are two main options that we need to specify in the project configuration. Follow the next steps to do it; Double click the file platformio.ini to open it in the editor. By default it has three options included: platform , board , framework . We are going to include two more below those three: monitor_speed = 115200 upload_port = /tty/USB1 Note that the upload_port specified above is the one used by default in the Virtual Machine provided. If you are not using it, make sure you write the correct port name. Including source code The new project will automatically create a src folder, including a default main.c file with the following content: void app_main() { } We are going to write a very simple Hello World application. Write the following code in main.c file: #include <stdio.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" void app_main(void) { while (1) { printf(\"Hello world!\\n\"); vTaskDelay(1000 / portTICK_PERIOD_MS); } vTaskDelete(NULL); } Once you have written the source code, you can proceed to build the project. To do so, you can display the Project Tasks ( View->Command Palette ) and execute PlatformIO: Build . You could also press the Build button ( check button in the bottom pane). If the building process works ok (it may take a few minutes the first time) you should see a message similar to: Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know. Flashing the project Once we have our application built (note that our source code is linked with the whole ESP-IDF environment, including FreeRTOS ), we are ready to upload it to our ESP32 device (this operation is commonly known as flash because we will be writing the binary file in flash memory). First, plug the ESP32 MeshKit to the ESP-Prog board with the provided connection. Then, connect the microUSB wire to the corresponding ESP-Prog port and plug the USB end of the wire to your computes USB port. If you are using a virtual machine, you will need to claim the device from the virtual machine, as the host will very likely keep the device by default. Once you are done physically connecting the devices, you can proceed with the uploading. You can use the PlatformIO: Upload task from Project Tasks or click in the corresponding button of the bottom pane: Monitoring the project Finally, you can open a serial connection from your computer to the device to monitor the progress. You can select PlatformIO: Monitor from the Project Tasks or click the plug button in the bottom pane: Once done, you should see the message *Hello World\" in your screen once every second. Congrats! You have uploaded your first ESP32 project! Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know. Tasks / Homework (28/10/2021) Task Keep a snapshot of your screen at the end of every section (i.e. whenever a Stop and Sync message appears in these instructions) and paste them in a PDF file including the information of your group (names of each of the members of the group). Send the PDF file to the instructor (jigomez@ucm.es) by the end of this session (just one file per group). Homework Modify the Hello World project so that it prints 10 messages, then it waits for 5 seconds and finally restarts the system. You can find which function you could use for the reset in the official ESP-IDF documentation . Send the modified source code (only the file main.c ) to the instructor before the start of next session (just one file per group). Extra (OPTIONAL): Memory Map Our ESP32 has several memory types (details can be found in this link and with more details in the Technical Reference Manuel (Chapter 1) Most of the code will be placed in the external, flash based memory (SPI flash). But we can also used some other modules. The most relevant are: Data RAM . Global variables (non-constant) are assigned to this SRAM (Static RAM) memory. Remaining space in this region is used for the runtime heap. This space is mapped to the Internal SRAM 2 (200KB) starting at address 0x3FFA_E000 and could also use Internal SRAM 1 (128KB) starting at 0x3FFE_0000. Note that SRAM1 could be also used as instruction memory. DROM (data stored in Flash). By default, constant data is placed by the linker into a region mapped to the MMU flash cache. Instruction RAM ESP-IDF allocates part of Internal SRAM0 region for instruction RAM. It allows us to use the range 0x4008_0000 to 0x400A_0000 to store parts of the application which need to run from RAM instead of Flash (for example, interrupt handlers are good candidates since they need to run as fast as possible). In order to place code in IRAM we may use the IRAM_ATTR macro: #include \"esp_attr.h\" void IRAM_ATTR gpio_isr_handler(void* arg) { // ... } Heap memory allocation Since FreeRTOS is mult-threaded, each RTOS task has its own stack. By default, each of these stacks is allocated from the heap when the task is created. Since there are multiple types of RAM, there are also several heaps with different capabilities. Most of the time, you can rely in the standard libc calls ( malloc() , free() ....). But you may explicitly ask for certain capabilities when allocating memory using heap_caps_malloc() . Please check the documentation in this link for more details Homework (Optional) Create a new project to explore the addresses of different variables. Declare different variables: g lobal variables with initial value, global variables without initial value, global const variables, local variables (stack), allocate memory in the heap using both malloc() and heap_caps_malloc() and try to allocate some function in IRAM. Then print the address of all these symbols (variables, functions...) and check in which memories they are actually allocated.","title":"Introduction to ESP-IDF and Platform IO. First project"},{"location":"Subjects/IOTNA/P1/#introduction-to-esp-idf-and-platform-io-first-project","text":"","title":"Introduction to ESP-IDF and Platform IO. First project"},{"location":"Subjects/IOTNA/P1/#goals","text":"Build your first project using PlatformIO Connect your ESP32 meshkit-sense board to the computer and upload a simple application Monitor your application using the serial port","title":"Goals"},{"location":"Subjects/IOTNA/P1/#create-a-platformio-project","text":"Whenever you want to create a new project, you can add it using the PlatformIO interface. First, click the PlatformIo Home icon: From the \"PIO Home\" tab, select \"New Project\" and the Project Wizard window will show up: In that window: Write your project name (do not use white spaces) Select Espressif ESP32 Dev Module as Board Select Espressif IoT Development framework as Framework If you want to choose an ad-hoc location for your project, unselect Use default location Press Finish You are done! Your first ESP-IDF project in PlatformIO is already created. Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know.","title":"Create a PlatformIO project"},{"location":"Subjects/IOTNA/P1/#project-configuration","text":"Before proceeding with the application coding, you should configure the project so the framework knows where to find the device and how to communicate with it. There are two main options that we need to specify in the project configuration. Follow the next steps to do it; Double click the file platformio.ini to open it in the editor. By default it has three options included: platform , board , framework . We are going to include two more below those three: monitor_speed = 115200 upload_port = /tty/USB1 Note that the upload_port specified above is the one used by default in the Virtual Machine provided. If you are not using it, make sure you write the correct port name.","title":"Project configuration"},{"location":"Subjects/IOTNA/P1/#including-source-code","text":"The new project will automatically create a src folder, including a default main.c file with the following content: void app_main() { } We are going to write a very simple Hello World application. Write the following code in main.c file: #include <stdio.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" void app_main(void) { while (1) { printf(\"Hello world!\\n\"); vTaskDelay(1000 / portTICK_PERIOD_MS); } vTaskDelete(NULL); } Once you have written the source code, you can proceed to build the project. To do so, you can display the Project Tasks ( View->Command Palette ) and execute PlatformIO: Build . You could also press the Build button ( check button in the bottom pane). If the building process works ok (it may take a few minutes the first time) you should see a message similar to: Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know.","title":"Including source code"},{"location":"Subjects/IOTNA/P1/#flashing-the-project","text":"Once we have our application built (note that our source code is linked with the whole ESP-IDF environment, including FreeRTOS ), we are ready to upload it to our ESP32 device (this operation is commonly known as flash because we will be writing the binary file in flash memory). First, plug the ESP32 MeshKit to the ESP-Prog board with the provided connection. Then, connect the microUSB wire to the corresponding ESP-Prog port and plug the USB end of the wire to your computes USB port. If you are using a virtual machine, you will need to claim the device from the virtual machine, as the host will very likely keep the device by default. Once you are done physically connecting the devices, you can proceed with the uploading. You can use the PlatformIO: Upload task from Project Tasks or click in the corresponding button of the bottom pane:","title":"Flashing the project"},{"location":"Subjects/IOTNA/P1/#monitoring-the-project","text":"Finally, you can open a serial connection from your computer to the device to monitor the progress. You can select PlatformIO: Monitor from the Project Tasks or click the plug button in the bottom pane: Once done, you should see the message *Hello World\" in your screen once every second. Congrats! You have uploaded your first ESP32 project! Stop and Sync If you reach this step, please contact the instructor in the chat to let him/her know.","title":"Monitoring the project"},{"location":"Subjects/IOTNA/P1/#tasks-homework-28102021","text":"Task Keep a snapshot of your screen at the end of every section (i.e. whenever a Stop and Sync message appears in these instructions) and paste them in a PDF file including the information of your group (names of each of the members of the group). Send the PDF file to the instructor (jigomez@ucm.es) by the end of this session (just one file per group). Homework Modify the Hello World project so that it prints 10 messages, then it waits for 5 seconds and finally restarts the system. You can find which function you could use for the reset in the official ESP-IDF documentation . Send the modified source code (only the file main.c ) to the instructor before the start of next session (just one file per group).","title":"Tasks / Homework (28/10/2021)"},{"location":"Subjects/IOTNA/P1/#extra-optional-memory-map","text":"Our ESP32 has several memory types (details can be found in this link and with more details in the Technical Reference Manuel (Chapter 1) Most of the code will be placed in the external, flash based memory (SPI flash). But we can also used some other modules. The most relevant are: Data RAM . Global variables (non-constant) are assigned to this SRAM (Static RAM) memory. Remaining space in this region is used for the runtime heap. This space is mapped to the Internal SRAM 2 (200KB) starting at address 0x3FFA_E000 and could also use Internal SRAM 1 (128KB) starting at 0x3FFE_0000. Note that SRAM1 could be also used as instruction memory. DROM (data stored in Flash). By default, constant data is placed by the linker into a region mapped to the MMU flash cache. Instruction RAM ESP-IDF allocates part of Internal SRAM0 region for instruction RAM. It allows us to use the range 0x4008_0000 to 0x400A_0000 to store parts of the application which need to run from RAM instead of Flash (for example, interrupt handlers are good candidates since they need to run as fast as possible). In order to place code in IRAM we may use the IRAM_ATTR macro: #include \"esp_attr.h\" void IRAM_ATTR gpio_isr_handler(void* arg) { // ... }","title":"Extra (OPTIONAL): Memory Map"},{"location":"Subjects/IOTNA/P1/#heap-memory-allocation","text":"Since FreeRTOS is mult-threaded, each RTOS task has its own stack. By default, each of these stacks is allocated from the heap when the task is created. Since there are multiple types of RAM, there are also several heaps with different capabilities. Most of the time, you can rely in the standard libc calls ( malloc() , free() ....). But you may explicitly ask for certain capabilities when allocating memory using heap_caps_malloc() . Please check the documentation in this link for more details Homework (Optional) Create a new project to explore the addresses of different variables. Declare different variables: g lobal variables with initial value, global variables without initial value, global const variables, local variables (stack), allocate memory in the heap using both malloc() and heap_caps_malloc() and try to allocate some function in IRAM. Then print the address of all these symbols (variables, functions...) and check in which memories they are actually allocated.","title":"Heap memory allocation"},{"location":"Subjects/IOTNA/P2/","text":"Task management in FreeRTOS (ESP-IDF) Goals Learn the task related API offered by ESP-IDF Create multi-tasked applications where tasks effectively cooperate to a common goal. Matrix multiplication Matrix multiplication is a key kernel in many applications (for example, in Neural Network training and inference). It is an example of a massively parallel computation, where all the elements of the output matrix ( C in the image below) can be computed in parallel. The most basic pseudo-code of the matrix multiplication is shown below: for i = 0 to N for j = 0 to M C[i][j] = 0 for k=0 to K C[i][j] += A[i][k]*B[k][j] where loops i and j are fully parallel. Assignment 1 Create a new project and write a function that will multiply two matrix (received as input arguments) and write the result in a third matrix (also provided as argument). You can choose N=8, M= 8, K =8 and uint32_t as element type. To make it easier to check the output, you can initialize B matrix as the identity matrix. Please send a message to the professor as soon as you finished Simple parallelisation In this exercise you will create two tasks. The first task will process the even rows of A ( i=0,2,4,6... ) and the second task will take care of the even rows. The main task (the one executing app_main() ) will simply create both task and then destroy itself. Assignment 2 Create a new project and implement the simple parallelization. Check the result with your previous sequential version. Please send a message to the professor as soon as you finished Work dispatching In this last (optional) exercise, you will implement a different parallelisation strategy: a Controller task ) will write pairs in a queue (from 0 to N-1). A set of Worker tasks will read from that queue, obtain one pair and multiply row i of matrix A by column j of matrix B, and write the result as element [i,j] of matrix C. The Controller task will insert all the pairs in the queue and then wait in a semaphore for the Worker tasks to complete. Homework (Optional) Create a new project and implement this alternative. Try creating a different number of Worker tasks (from 1 to 4, for example) and measure the execution time. You may use esp_timer_get_time() to compute the total time.","title":"Task management in FreeRTOS (ESP-IDF)"},{"location":"Subjects/IOTNA/P2/#task-management-in-freertos-esp-idf","text":"","title":"Task management in FreeRTOS (ESP-IDF)"},{"location":"Subjects/IOTNA/P2/#goals","text":"Learn the task related API offered by ESP-IDF Create multi-tasked applications where tasks effectively cooperate to a common goal.","title":"Goals"},{"location":"Subjects/IOTNA/P2/#matrix-multiplication","text":"Matrix multiplication is a key kernel in many applications (for example, in Neural Network training and inference). It is an example of a massively parallel computation, where all the elements of the output matrix ( C in the image below) can be computed in parallel. The most basic pseudo-code of the matrix multiplication is shown below: for i = 0 to N for j = 0 to M C[i][j] = 0 for k=0 to K C[i][j] += A[i][k]*B[k][j] where loops i and j are fully parallel. Assignment 1 Create a new project and write a function that will multiply two matrix (received as input arguments) and write the result in a third matrix (also provided as argument). You can choose N=8, M= 8, K =8 and uint32_t as element type. To make it easier to check the output, you can initialize B matrix as the identity matrix. Please send a message to the professor as soon as you finished","title":"Matrix multiplication"},{"location":"Subjects/IOTNA/P2/#simple-parallelisation","text":"In this exercise you will create two tasks. The first task will process the even rows of A ( i=0,2,4,6... ) and the second task will take care of the even rows. The main task (the one executing app_main() ) will simply create both task and then destroy itself. Assignment 2 Create a new project and implement the simple parallelization. Check the result with your previous sequential version. Please send a message to the professor as soon as you finished","title":"Simple parallelisation"},{"location":"Subjects/IOTNA/P2/#work-dispatching","text":"In this last (optional) exercise, you will implement a different parallelisation strategy: a Controller task ) will write pairs in a queue (from 0 to N-1). A set of Worker tasks will read from that queue, obtain one pair and multiply row i of matrix A by column j of matrix B, and write the result as element [i,j] of matrix C. The Controller task will insert all the pairs in the queue and then wait in a semaphore for the Worker tasks to complete. Homework (Optional) Create a new project and implement this alternative. Try creating a different number of Worker tasks (from 1 to 4, for example) and measure the execution time. You may use esp_timer_get_time() to compute the total time.","title":"Work dispatching"},{"location":"Subjects/IOTNA/P3/","text":"Basic Input/output in ESP-IDF Goals Learn the basics of input/output, using polling and interrupts Configuring and use GPIO pins as input/output Program timers to schedule periodic events Documentation To complete this assignment, you may need to check the slides discuss in the lectures and the official API documentation: GPIO * Timers Using GPIO Checking connections The first step when using external peripherals connected to our SoC (ESP32) is to learn how are they connected. The module exposes a series of pines from the core and the operating system (ESP-IDF) assigns them a number. We need then to find out which pin number correspond to every relevant connection to us. In this fist step, you must find out the GPIO number for the button and LED. The information is usually included in the documentation of the SoC and the board: we need to check both, the SoC and the board. In our case, part of the information may be found in the brief online documentation . If you don't find all the information there, try to look it up carefully in the board itself. Sometimes, this information is printed on the PCB... Simple GPIO polling: button The next step will be to set up the button to use it as an input for our system. First, you will need to configure the GPIO pin: Configure the pin as INPUT. Disable interrupts. Enable pull-ip mode. Check the slides and documentation to learn how to do this configuration in ESP-IDF. Remember that you need to declare a variable of type gpio_config_t , assign the relevant fields of such variable and finally call gpio_config( ) to complete the configuration. Once the configuration of the GPIO is done, you can write a simple sampling loop. Write and endless while loop where you poll the status of the button, print a message if the button is pressed and wait for 250ms before polling again. A pseudo-code for such loop could be the following: while (1) { int status = gpio_get_level(GPIO_BUTTON_PIN); if (status == BUTTON_PRESSED) printf(\"Button pressed!!\\n\"); delay(250); } GPIO input and output: button + LED In the next step, you will configure a GPIO pin as an output in order to control the LEDs. Similar to the button configuration, the first step is to configure the respective pins (there are two LEDs available): Configure the pin(s) as OUTPUT. Disable interrupts. Disable pull-up and pull-down modes. Remember to use a variable of type gpio_config_t and complete the configuration with a call to gpio_config( ) . Once both the three pins (one input, two outputs) are correctly configured, you will develop a very simple program that will switch one of the LEDs (on/off) every time the button is pressed. The pseudo-code may be similar to: while (1) { int status = gpio_get_level(GPIO_BUTTON_PIN); if (status == BUTTON_PRESSED) { if LED_IS_ON gpio_set_level(GPIO_LED_PIN, OFF); else gpio_set_level(GPIO_LED_PIN, ON); } delay(250); } Stop and sync Please send a message in Zoom chat to the professor as soon as you finished GPIO interrupts In this subsection you will change the polling mechanism and use interrupts instead. Starting from the configuration you already have for the button GPIO pin, you need to do certain modifications: Enable interrupts (for example, POSEDGE ). You may change the edge/level later using gpio_set_intr_type() . Register the ISR that will be executed when the interrupt rises. You will need to call gpio_install_isr_service() and gpio_isr_handler_add . Once the new configuration is done, you need to write the ISR for the button interrupts. Remember to use the correct protoype: static void IRAM_ATTR gpio_isr_handler(void* arg) (you may change the name of the ISR itself, but not its prototype). Finally, adapt the previous code (LED switching) to work with the new code. How are you going to notify you main loop about a new interrupt? Extending button functionality Just to play a bit longer with interrupts, let's extend the functionality of our application. Adapt your code so you can identify if the button was pressed normally or if it was hold at least for 4 seconds: If the button was just pressed (less than 4 seconds) you will switch the green LED. If the button was pressed and hold for more than 4 seconds, you will switch the red LED. Note that, if both LEDs are on, you will see a yellow light. Stop and sync Please send a message (using Zoom) to the professor as soon as you finished. Timers Now we will include timers in our design. Read again the slides and API documentation to remember how to declare and configure a timer in ESP-IDF. LED blink Then, create a timer that will blink the red LED every second (i.e. the red LED will be on for one second, then off for another second and so on). The green LED will still be controlled with the button (but keep your code detecting when the button was pressed for more than 4 seconds; you will use it later). Controlling blinking frequency We will define several blinking periods: 500ms, 1s or 2s. When your program starts, the red LED will be blinking every 500ms. Then, your code must do the following: When the button is pressed, the period will increase, first to 1 second, then to 2 seconds. If the button is pressed when the period is already 2 seconds, nothing changes. When the button is held pressed for more than 4 seconds, the period will decrease (from 2s to 1s and then to 500ms). If the button is held pressed for more than 4 seconds when the period is 500ms, nothing changes. Stop and sync All previous exercises must be finished DURING the lecture (not afterwards) and shown to the teacher during the Zoom meeting. AFTER they are shown to be working during the lecture, the Recorder of the group will send an email with the source code of the last section ( Controlling blinking frequency ). Remind that plagiarism is strictly prohibited: the code of each group must be solely developed by members of that group. Chronometer (optional) This assignment is optional, but required if you want to obtain more than 6 / 10 in this assignment. You will need to implement a simple chronometer with the following functionality: The chronometer counts minutes and seconds. Pressing the button starts/stops counting. Holding pressed the button for more than 4 seconds resets the count to 0. Every second, the actual count (in a format MM:SS) will be shown in the terminal (using printf() ). Homework (Optional) Implement the chronometer using, at least, one timer . Once finished, the Speaker will contact me to explain (orally) the code developed","title":"Basic Input/output in ESP-IDF"},{"location":"Subjects/IOTNA/P3/#basic-inputoutput-in-esp-idf","text":"","title":"Basic Input/output in ESP-IDF"},{"location":"Subjects/IOTNA/P3/#goals","text":"Learn the basics of input/output, using polling and interrupts Configuring and use GPIO pins as input/output Program timers to schedule periodic events","title":"Goals"},{"location":"Subjects/IOTNA/P3/#documentation","text":"To complete this assignment, you may need to check the slides discuss in the lectures and the official API documentation: GPIO * Timers","title":"Documentation"},{"location":"Subjects/IOTNA/P3/#using-gpio","text":"","title":"Using GPIO"},{"location":"Subjects/IOTNA/P3/#checking-connections","text":"The first step when using external peripherals connected to our SoC (ESP32) is to learn how are they connected. The module exposes a series of pines from the core and the operating system (ESP-IDF) assigns them a number. We need then to find out which pin number correspond to every relevant connection to us. In this fist step, you must find out the GPIO number for the button and LED. The information is usually included in the documentation of the SoC and the board: we need to check both, the SoC and the board. In our case, part of the information may be found in the brief online documentation . If you don't find all the information there, try to look it up carefully in the board itself. Sometimes, this information is printed on the PCB...","title":"Checking connections"},{"location":"Subjects/IOTNA/P3/#simple-gpio-polling-button","text":"The next step will be to set up the button to use it as an input for our system. First, you will need to configure the GPIO pin: Configure the pin as INPUT. Disable interrupts. Enable pull-ip mode. Check the slides and documentation to learn how to do this configuration in ESP-IDF. Remember that you need to declare a variable of type gpio_config_t , assign the relevant fields of such variable and finally call gpio_config( ) to complete the configuration. Once the configuration of the GPIO is done, you can write a simple sampling loop. Write and endless while loop where you poll the status of the button, print a message if the button is pressed and wait for 250ms before polling again. A pseudo-code for such loop could be the following: while (1) { int status = gpio_get_level(GPIO_BUTTON_PIN); if (status == BUTTON_PRESSED) printf(\"Button pressed!!\\n\"); delay(250); }","title":"Simple GPIO polling: button"},{"location":"Subjects/IOTNA/P3/#gpio-input-and-output-button-led","text":"In the next step, you will configure a GPIO pin as an output in order to control the LEDs. Similar to the button configuration, the first step is to configure the respective pins (there are two LEDs available): Configure the pin(s) as OUTPUT. Disable interrupts. Disable pull-up and pull-down modes. Remember to use a variable of type gpio_config_t and complete the configuration with a call to gpio_config( ) . Once both the three pins (one input, two outputs) are correctly configured, you will develop a very simple program that will switch one of the LEDs (on/off) every time the button is pressed. The pseudo-code may be similar to: while (1) { int status = gpio_get_level(GPIO_BUTTON_PIN); if (status == BUTTON_PRESSED) { if LED_IS_ON gpio_set_level(GPIO_LED_PIN, OFF); else gpio_set_level(GPIO_LED_PIN, ON); } delay(250); } Stop and sync Please send a message in Zoom chat to the professor as soon as you finished","title":"GPIO input and output: button + LED"},{"location":"Subjects/IOTNA/P3/#gpio-interrupts","text":"In this subsection you will change the polling mechanism and use interrupts instead. Starting from the configuration you already have for the button GPIO pin, you need to do certain modifications: Enable interrupts (for example, POSEDGE ). You may change the edge/level later using gpio_set_intr_type() . Register the ISR that will be executed when the interrupt rises. You will need to call gpio_install_isr_service() and gpio_isr_handler_add . Once the new configuration is done, you need to write the ISR for the button interrupts. Remember to use the correct protoype: static void IRAM_ATTR gpio_isr_handler(void* arg) (you may change the name of the ISR itself, but not its prototype). Finally, adapt the previous code (LED switching) to work with the new code. How are you going to notify you main loop about a new interrupt?","title":"GPIO interrupts"},{"location":"Subjects/IOTNA/P3/#extending-button-functionality","text":"Just to play a bit longer with interrupts, let's extend the functionality of our application. Adapt your code so you can identify if the button was pressed normally or if it was hold at least for 4 seconds: If the button was just pressed (less than 4 seconds) you will switch the green LED. If the button was pressed and hold for more than 4 seconds, you will switch the red LED. Note that, if both LEDs are on, you will see a yellow light. Stop and sync Please send a message (using Zoom) to the professor as soon as you finished.","title":"Extending button functionality"},{"location":"Subjects/IOTNA/P3/#timers","text":"Now we will include timers in our design. Read again the slides and API documentation to remember how to declare and configure a timer in ESP-IDF.","title":"Timers"},{"location":"Subjects/IOTNA/P3/#led-blink","text":"Then, create a timer that will blink the red LED every second (i.e. the red LED will be on for one second, then off for another second and so on). The green LED will still be controlled with the button (but keep your code detecting when the button was pressed for more than 4 seconds; you will use it later).","title":"LED blink"},{"location":"Subjects/IOTNA/P3/#controlling-blinking-frequency","text":"We will define several blinking periods: 500ms, 1s or 2s. When your program starts, the red LED will be blinking every 500ms. Then, your code must do the following: When the button is pressed, the period will increase, first to 1 second, then to 2 seconds. If the button is pressed when the period is already 2 seconds, nothing changes. When the button is held pressed for more than 4 seconds, the period will decrease (from 2s to 1s and then to 500ms). If the button is held pressed for more than 4 seconds when the period is 500ms, nothing changes. Stop and sync All previous exercises must be finished DURING the lecture (not afterwards) and shown to the teacher during the Zoom meeting. AFTER they are shown to be working during the lecture, the Recorder of the group will send an email with the source code of the last section ( Controlling blinking frequency ). Remind that plagiarism is strictly prohibited: the code of each group must be solely developed by members of that group.","title":"Controlling blinking frequency"},{"location":"Subjects/IOTNA/P3/#chronometer-optional","text":"This assignment is optional, but required if you want to obtain more than 6 / 10 in this assignment. You will need to implement a simple chronometer with the following functionality: The chronometer counts minutes and seconds. Pressing the button starts/stops counting. Holding pressed the button for more than 4 seconds resets the count to 0. Every second, the actual count (in a format MM:SS) will be shown in the terminal (using printf() ). Homework (Optional) Implement the chronometer using, at least, one timer . Once finished, the Speaker will contact me to explain (orally) the code developed","title":"Chronometer (optional)"},{"location":"Subjects/IOTNA/P4/","text":"Logging and flash filesystem Goals Learn the logging mechanisms provided by ESP-IDF Create your own partitions in SPI FLASH memory Mount a filesystem in FLASH memory Documentation To complete this assignment, you may need to check the slides discuss in the lectures and the official API documentation: Log SPI Flash and partitions FAT filesystem Wear levelling API Logging to UART Basic logging Start from your basic (single-task) matrix multiply code (Lab 2). Insert ESP_LOG calls at least at 3 levels: ERROR, INFO and VERBOSE. Modify logging level via menuconfig Use menuconfig to select INFO as the minimum log level. Check that the VERBOSE messages are not shown Multimodule Create a new .c file in your project. Include there a couple of functions from your code. Remind to declare. a new TAG there. Include LOG macros in both files. Modify logging level at runtime Use esp_log_level_set() to set WARNING as the log level for the main file and VERBOSE for the other file. Check that the log output is correct. Stop and sync All previous exercises must be finished DURING the lecture (not afterwards) and shown to the teacher during the Zoom meeting. AFTER they are shown to be working during the lecture, the Recorder of the group will send an email with the source code of the last section ( Modify logging level at runtime ). Remind that plagiarism is strictly prohibited: the code of each group must be solely developed by members of that group. Mounting FAT filesystem In this step you will mount a FAT filesystem in a new partition created in the SPI FLASH existing in the board. Follow the example Wear Levelling ( [wear levelling example])https://github.com/espressif/esp-idf/tree/master/examples/storage/wear_levelling) ) and create a PlatformIO project to run it in your board: Create the PlatformIO project and copy the source code from the Wear Levelling example. Copy the file partitions_example.csv in the root folder of your project. Rename it as partitions.csv Modify the file platformio.ini to include: monitor_port = /dev/ttyUSB1 upload_port = /dev/ttyUSB1 board_build.partitions = partitions.csv Run menuconfig (type pio run -t menuconfig in a PlatformIO terminal) Partition Table --> PartitionTable --> Custom partition table CSV Check that the name of the Custom parition CSV file in menuconfig is partitions.csv Save the new configuration (press S ) and quit (press Q ) Build, upload and execute. Monitor the output and check that the messages are the ones expected. Questions Once you finished the code, try to answer the following questions. Include them in the report of this assignment. What is the name of the file you are creating in this example? What is the path of the file? Why? When was that folder created? What is the difference between printf() and fprintf() Why there are two calls to `fopen()? What is the difference between them? What is fgets() doing? Write a code that creates a new file called timestamp.txt whose content is a timestamp (time elapsed since boot). How can we later modify its content? Try to open a file after the call \u00e8sp_vfs_fat_spiflash_umount()*. What happens? Redirecting the log to FLASH (optional) This assignment is optional, but required if you want to obtain more than 6 / 10 in this assignment. Starting from your chronometer code (or equivalent), include LOG messages (using ESP_LOG macros) and redirect the log to a file called log.txt that you will create in a FAT partition in SPI FLAG. Use esp_log_set_vprintf() to do the redirection. You should LOG: Every 5 seconds of the chronometer running, you must LOG a message. Every time the button is pressed Every time there is a long press (more than 4 seconds). Note that you can still use printf() to write to the terminal. Also, after 1 minute of functioning, you will read the first 5 lines of the log file and write them to the terminal (using printf() ). Homework (Optional) Once finished, the Speaker will contact me to explain (orally) the code developed","title":"Logging and flash filesystem"},{"location":"Subjects/IOTNA/P4/#logging-and-flash-filesystem","text":"","title":"Logging and flash filesystem"},{"location":"Subjects/IOTNA/P4/#goals","text":"Learn the logging mechanisms provided by ESP-IDF Create your own partitions in SPI FLASH memory Mount a filesystem in FLASH memory","title":"Goals"},{"location":"Subjects/IOTNA/P4/#documentation","text":"To complete this assignment, you may need to check the slides discuss in the lectures and the official API documentation: Log SPI Flash and partitions FAT filesystem Wear levelling API","title":"Documentation"},{"location":"Subjects/IOTNA/P4/#logging-to-uart","text":"","title":"Logging to UART"},{"location":"Subjects/IOTNA/P4/#basic-logging","text":"Start from your basic (single-task) matrix multiply code (Lab 2). Insert ESP_LOG calls at least at 3 levels: ERROR, INFO and VERBOSE.","title":"Basic logging"},{"location":"Subjects/IOTNA/P4/#modify-logging-level-via-menuconfig","text":"Use menuconfig to select INFO as the minimum log level. Check that the VERBOSE messages are not shown","title":"Modify logging level via menuconfig"},{"location":"Subjects/IOTNA/P4/#multimodule","text":"Create a new .c file in your project. Include there a couple of functions from your code. Remind to declare. a new TAG there. Include LOG macros in both files.","title":"Multimodule"},{"location":"Subjects/IOTNA/P4/#modify-logging-level-at-runtime","text":"Use esp_log_level_set() to set WARNING as the log level for the main file and VERBOSE for the other file. Check that the log output is correct. Stop and sync All previous exercises must be finished DURING the lecture (not afterwards) and shown to the teacher during the Zoom meeting. AFTER they are shown to be working during the lecture, the Recorder of the group will send an email with the source code of the last section ( Modify logging level at runtime ). Remind that plagiarism is strictly prohibited: the code of each group must be solely developed by members of that group.","title":"Modify logging level at runtime"},{"location":"Subjects/IOTNA/P4/#mounting-fat-filesystem","text":"In this step you will mount a FAT filesystem in a new partition created in the SPI FLASH existing in the board. Follow the example Wear Levelling ( [wear levelling example])https://github.com/espressif/esp-idf/tree/master/examples/storage/wear_levelling) ) and create a PlatformIO project to run it in your board: Create the PlatformIO project and copy the source code from the Wear Levelling example. Copy the file partitions_example.csv in the root folder of your project. Rename it as partitions.csv Modify the file platformio.ini to include: monitor_port = /dev/ttyUSB1 upload_port = /dev/ttyUSB1 board_build.partitions = partitions.csv Run menuconfig (type pio run -t menuconfig in a PlatformIO terminal) Partition Table --> PartitionTable --> Custom partition table CSV Check that the name of the Custom parition CSV file in menuconfig is partitions.csv Save the new configuration (press S ) and quit (press Q ) Build, upload and execute. Monitor the output and check that the messages are the ones expected. Questions Once you finished the code, try to answer the following questions. Include them in the report of this assignment. What is the name of the file you are creating in this example? What is the path of the file? Why? When was that folder created? What is the difference between printf() and fprintf() Why there are two calls to `fopen()? What is the difference between them? What is fgets() doing? Write a code that creates a new file called timestamp.txt whose content is a timestamp (time elapsed since boot). How can we later modify its content? Try to open a file after the call \u00e8sp_vfs_fat_spiflash_umount()*. What happens?","title":"Mounting FAT filesystem"},{"location":"Subjects/IOTNA/P4/#redirecting-the-log-to-flash-optional","text":"This assignment is optional, but required if you want to obtain more than 6 / 10 in this assignment. Starting from your chronometer code (or equivalent), include LOG messages (using ESP_LOG macros) and redirect the log to a file called log.txt that you will create in a FAT partition in SPI FLAG. Use esp_log_set_vprintf() to do the redirection. You should LOG: Every 5 seconds of the chronometer running, you must LOG a message. Every time the button is pressed Every time there is a long press (more than 4 seconds). Note that you can still use printf() to write to the terminal. Also, after 1 minute of functioning, you will read the first 5 lines of the log file and write them to the terminal (using printf() ). Homework (Optional) Once finished, the Speaker will contact me to explain (orally) the code developed","title":"Redirecting the log to FLASH (optional)"},{"location":"Subjects/IOTNA/P5/","text":"Reading sensors using I2C Goals Learn to use the API provided by ESP-IDF for the I2C serial buses Read the temperature from sensor HTS221 in the board Documentation To complete this assignment, you may need to check the slides discussed in the lectures and the official API documentation: ESP-IDF API for I2C HTS221 sensor data sheet SoC reference Reading the temperature sensor Obtaining information about the sensor Using the data sheet, search the infomation required to read the sensor using I2C bus: slave address, addresses of the control registers, number of bytes needed to read the temperature. Using the information from the SoC and the pin numbers writen in the lower side of the board, find the information about: gpio pins connected to SDA, SCL and to the sensors VDD. Using the API reference, find how to perform a write and a read through I2C. Questions All previous exercises must be finished DURING the lecture (not afterwards) and shown to the teacher during the Zoom meeting. Reading the device identification In this step you will use the I2C bus to read the device identificaci\u00f3n of the temperature sensor, that is stored in its WHO_AM_I register. Note that you must write a 0 in the GPIO pin that controls the VDD signal of the sensors. If not, the sensors will be in power-off state. Stop and sycn Once you finished the code, show it to the teacher Reading the temperature from the sensor In this step you will use the I2C bus to read the raw temperature from the sensor. Stop and sycn Once you finished the code, show it to the teacher Reading the temperature in celsius (optional) This assignment is optional, but required if you want to obtain more than 6 / 10 in this assignment. Use the calibration mechanism to obtain the real value of temperature. Homework (Optional) Once finished, the Speaker will contact me to explain (orally) the code developed","title":"Reading sensors using I2C"},{"location":"Subjects/IOTNA/P5/#reading-sensors-using-i2c","text":"","title":"Reading sensors using I2C"},{"location":"Subjects/IOTNA/P5/#goals","text":"Learn to use the API provided by ESP-IDF for the I2C serial buses Read the temperature from sensor HTS221 in the board","title":"Goals"},{"location":"Subjects/IOTNA/P5/#documentation","text":"To complete this assignment, you may need to check the slides discussed in the lectures and the official API documentation: ESP-IDF API for I2C HTS221 sensor data sheet SoC reference","title":"Documentation"},{"location":"Subjects/IOTNA/P5/#reading-the-temperature-sensor","text":"","title":"Reading the temperature sensor"},{"location":"Subjects/IOTNA/P5/#obtaining-information-about-the-sensor","text":"Using the data sheet, search the infomation required to read the sensor using I2C bus: slave address, addresses of the control registers, number of bytes needed to read the temperature. Using the information from the SoC and the pin numbers writen in the lower side of the board, find the information about: gpio pins connected to SDA, SCL and to the sensors VDD. Using the API reference, find how to perform a write and a read through I2C. Questions All previous exercises must be finished DURING the lecture (not afterwards) and shown to the teacher during the Zoom meeting.","title":"Obtaining information about the sensor"},{"location":"Subjects/IOTNA/P5/#reading-the-device-identification","text":"In this step you will use the I2C bus to read the device identificaci\u00f3n of the temperature sensor, that is stored in its WHO_AM_I register. Note that you must write a 0 in the GPIO pin that controls the VDD signal of the sensors. If not, the sensors will be in power-off state. Stop and sycn Once you finished the code, show it to the teacher","title":"Reading the device identification"},{"location":"Subjects/IOTNA/P5/#reading-the-temperature-from-the-sensor","text":"In this step you will use the I2C bus to read the raw temperature from the sensor. Stop and sycn Once you finished the code, show it to the teacher","title":"Reading the temperature from the sensor"},{"location":"Subjects/IOTNA/P5/#reading-the-temperature-in-celsius-optional","text":"This assignment is optional, but required if you want to obtain more than 6 / 10 in this assignment. Use the calibration mechanism to obtain the real value of temperature. Homework (Optional) Once finished, the Speaker will contact me to explain (orally) the code developed","title":"Reading the temperature in celsius (optional)"},{"location":"Subjects/IOTNA/P6/","text":"Lab 6. Energy saving modes Goals Learn the mechanisms provided by ESP-IDF to exploit the different energy modes existing in ESP32 SoCs: Explicit moving into light sleep and deep sleep modes Discover wakeup reasons. Configuring and using the automatic power manager in ESP-IDF. Documentation To complete this assignment, you may need to check the slides discuss in the lectures and the official API documentation: Sleep modes Power manager It is also relevant to check the examples provided in GitHub: Light sleep Deep sleep Wifi Power save Explicitly moving to low power modes We will start from a basic code monitoring any input device (like the button or the temperature sensor), where the main program is in an endless loop reading, periodically, the device status. The structure of the starting code could be similar to: while (1) { med = read_device(); // Could be button, sensor... ESP_LOGI(TAG,\"Medida: %f\", med); vTaskDelay(pdMS_TO_TICKS(DELAY)); } Implement the following modifications: Include a explicit call to enter light sleep after 5 iterations. Previously, you will configure the wakeup mechanism to be the timer and instruct it to wake the system up after 10 seconds. Repeat the previous point but entering deep sleep Include code to determine the cause of the wakeup for both previous cases. Questions What difference do you observe when entering deep sleep compared with light sleep ? What does it happen after 10 seconds in each case? Where do you need to include the code to determine the wakeup cause in each of the two cases? Using the Power Manager Starting from the same simple code of previous section, we will be using the Power Manager provided by ESP-IDF. In order to do so, we must enable Dynamic frequency scaling (DFS). We can enable it with menuconfig -> Component config -> Power Management -> Support for Power Management -> Enable DFS at startup . It is also possible to configure it in our own code using the call esp_pm_configure() . You will use this latter method ( esp_pm_configure() ) and define: * Max. frequency of 240MHz * Min. frequency of 40MHz * Enable automatic entering light sleep mode To enable automatic entering light sleep mode we must activate the corresponding option in menuconfig : Component config -> FreeRTOS -> Tickless Idle Support (this option is only visible if the Enable DFS at startup option is also enabled). Following the earlier pseudo-code, modify your code in order to guess the wakeup cause. The structure of code could be now similar to: while (1) { med = read_device(); // Could be button, sensor... ESP_LOGI(TAG,\"Medida: %f\", med); vTaskDelay(pdMS_TO_TICKS(DELAY)); cause = get_wakeup_cause(); } Questions Which mechanism is waking the system up when using the Power Manager ? Using High Resolution Timers (OPTIONAL) Modify your code to monitor the device (sensor, button...) using a High Resolution Timer instead of using the call to vTaskDelay(pdMS_TO_TICKS(DELAY)) . The main task will configure the high resolution timer and then go to sleep for 100 seconds in and endless loop. Entering light sleep mode manually Modify your code to enter light sleep mode (calling esp_light_sleep_start() ) after 3 executions of the high resolution timer callback. Set the high resolution timer to trigger every 3 seconds, and program the system to wake up after 10 seconds. Include a log message in the callback function which prints the number of times the callback function has been called. Questions Call esp_light_sleep_start() outside the callback function of the high resolution timer. What happens when the system wakes up? Are there log messages lost? Do they happen when they should happen? No call esp_light_sleep_start() inside the callback function of the high resolution timer. Do you observe any difference? Automatically entering light sleep mode Repeat previous experiments using the Power Manager. Questions Note that, since you do not manually enter the sleep mode, you will not move into light sleep after 3 executions of the high resolution timer. When is the system moving to light sleep ? What happens with the callback log messages? Do they happen when they should happen? Delivering the assignment Once you finish the complete assignment (at least the first two sections), please send an email to Prof. Jose Ignacio (jigomez@ucm.es) with the codes develop for each section and a text file (text or PDF) with your answers to the questions. Please send only one email per group. DEADLINE: 12th January 2022","title":"Lab 6. Energy saving modes"},{"location":"Subjects/IOTNA/P6/#lab-6-energy-saving-modes","text":"","title":"Lab 6. Energy saving modes"},{"location":"Subjects/IOTNA/P6/#goals","text":"Learn the mechanisms provided by ESP-IDF to exploit the different energy modes existing in ESP32 SoCs: Explicit moving into light sleep and deep sleep modes Discover wakeup reasons. Configuring and using the automatic power manager in ESP-IDF.","title":"Goals"},{"location":"Subjects/IOTNA/P6/#documentation","text":"To complete this assignment, you may need to check the slides discuss in the lectures and the official API documentation: Sleep modes Power manager It is also relevant to check the examples provided in GitHub: Light sleep Deep sleep Wifi Power save","title":"Documentation"},{"location":"Subjects/IOTNA/P6/#explicitly-moving-to-low-power-modes","text":"We will start from a basic code monitoring any input device (like the button or the temperature sensor), where the main program is in an endless loop reading, periodically, the device status. The structure of the starting code could be similar to: while (1) { med = read_device(); // Could be button, sensor... ESP_LOGI(TAG,\"Medida: %f\", med); vTaskDelay(pdMS_TO_TICKS(DELAY)); } Implement the following modifications: Include a explicit call to enter light sleep after 5 iterations. Previously, you will configure the wakeup mechanism to be the timer and instruct it to wake the system up after 10 seconds. Repeat the previous point but entering deep sleep Include code to determine the cause of the wakeup for both previous cases. Questions What difference do you observe when entering deep sleep compared with light sleep ? What does it happen after 10 seconds in each case? Where do you need to include the code to determine the wakeup cause in each of the two cases?","title":"Explicitly moving to low power modes"},{"location":"Subjects/IOTNA/P6/#using-the-power-manager","text":"Starting from the same simple code of previous section, we will be using the Power Manager provided by ESP-IDF. In order to do so, we must enable Dynamic frequency scaling (DFS). We can enable it with menuconfig -> Component config -> Power Management -> Support for Power Management -> Enable DFS at startup . It is also possible to configure it in our own code using the call esp_pm_configure() . You will use this latter method ( esp_pm_configure() ) and define: * Max. frequency of 240MHz * Min. frequency of 40MHz * Enable automatic entering light sleep mode To enable automatic entering light sleep mode we must activate the corresponding option in menuconfig : Component config -> FreeRTOS -> Tickless Idle Support (this option is only visible if the Enable DFS at startup option is also enabled). Following the earlier pseudo-code, modify your code in order to guess the wakeup cause. The structure of code could be now similar to: while (1) { med = read_device(); // Could be button, sensor... ESP_LOGI(TAG,\"Medida: %f\", med); vTaskDelay(pdMS_TO_TICKS(DELAY)); cause = get_wakeup_cause(); } Questions Which mechanism is waking the system up when using the Power Manager ?","title":"Using the Power Manager"},{"location":"Subjects/IOTNA/P6/#using-high-resolution-timers-optional","text":"Modify your code to monitor the device (sensor, button...) using a High Resolution Timer instead of using the call to vTaskDelay(pdMS_TO_TICKS(DELAY)) . The main task will configure the high resolution timer and then go to sleep for 100 seconds in and endless loop.","title":"Using High Resolution Timers (OPTIONAL)"},{"location":"Subjects/IOTNA/P6/#entering-light-sleep-mode-manually","text":"Modify your code to enter light sleep mode (calling esp_light_sleep_start() ) after 3 executions of the high resolution timer callback. Set the high resolution timer to trigger every 3 seconds, and program the system to wake up after 10 seconds. Include a log message in the callback function which prints the number of times the callback function has been called. Questions Call esp_light_sleep_start() outside the callback function of the high resolution timer. What happens when the system wakes up? Are there log messages lost? Do they happen when they should happen? No call esp_light_sleep_start() inside the callback function of the high resolution timer. Do you observe any difference?","title":"Entering light sleep mode manually"},{"location":"Subjects/IOTNA/P6/#automatically-entering-light-sleep-mode","text":"Repeat previous experiments using the Power Manager. Questions Note that, since you do not manually enter the sleep mode, you will not move into light sleep after 3 executions of the high resolution timer. When is the system moving to light sleep ? What happens with the callback log messages? Do they happen when they should happen?","title":"Automatically entering light sleep mode"},{"location":"Subjects/IOTNA/P6/#delivering-the-assignment","text":"Once you finish the complete assignment (at least the first two sections), please send an email to Prof. Jose Ignacio (jigomez@ucm.es) with the codes develop for each section and a text file (text or PDF) with your answers to the questions. Please send only one email per group. DEADLINE: 12th January 2022","title":"Delivering the assignment"},{"location":"Subjects/IOTNA/P7/","text":"Final programming project The final development (programming) project will be finally carried on in teams of 2 people . Project description The project must provide the following features: It must periodically monitor two I2C sensors of the ESP32-MeshKit-Sense board, the temperature sensor (HTS221) and the ambient light sensor (BH1750FVI). You will read the temperature sensor every 5 seconds and the light sensor every 2 seconds. The power manager will be configured to enter light sleep whenever possible. There will be a LOG (level INFO) every 10 seconds informing of the last temperature and ambient light (illuminance, measured in lux) readings LED IO12 should be blinking every second to inform that the system is running. If the ambient light sensor lux lecture goes below a certain threshold (decided by you), the LED IO2 will be on and LED IO12 will go off. If the ambient light sensor readings remain under the threshold for more than 10 minutes, the system will enter deep sleep for 30 minutes. Optional parts OPTIONALLY you could include all/some of the following features: Design the system using the Finite State Machine (FSM) presented in the lectures. Instead of informing of the last temperature/illuminance reading, log the average of the readings since the last log. Before entering deep sleep, the system will write the current temperature and luminance reading in Flash, using the NVS partition. After waking up, and only if we are returning from a deep sleep, there will be a LOG message informing of the stored temperature and illuminance before starting to read the sensors again. LED IO12 could be controlled using a PWM signal so its intensity changes depending on the current illuminance: if the illuminance is high, the LED IO12 will bright more. When the illuminance is less, the LED IO12 will be dimmer. You can check the ESP-IDF documentation and examples for PWM (in the documentation, PWM is used to control motors and servomotors. But the same signal could drive the LED, controlling its intensity). Important dates Group notifications . Remember that this assignment has to be done in a team of 2 people, so the current groups are no longer valid . Please send an email to Prof. Jose Ignacio him about your team for this project before 29th Dec 2021 During the week of 10th January 2022, you will be able to work on this project during IOTNA lectures. You will be able to ask your questions to the Professor during those sessions. DEADLINE : 24th January 2022. Delivery instructions You must send your code (.c and .h files) to Prof. Jose Ignacio by email (jigomez@ucm.es) before the deadline expires. Groups for the final project Group Name 1 Name 2 1 SHUISHI ZHOU YANG CHU 2 YANG ZHAO HU ZHAO 3 XIAOLAN LI QIUJI CHEN 4 XIONGLAN LUO. JIANCHUANG ZHANG 5 WEILIN ZHANG. YONGTAO HE 6 JUNYAN GUO ZHIJUN HAO 7 GONGLU ZOU. HONGBIAO CAO 8 JIAYUN PAN JIALI GAO 9 Liu JINHUA HUANG YUJUAN 10 DUAN ZHEN HU HAO 11 GUANJIE XIAO YUANSHUANG SHA 12 Dongyang Xu XUEQING ZHAO 13 WEI REN SUIZHI LIU 14 YOURAN TIAN JUN SHOU 15 TIANFENG LI YI ZHANG 16 Fengfen GU Wenyan Liao 17 Bin Zhang YINGHUA LIAO Group 18 will have 3 members: JIEPING YOU, QINGHONG YUHUAN and XIAZU HU","title":"Final programming project"},{"location":"Subjects/IOTNA/P7/#final-programming-project","text":"The final development (programming) project will be finally carried on in teams of 2 people .","title":"Final programming project"},{"location":"Subjects/IOTNA/P7/#project-description","text":"The project must provide the following features: It must periodically monitor two I2C sensors of the ESP32-MeshKit-Sense board, the temperature sensor (HTS221) and the ambient light sensor (BH1750FVI). You will read the temperature sensor every 5 seconds and the light sensor every 2 seconds. The power manager will be configured to enter light sleep whenever possible. There will be a LOG (level INFO) every 10 seconds informing of the last temperature and ambient light (illuminance, measured in lux) readings LED IO12 should be blinking every second to inform that the system is running. If the ambient light sensor lux lecture goes below a certain threshold (decided by you), the LED IO2 will be on and LED IO12 will go off. If the ambient light sensor readings remain under the threshold for more than 10 minutes, the system will enter deep sleep for 30 minutes.","title":"Project description"},{"location":"Subjects/IOTNA/P7/#optional-parts","text":"OPTIONALLY you could include all/some of the following features: Design the system using the Finite State Machine (FSM) presented in the lectures. Instead of informing of the last temperature/illuminance reading, log the average of the readings since the last log. Before entering deep sleep, the system will write the current temperature and luminance reading in Flash, using the NVS partition. After waking up, and only if we are returning from a deep sleep, there will be a LOG message informing of the stored temperature and illuminance before starting to read the sensors again. LED IO12 could be controlled using a PWM signal so its intensity changes depending on the current illuminance: if the illuminance is high, the LED IO12 will bright more. When the illuminance is less, the LED IO12 will be dimmer. You can check the ESP-IDF documentation and examples for PWM (in the documentation, PWM is used to control motors and servomotors. But the same signal could drive the LED, controlling its intensity).","title":"Optional parts"},{"location":"Subjects/IOTNA/P7/#important-dates","text":"Group notifications . Remember that this assignment has to be done in a team of 2 people, so the current groups are no longer valid . Please send an email to Prof. Jose Ignacio him about your team for this project before 29th Dec 2021 During the week of 10th January 2022, you will be able to work on this project during IOTNA lectures. You will be able to ask your questions to the Professor during those sessions. DEADLINE : 24th January 2022.","title":"Important dates"},{"location":"Subjects/IOTNA/P7/#delivery-instructions","text":"You must send your code (.c and .h files) to Prof. Jose Ignacio by email (jigomez@ucm.es) before the deadline expires.","title":"Delivery instructions"},{"location":"Subjects/IOTNA/P7/#groups-for-the-final-project","text":"Group Name 1 Name 2 1 SHUISHI ZHOU YANG CHU 2 YANG ZHAO HU ZHAO 3 XIAOLAN LI QIUJI CHEN 4 XIONGLAN LUO. JIANCHUANG ZHANG 5 WEILIN ZHANG. YONGTAO HE 6 JUNYAN GUO ZHIJUN HAO 7 GONGLU ZOU. HONGBIAO CAO 8 JIAYUN PAN JIALI GAO 9 Liu JINHUA HUANG YUJUAN 10 DUAN ZHEN HU HAO 11 GUANJIE XIAO YUANSHUANG SHA 12 Dongyang Xu XUEQING ZHAO 13 WEI REN SUIZHI LIU 14 YOURAN TIAN JUN SHOU 15 TIANFENG LI YI ZHANG 16 Fengfen GU Wenyan Liao 17 Bin Zhang YINGHUA LIAO Group 18 will have 3 members: JIEPING YOU, QINGHONG YUHUAN and XIAZU HU","title":"Groups for the final project"},{"location":"Subjects/IOTNA/ctutorial/","text":"C programming. Exercises There are many good C/C++ tutorials online. You can find one in this link . Next, there are several examples that we will use during the lectures to talk about different aspects of C language. You can download a ZIP with the examples here Compilation (headers, macros...) #include <stdio.h> /******** QUESTIONS/TASKS ***** * 1. Compile and execute the code * 2. Later, apply only the preprocessor (-E flag) and redirect the output * to a file called hello.i * 3. What happened to the call min()? * 4. What did the directive #include <stdio.h> produced? *****************/ #define N 5 #define min(x,y) ( (x<y)?x:y ) int a = 7; int b = 9; int main() { char* cad = \"Hello world\"; int i; for (i=0;i<N;i++) { printf(\"%s \\t a= %d b= %d\\n\",cad,a,b); a++; a = min(a,b); } return 0; } Data types. Sizes #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the first \"printf\" prints different values for the same variable 'a'? * 2. How large is a 'char' variable? * 3. Why the value of 'a' changes that much when adding 1? * 4. If \"long\" and \"double\" have the same size, what's the difference? *****/ char a = 127; int b = 41; int main() { printf(\"a = %d a = %c \\n\", a,a); a++; printf(\"a = %d a = %c b=%d b=%c\\n\", a,a,b,b); printf(\"Size of int: %lu\\n\",sizeof(int ) ); printf(\"Size of char: %lu\\n\",sizeof( char) ); printf(\"Size of float: %lu\\n\",sizeof(float ) ); printf(\"Size of double: %lu\\n\",sizeof( double) ); printf(\"Size of long: %lu\\n\",sizeof(long ) ); printf(\"Size of short: %lu\\n\",sizeof( short) ); printf(\"Size of void*: %lu\\n\",sizeof( void*) ); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Is there a compilation problem or a execution problem? * 2. Why is it complaining? Fix it and compila again. * 3. a,b,c, y x are declared one after the other. Are their addresses consecutive in memory? * 4. What does the modifier \"%lu\" means in printf()? * 5. Which address is \"pc\" pointed to? Is the address of any other variable? Are those two the same size? * 6. Does the size of \"array1\" matches the number of elements? Why? * 7. Do \"cadena1\" and \"cadena2 \"point to the same address? * 8. Why sizes (according to sizeof()) of cadena1 and cadena2 are different? *************/ #define ARRAY_SIZE 10 int a = 7; unsigned long b = 8; short c; char x; char* pc; int array1[ARRAY_SIZE]; int array2[a]; char* cadena1 = \"CADENA DE CARACTERES\"; char cadena2[] = \"CADENA DE CARACTERES\"; int main() { pc =&x; a = 16; printf(\"Adress of a: %p Tam: %lu \\n\",&a,sizeof(a)); printf(\"Adress of b: %p Tam: %lu \\n\",&b,sizeof(b)); printf(\"Adress of c: %p Tam: %lu \\n\",&c,sizeof(c)); printf(\"Adress of x: %p Tam: %lu \\n\",&x,sizeof(x)); printf(\"Adress of pc: %p Adress pointed by pc: %p Tam: %lu \\n\",&pc,pc,sizeof(pc)); printf(\"Adress of array: %p Adress of elem 0: %p Tam de array: %lu \\n\",array1, &array1[0], sizeof(array1)); printf(\"Adress of cadena1: %p Adress pointed by: %p Tam: %lu \\n\",&cadena1,cadena1,sizeof(cadena1)); printf(\"Adress of cadena2: %p DAdress pointed by: %p Tam: %lu \\n\",&cadena2,cadena2,sizeof(cadena2)); return 0; } Using Arrays. #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Should we use \"&list\" to get the address of the array? * 2. What is actually stored in the address of \"list\"? * 3. Why are we including the lentgh of the array as parameter to \"init_array\"? * 4. Why the sizeof() output is different for the array in \"init_array\" and the one in main()? * 5. Why aren't we including a second parameter in init_array2? * 6. Do sizeof() outuput now match with the array in init_array2()? ***************/ #define N 5 void init_array(int array[], int size) ; void init_array2(int array[N]); int main(void) { int i,list[N]; printf(\"Dir de list %p Dir de list[0]: %p Dir de list[1]: %p. Sizeof list %lu \\n\",list,&list[0],&list[1],sizeof(list)); init_array(list, N); for (i = 0; i < N; i++) printf(\"next: %d \", list[i]); printf(\"\\n-------------------------\\n\"); init_array2(list); for (i = 0; i < N; i++) printf(\"next: %d \", list[i]); printf(\"\\n-------------------------\\n\"); } void init_array(int array[], int size) { int i; printf(\"Direccion de array: %p Sizeof array %lu \\n\", array, sizeof(array)); for (i = 0; i < size; i++) array[i] = i; printf(\"Array initialized\\n\\n\"); } void init_array2(int array[N]) { int i; printf(\"Direccion de array: %p Sizeof array %lu \\n\", array, sizeof(array)); for (i = 0; i < N; i++) array[i] = i*2; printf(\"Array initialized\\n\\n\"); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Does the copy of the array works? Why? * 2. Fix it. * 3. Uncommnet the call to function \"tom\". Compile again and execute. * 4. The problem that arises, is it in compilation or execution time? Why? * 5. Find a value for MAXVALID (greater than 4) when the problem does not happen. Why does it work? *******************/ #define N 10 #define MAXELEM 5000 #define MAXVALID 100 void printArray(int v[],int size) { int i; printf(\"-------------------\\n\"); for (i=0;i<size;i++) printf(\"%d \",v[i]); printf(\"\\n\\n\"); } void copyArray(int src[],int dst[],int size) { dst = src; } void tmo() { int x = -1; int a[4] = {0,1,2,3}; int b = 10000; int c = -1; int i; for (i=4;i<MAXVALID;i++) a[i]=i; printf(\"x %d b %d c %d\\n\", x,b,c); } int main() { int A[N] = {4,3,8,5,6,9,0,1,7,2}; int B[N]; //tmo(); copyArray(A,B,N); printArray(B,N); } Pointers #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Which operand should we use to declae a variable as a ponter? * 2. How do we obtain the address of a variable? * 3. How do we read/write into the address pointed by a pointer? * 4. There \u00a1s a bug in the code. Is it a compile-time or executiontime errror? Why does it happen? ***********/ int c = 7; int main(void) { int *ptr; printf(\"Address of ptr %p. ptr apunta a %p. Address of c: %p Valor of c %d\\n\",&ptr,ptr,&c,c); ptr = &c; printf(\"Address of ptr %p,. ptr apunta a %p. Address of c: %p Value of c %d\\n\",&ptr,ptr,&c,c); *ptr=4; printf(\"ptr apunta a %p. Content of address of ptr: %d Address of c: %p Value of c %d\\n\",ptr,*ptr,&c,c); ptr = (int*) 0x600a48; printf(\"Address of ptr %p. Value of c %d\\n\",ptr,c); *ptr =13; printf(\"Address of ptr %p. Value of c %d\\n\",ptr,c); return 0; } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. How many bytes are allocated in memory with the malloc() call? * 2. Which are the addresses of the first and last bytes of the allocated area? * 3. Why the content of the address pointed by \"ptr\" is 7 and not 5 in the first printf()? * 4. Why the content of ptrg[1] is modified after the sentence *ptr2=15 ? * 5. Suggest two different ways of writting the value 13 in the address of ptr[100] * 6. There is a bug in the code. Even if nothing goes wrong,the bug is there. Where? * ***********/ int nelem; int main(void) { int *ptr; int * ptr2; nelem = 127; ptr = (int*) malloc(nelem*sizeof(int)); *ptr = 5; ptr[0] = 7; ptr2 = ptr; printf(\"Address pointed by ptr %p. Content of that address: %d \\n\",ptr,*ptr); ptr[1] = 10; printf(\"Address pointed by ptr[1] %p. Content of that address: %d \\n\",&ptr[1],ptr[1]); ptr2++; *ptr2 = 15; printf(\"Address pointed by ptr[1] %p. Content of that address: %d \\n\",&ptr[1],ptr[1]); free(ptr); *ptr = 3; printf(\"Address pointed by ptr %p. Content of that address: %d \\n\",ptr,*ptr); } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the value of ptr[13] is changed after the sentence ptr = &c; * 2. This code has (at least) one bug. Compile or run-timer error? Why? * 3. What happens with the memory allocated by malloc() after the assignment ptr=&c? * How can we reach that memory again? How can we free it? * ***********/ int nelem; int c; int main(void) { int *ptr; int i; c = 37; nelem = 127; ptr = (int*) malloc(nelem*sizeof(int)); for (i=0; i<nelem; i++) ptr[i] = i; printf(\"ptr[0]= %d ptr[13]=%d \\n\",ptr[0],ptr[13]); ptr = &c; printf(\"ptr[0]= %d ptr[13]=%d \\n\",ptr[0],ptr[13]); free(ptr); } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the second printf() prints a different value for 'd'? * 2. What is 'f'? A variable? A function? * 3. Use the function 'opera()' to perform the first addition. Then, use it again to perform a substraction. * 4. Using typedef, build a type called ptrToFunc with the same prototype thatn 'f' * 5. Creat a function 'choose()' that will return, alternatively, a pointer to \"add()\" and \"sub()\" * every time it is called * ***********/ int add (int x, int y); int sub(int x, int y); int (*f)(int a, int b); int add(int x, int y) { return x+y; } int sub(int x, int y) { return x-y; } int opera(int x, int y, int (*g)(int, int)) { return g(x,y); } int main(void) { int a = 12; int b = 8; int c,d; f = add; c = add(a,b); d = f(a,b); printf(\"c = %d d= %d \\n\",c,d); f = sub; d = f(a,b); printf(\"c = %d d= %d \\n\",c,d); } Arguments #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the value of 'xc' is not changed after the call to sumC()? * Where do the write operations happen? * 2. Comment the two forwarded declarations of sum() and sumC(). Compile again. What happens? *******************/ /* Struct type */ struct _complex_ { float re; float im; }; /* Forward declarations */ int sum(int a, int b); struct _complex_ sumC( struct _complex_ a, struct _complex_ b); int main(void){ int x = 4,y = 5; struct _complex_ xc = {.re = 1.0, .im = 2.0}; struct _complex_ yc = {.re = 3.0, .im = 1.0}; struct _complex_ zc; zc = sumC(xc,yc); int total = sum(x,y); printf(\"Suma de complejos. (%f,%f i) + (%f,%f i) =(%f,%f i)\\n\",xc.re,xc.im,yc.re,yc.im,zc.re,zc.im); printf(\"Suma de enteros: x +y = %d + %d = %d \\n\",x,y, total); return 0; } int sum(int x, int y) { int c; c = x +y; x = 7; y =3; return c; } struct _complex_ sumC( struct _complex_ a, struct _complex_ b) { struct _complex_ r; r.re = a.re + b.re; r.im = a.im + b.im; // Try to change the first parameter a.re = 12.5; a.im = 13.4; return r; } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why does the value of 'y' changes after the call to sum()? * 2. Why sometimes we use operator '.' and other times '->'? * 3. Why the vauue of 'zc' gets wrong without further using it in the code? * 4. Fix the code to avoid the bug in 'zc' shown in previous point *******************/ struct _complex_ { float re; float im; }; int sum(int *pa, int *pb); struct _complex_ * sumC( struct _complex_ *a, struct _complex_ *b); int main(void){ int x = 4,y = 5; int* ptr = &y; struct _complex_ xc = {.re = 1.0, .im = 2.0}; struct _complex_ yc = {.re = 3.0, .im = 1.0}; struct _complex_ *zc; printf(\"Complex addition (%f,%f i) + (%f,%f i) = \", xc.re,xc.im,yc.re,yc.im); zc = sumC(&xc,&yc); printf(\"(%f,%f i)\\n\",zc->re,zc->im); int total = sum(&x,ptr); printf(\"Complex addition: x +y = %d + %d = %d \\n\",x,y, total); printf(\"xc = (%f,%f i) yc = (%f,%f i) zc = (%f,%f i)\\n\",xc.re,xc.im,yc.re,yc.im,zc->re,zc->im); return 0; } int sum(int *pa, int *pb) { /* args passed by reference */ int c = *pa + *pb; int buf[256] = {0}; *pa = 7; *pb = 8; return c; /* return by value */ } struct _complex_ * sumC( struct _complex_* a, struct _complex_* b) { struct _complex_ r; r.re = a->re + b->re; r.im = a->im + b->im; a->re = 12.5; a->im = 13.4; return &r; } Strings #include <stdio.h> #include <string.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. The code has a bug. Compile or run-time? Why? * Fix the bug commenting the line(s) that produce it. Compile and execute again. * 2. Which is the address of letter 'B' in the chain \"Bonjour\"? And letter 'j'? * 3. After the assignment p=msg2; how can we get back the address of \"Bonjour\"? * 4. Why the length of strings 'p' and 'msg2' are 2 after the third assignment? * 3 bytes are assigned to 'p', but then the length is only 2 !! * 5. Why strlen() returns a different value than sizeof()? * 6. Why the string stored in 'msg' in line 36 is bad-printed in the last printf()? ************** */ int main() { char msg[10]; /* array of 10 chars */ char *p; /* pointer to a char */ char msg2[28]=\"Hello\"; /* msg2 = 'H' 'e' 'l' 'l' 'o' '\\0' */ p = \"Bonjour\"; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"dir de msg: %p, dir de p: %p, dir de msg2: %p\\n\",msg,p,msg2); p = msg2; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"dir de msg: %p, dir de p: %p, dir de msg2: %p\\n\",msg,p,msg2); p[0] = 'H', p[1] = 'i',p[2]='\\0'; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"msg len: %lu p len %lu msg2 len %lu\\n\", strlen(msg),strlen(p),strlen(msg2)); printf(\"msg size: %lu p size %lu msg2 size %lu\\n\", sizeof(msg),sizeof(p),sizeof(msg2)); msg[0] = 'B', msg[1] = 'y'; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); msg = \"Goodbye\"; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); } #include <stdio.h> #include <string.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. The code of fcuntion 'copy' does not work. Why? * 2. Use now 'copy2()'. Does the copy actually work? * 3. Suggest a valid implementation for a copy * 4. What does function \"mod\" do? * 5. Uncomment last line of code (call to mod()). Compile and execute. Why is there an error now? ************** */ void copy2(char* org, char** dst) { *dst = org; } void copy(char* org, char* dst) { dst = org; } void mod(char* org, char* dst) { int i; for (i=0;i<strlen(org);i++) dst[i] = org[i] - 32; } int main() { char* cad1 = \"original\"; char* cad2 = \"other\"; char cad3[32]; copy(cad1,cad2); //copy2(cad1,&cad2); printf(\"cad1 %s cad2 %s\\n\", cad1,cad2); mod(cad1,cad3); printf(\"cad1 %s cad3 %s\\n\", cad1,cad3); //mod(cad1,cad1); } Bitwaise operations #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * Study the syntax of the different bit-level operators * and make sure you understand the result of every operation ************** */ int a,b,c; int main() { a = 7; b = 9; c = a & b; printf(\"%x AND %x = %x\\n\",a,b,c); c= a | b; printf(\"%x OR %x = %x\\n\",a,b,c); c = a ^ b; printf(\"%x XOR %x = %x\\n\",a,b,c); c = ~a; printf(\"NOT %x = %x\\n\",a,c); c = a << 2; printf(\" %x << 2 = %x\\n\",a,c); c = a >> 1; printf(\" %x >> 1 = %x\\n\",a,c); c = a & 0xFB; printf(\" %x bit 2 to 0 -> %x\\n\",a,c); c = a | 0x40; printf(\" %x bit 6 to 1 -> %x\\n\",a,c); c = (a & 0x1C) >> 2; printf(\"bits 4-3-2 of %x: %x\\n\",a,c); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the assignment using pointer 'p' does not overwrite completely 'a'? * 2. How is modified the address pointed by 'p' after the assignment p=p+1 * 3. How would it be different if 'p' is declared as 'short *' * ************** */ int a = 3; int b; char * p; int c; int main() { printf(\"a = %x Address of a: %p \\n\",a,&a); p = (char*) &a; p=p+1; *p= 0x1f; printf(\"a = %x. Address pointed by p:%p \\n\",a,p); a = 3; b = 0x00001f00; a= a | b; printf(\"a = %x. Address pointed by p:%p \\n\",a,p); }","title":"C programming. Exercises"},{"location":"Subjects/IOTNA/ctutorial/#c-programming-exercises","text":"There are many good C/C++ tutorials online. You can find one in this link . Next, there are several examples that we will use during the lectures to talk about different aspects of C language. You can download a ZIP with the examples here","title":"C programming. Exercises"},{"location":"Subjects/IOTNA/ctutorial/#compilation-headers-macros","text":"#include <stdio.h> /******** QUESTIONS/TASKS ***** * 1. Compile and execute the code * 2. Later, apply only the preprocessor (-E flag) and redirect the output * to a file called hello.i * 3. What happened to the call min()? * 4. What did the directive #include <stdio.h> produced? *****************/ #define N 5 #define min(x,y) ( (x<y)?x:y ) int a = 7; int b = 9; int main() { char* cad = \"Hello world\"; int i; for (i=0;i<N;i++) { printf(\"%s \\t a= %d b= %d\\n\",cad,a,b); a++; a = min(a,b); } return 0; }","title":"Compilation (headers, macros...)"},{"location":"Subjects/IOTNA/ctutorial/#data-types-sizes","text":"#include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the first \"printf\" prints different values for the same variable 'a'? * 2. How large is a 'char' variable? * 3. Why the value of 'a' changes that much when adding 1? * 4. If \"long\" and \"double\" have the same size, what's the difference? *****/ char a = 127; int b = 41; int main() { printf(\"a = %d a = %c \\n\", a,a); a++; printf(\"a = %d a = %c b=%d b=%c\\n\", a,a,b,b); printf(\"Size of int: %lu\\n\",sizeof(int ) ); printf(\"Size of char: %lu\\n\",sizeof( char) ); printf(\"Size of float: %lu\\n\",sizeof(float ) ); printf(\"Size of double: %lu\\n\",sizeof( double) ); printf(\"Size of long: %lu\\n\",sizeof(long ) ); printf(\"Size of short: %lu\\n\",sizeof( short) ); printf(\"Size of void*: %lu\\n\",sizeof( void*) ); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Is there a compilation problem or a execution problem? * 2. Why is it complaining? Fix it and compila again. * 3. a,b,c, y x are declared one after the other. Are their addresses consecutive in memory? * 4. What does the modifier \"%lu\" means in printf()? * 5. Which address is \"pc\" pointed to? Is the address of any other variable? Are those two the same size? * 6. Does the size of \"array1\" matches the number of elements? Why? * 7. Do \"cadena1\" and \"cadena2 \"point to the same address? * 8. Why sizes (according to sizeof()) of cadena1 and cadena2 are different? *************/ #define ARRAY_SIZE 10 int a = 7; unsigned long b = 8; short c; char x; char* pc; int array1[ARRAY_SIZE]; int array2[a]; char* cadena1 = \"CADENA DE CARACTERES\"; char cadena2[] = \"CADENA DE CARACTERES\"; int main() { pc =&x; a = 16; printf(\"Adress of a: %p Tam: %lu \\n\",&a,sizeof(a)); printf(\"Adress of b: %p Tam: %lu \\n\",&b,sizeof(b)); printf(\"Adress of c: %p Tam: %lu \\n\",&c,sizeof(c)); printf(\"Adress of x: %p Tam: %lu \\n\",&x,sizeof(x)); printf(\"Adress of pc: %p Adress pointed by pc: %p Tam: %lu \\n\",&pc,pc,sizeof(pc)); printf(\"Adress of array: %p Adress of elem 0: %p Tam de array: %lu \\n\",array1, &array1[0], sizeof(array1)); printf(\"Adress of cadena1: %p Adress pointed by: %p Tam: %lu \\n\",&cadena1,cadena1,sizeof(cadena1)); printf(\"Adress of cadena2: %p DAdress pointed by: %p Tam: %lu \\n\",&cadena2,cadena2,sizeof(cadena2)); return 0; }","title":"Data types. Sizes"},{"location":"Subjects/IOTNA/ctutorial/#using-arrays","text":"#include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Should we use \"&list\" to get the address of the array? * 2. What is actually stored in the address of \"list\"? * 3. Why are we including the lentgh of the array as parameter to \"init_array\"? * 4. Why the sizeof() output is different for the array in \"init_array\" and the one in main()? * 5. Why aren't we including a second parameter in init_array2? * 6. Do sizeof() outuput now match with the array in init_array2()? ***************/ #define N 5 void init_array(int array[], int size) ; void init_array2(int array[N]); int main(void) { int i,list[N]; printf(\"Dir de list %p Dir de list[0]: %p Dir de list[1]: %p. Sizeof list %lu \\n\",list,&list[0],&list[1],sizeof(list)); init_array(list, N); for (i = 0; i < N; i++) printf(\"next: %d \", list[i]); printf(\"\\n-------------------------\\n\"); init_array2(list); for (i = 0; i < N; i++) printf(\"next: %d \", list[i]); printf(\"\\n-------------------------\\n\"); } void init_array(int array[], int size) { int i; printf(\"Direccion de array: %p Sizeof array %lu \\n\", array, sizeof(array)); for (i = 0; i < size; i++) array[i] = i; printf(\"Array initialized\\n\\n\"); } void init_array2(int array[N]) { int i; printf(\"Direccion de array: %p Sizeof array %lu \\n\", array, sizeof(array)); for (i = 0; i < N; i++) array[i] = i*2; printf(\"Array initialized\\n\\n\"); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Does the copy of the array works? Why? * 2. Fix it. * 3. Uncommnet the call to function \"tom\". Compile again and execute. * 4. The problem that arises, is it in compilation or execution time? Why? * 5. Find a value for MAXVALID (greater than 4) when the problem does not happen. Why does it work? *******************/ #define N 10 #define MAXELEM 5000 #define MAXVALID 100 void printArray(int v[],int size) { int i; printf(\"-------------------\\n\"); for (i=0;i<size;i++) printf(\"%d \",v[i]); printf(\"\\n\\n\"); } void copyArray(int src[],int dst[],int size) { dst = src; } void tmo() { int x = -1; int a[4] = {0,1,2,3}; int b = 10000; int c = -1; int i; for (i=4;i<MAXVALID;i++) a[i]=i; printf(\"x %d b %d c %d\\n\", x,b,c); } int main() { int A[N] = {4,3,8,5,6,9,0,1,7,2}; int B[N]; //tmo(); copyArray(A,B,N); printArray(B,N); }","title":"Using Arrays."},{"location":"Subjects/IOTNA/ctutorial/#pointers","text":"#include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Which operand should we use to declae a variable as a ponter? * 2. How do we obtain the address of a variable? * 3. How do we read/write into the address pointed by a pointer? * 4. There \u00a1s a bug in the code. Is it a compile-time or executiontime errror? Why does it happen? ***********/ int c = 7; int main(void) { int *ptr; printf(\"Address of ptr %p. ptr apunta a %p. Address of c: %p Valor of c %d\\n\",&ptr,ptr,&c,c); ptr = &c; printf(\"Address of ptr %p,. ptr apunta a %p. Address of c: %p Value of c %d\\n\",&ptr,ptr,&c,c); *ptr=4; printf(\"ptr apunta a %p. Content of address of ptr: %d Address of c: %p Value of c %d\\n\",ptr,*ptr,&c,c); ptr = (int*) 0x600a48; printf(\"Address of ptr %p. Value of c %d\\n\",ptr,c); *ptr =13; printf(\"Address of ptr %p. Value of c %d\\n\",ptr,c); return 0; } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. How many bytes are allocated in memory with the malloc() call? * 2. Which are the addresses of the first and last bytes of the allocated area? * 3. Why the content of the address pointed by \"ptr\" is 7 and not 5 in the first printf()? * 4. Why the content of ptrg[1] is modified after the sentence *ptr2=15 ? * 5. Suggest two different ways of writting the value 13 in the address of ptr[100] * 6. There is a bug in the code. Even if nothing goes wrong,the bug is there. Where? * ***********/ int nelem; int main(void) { int *ptr; int * ptr2; nelem = 127; ptr = (int*) malloc(nelem*sizeof(int)); *ptr = 5; ptr[0] = 7; ptr2 = ptr; printf(\"Address pointed by ptr %p. Content of that address: %d \\n\",ptr,*ptr); ptr[1] = 10; printf(\"Address pointed by ptr[1] %p. Content of that address: %d \\n\",&ptr[1],ptr[1]); ptr2++; *ptr2 = 15; printf(\"Address pointed by ptr[1] %p. Content of that address: %d \\n\",&ptr[1],ptr[1]); free(ptr); *ptr = 3; printf(\"Address pointed by ptr %p. Content of that address: %d \\n\",ptr,*ptr); } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the value of ptr[13] is changed after the sentence ptr = &c; * 2. This code has (at least) one bug. Compile or run-timer error? Why? * 3. What happens with the memory allocated by malloc() after the assignment ptr=&c? * How can we reach that memory again? How can we free it? * ***********/ int nelem; int c; int main(void) { int *ptr; int i; c = 37; nelem = 127; ptr = (int*) malloc(nelem*sizeof(int)); for (i=0; i<nelem; i++) ptr[i] = i; printf(\"ptr[0]= %d ptr[13]=%d \\n\",ptr[0],ptr[13]); ptr = &c; printf(\"ptr[0]= %d ptr[13]=%d \\n\",ptr[0],ptr[13]); free(ptr); } #include <stdio.h> #include <stdlib.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the second printf() prints a different value for 'd'? * 2. What is 'f'? A variable? A function? * 3. Use the function 'opera()' to perform the first addition. Then, use it again to perform a substraction. * 4. Using typedef, build a type called ptrToFunc with the same prototype thatn 'f' * 5. Creat a function 'choose()' that will return, alternatively, a pointer to \"add()\" and \"sub()\" * every time it is called * ***********/ int add (int x, int y); int sub(int x, int y); int (*f)(int a, int b); int add(int x, int y) { return x+y; } int sub(int x, int y) { return x-y; } int opera(int x, int y, int (*g)(int, int)) { return g(x,y); } int main(void) { int a = 12; int b = 8; int c,d; f = add; c = add(a,b); d = f(a,b); printf(\"c = %d d= %d \\n\",c,d); f = sub; d = f(a,b); printf(\"c = %d d= %d \\n\",c,d); }","title":"Pointers"},{"location":"Subjects/IOTNA/ctutorial/#arguments","text":"#include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the value of 'xc' is not changed after the call to sumC()? * Where do the write operations happen? * 2. Comment the two forwarded declarations of sum() and sumC(). Compile again. What happens? *******************/ /* Struct type */ struct _complex_ { float re; float im; }; /* Forward declarations */ int sum(int a, int b); struct _complex_ sumC( struct _complex_ a, struct _complex_ b); int main(void){ int x = 4,y = 5; struct _complex_ xc = {.re = 1.0, .im = 2.0}; struct _complex_ yc = {.re = 3.0, .im = 1.0}; struct _complex_ zc; zc = sumC(xc,yc); int total = sum(x,y); printf(\"Suma de complejos. (%f,%f i) + (%f,%f i) =(%f,%f i)\\n\",xc.re,xc.im,yc.re,yc.im,zc.re,zc.im); printf(\"Suma de enteros: x +y = %d + %d = %d \\n\",x,y, total); return 0; } int sum(int x, int y) { int c; c = x +y; x = 7; y =3; return c; } struct _complex_ sumC( struct _complex_ a, struct _complex_ b) { struct _complex_ r; r.re = a.re + b.re; r.im = a.im + b.im; // Try to change the first parameter a.re = 12.5; a.im = 13.4; return r; } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why does the value of 'y' changes after the call to sum()? * 2. Why sometimes we use operator '.' and other times '->'? * 3. Why the vauue of 'zc' gets wrong without further using it in the code? * 4. Fix the code to avoid the bug in 'zc' shown in previous point *******************/ struct _complex_ { float re; float im; }; int sum(int *pa, int *pb); struct _complex_ * sumC( struct _complex_ *a, struct _complex_ *b); int main(void){ int x = 4,y = 5; int* ptr = &y; struct _complex_ xc = {.re = 1.0, .im = 2.0}; struct _complex_ yc = {.re = 3.0, .im = 1.0}; struct _complex_ *zc; printf(\"Complex addition (%f,%f i) + (%f,%f i) = \", xc.re,xc.im,yc.re,yc.im); zc = sumC(&xc,&yc); printf(\"(%f,%f i)\\n\",zc->re,zc->im); int total = sum(&x,ptr); printf(\"Complex addition: x +y = %d + %d = %d \\n\",x,y, total); printf(\"xc = (%f,%f i) yc = (%f,%f i) zc = (%f,%f i)\\n\",xc.re,xc.im,yc.re,yc.im,zc->re,zc->im); return 0; } int sum(int *pa, int *pb) { /* args passed by reference */ int c = *pa + *pb; int buf[256] = {0}; *pa = 7; *pb = 8; return c; /* return by value */ } struct _complex_ * sumC( struct _complex_* a, struct _complex_* b) { struct _complex_ r; r.re = a->re + b->re; r.im = a->im + b->im; a->re = 12.5; a->im = 13.4; return &r; }","title":"Arguments"},{"location":"Subjects/IOTNA/ctutorial/#strings","text":"#include <stdio.h> #include <string.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. The code has a bug. Compile or run-time? Why? * Fix the bug commenting the line(s) that produce it. Compile and execute again. * 2. Which is the address of letter 'B' in the chain \"Bonjour\"? And letter 'j'? * 3. After the assignment p=msg2; how can we get back the address of \"Bonjour\"? * 4. Why the length of strings 'p' and 'msg2' are 2 after the third assignment? * 3 bytes are assigned to 'p', but then the length is only 2 !! * 5. Why strlen() returns a different value than sizeof()? * 6. Why the string stored in 'msg' in line 36 is bad-printed in the last printf()? ************** */ int main() { char msg[10]; /* array of 10 chars */ char *p; /* pointer to a char */ char msg2[28]=\"Hello\"; /* msg2 = 'H' 'e' 'l' 'l' 'o' '\\0' */ p = \"Bonjour\"; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"dir de msg: %p, dir de p: %p, dir de msg2: %p\\n\",msg,p,msg2); p = msg2; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"dir de msg: %p, dir de p: %p, dir de msg2: %p\\n\",msg,p,msg2); p[0] = 'H', p[1] = 'i',p[2]='\\0'; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); printf(\"msg len: %lu p len %lu msg2 len %lu\\n\", strlen(msg),strlen(p),strlen(msg2)); printf(\"msg size: %lu p size %lu msg2 size %lu\\n\", sizeof(msg),sizeof(p),sizeof(msg2)); msg[0] = 'B', msg[1] = 'y'; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); msg = \"Goodbye\"; printf(\"msg: %s, p: %s, msg2: %s\\n\",msg,p,msg2); } #include <stdio.h> #include <string.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. The code of fcuntion 'copy' does not work. Why? * 2. Use now 'copy2()'. Does the copy actually work? * 3. Suggest a valid implementation for a copy * 4. What does function \"mod\" do? * 5. Uncomment last line of code (call to mod()). Compile and execute. Why is there an error now? ************** */ void copy2(char* org, char** dst) { *dst = org; } void copy(char* org, char* dst) { dst = org; } void mod(char* org, char* dst) { int i; for (i=0;i<strlen(org);i++) dst[i] = org[i] - 32; } int main() { char* cad1 = \"original\"; char* cad2 = \"other\"; char cad3[32]; copy(cad1,cad2); //copy2(cad1,&cad2); printf(\"cad1 %s cad2 %s\\n\", cad1,cad2); mod(cad1,cad3); printf(\"cad1 %s cad3 %s\\n\", cad1,cad3); //mod(cad1,cad1); }","title":"Strings"},{"location":"Subjects/IOTNA/ctutorial/#bitwaise-operations","text":"#include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * Study the syntax of the different bit-level operators * and make sure you understand the result of every operation ************** */ int a,b,c; int main() { a = 7; b = 9; c = a & b; printf(\"%x AND %x = %x\\n\",a,b,c); c= a | b; printf(\"%x OR %x = %x\\n\",a,b,c); c = a ^ b; printf(\"%x XOR %x = %x\\n\",a,b,c); c = ~a; printf(\"NOT %x = %x\\n\",a,c); c = a << 2; printf(\" %x << 2 = %x\\n\",a,c); c = a >> 1; printf(\" %x >> 1 = %x\\n\",a,c); c = a & 0xFB; printf(\" %x bit 2 to 0 -> %x\\n\",a,c); c = a | 0x40; printf(\" %x bit 6 to 1 -> %x\\n\",a,c); c = (a & 0x1C) >> 2; printf(\"bits 4-3-2 of %x: %x\\n\",a,c); } #include <stdio.h> /**** QUESTIONS/TASKS ******** * Compile and execute the code. * 1. Why the assignment using pointer 'p' does not overwrite completely 'a'? * 2. How is modified the address pointed by 'p' after the assignment p=p+1 * 3. How would it be different if 'p' is declared as 'short *' * ************** */ int a = 3; int b; char * p; int c; int main() { printf(\"a = %x Address of a: %p \\n\",a,&a); p = (char*) &a; p=p+1; *p= 0x1f; printf(\"a = %x. Address pointed by p:%p \\n\",a,p); a = 3; b = 0x00001f00; a= a | b; printf(\"a = %x. Address pointed by p:%p \\n\",a,p); }","title":"Bitwaise operations"},{"location":"Subjects/IOTNA/demo/","text":"Introduction to ESP-IDF and Platform IO (demo) Goals Meet the IDE we will be using during the Master: native ESP-IDF and the tool PlatformIO Learn how to run the virtual machine and install the environments Learn how to connect our ESP32 board to the computer and upload a binary Using the Virtual Machine We have provided a virtual machine with some of the tools we will be using already installed. Note that you can install everything natively in your system, and I will run faster. We provide the virtual machine just in case you prefer not to install new software in your own computer. You can download the OVA file from Google Drive or Baidu Netdisk (with code 7spz). An OVA file contains a OVF (Open Virtualizaion Format) file so it can be opened in any virtualization framework. During the course, we will be using Oracle VM Virtualbox which is a free and open-source hosted hypervisor for x86 virtualization. In order to run the virtual machine just follow the steps: Download Virtual Box from this link . Install Virtual Box in your machine. Download the OVA file provided. Import the OVA file from Virtual Box (Use \"Import\" or \"Import Appliance\" from the File menu. Do not just drag the OVA file in the Virtual Box window) After importing the virtual machine is imported it should be listed in Virtual Box screen (the one named MIOT_VM_2022_CN ) Now, you can run the virtual machine. We have installed a recent version of Ubuntu operating system (Ubuntu 20.04.1 LTS). There is a sinlge user (named Ubuntu) whose password is ubuntu (small-caps). Launching Visual Studio Code and PlatformIO During this online demo, I will show you how to use Visual Studio Code and the PlatformIO plugin to create a new project, compile it and upload it to our board. You can install this environment in your own machine, which is recommended since virtualization introduces some overheads. You can download Visual Studio Code from this link . Once installed, you can easily install the PlatformIO plugin from the Extensions: Marketplace in the same Visual Studio Code window: Installing the native ESP-IDF environment There is an alternative to PlatformIO: installing the native Espressif environment for ESP-IDF. You have all the steps to install and setup their environment in this link Just a summary of the information there provided (please check the website, because it could be updated), we include here the most relevant steps for the environment installation in the Ubuntu terminal machine. Open a Terminal and make sure your package system is up to date: sudo apt update sudo apt upgrade Run the following command to install the pre-requisites (note that you will be using sudo to run it with superuser privileges. The user Ubuntu has sudo privileges, so just use the same password as before when required: ubuntu ). sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util If you are installing the environment in your own Linux machine, make sure your user is also in the dilaout group. Install Python 3 and make it the default distribution: sudo apt-get install python3 python3-pip python3-setuptools sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 Obtain ESP-IDF sources. We will install it under a folder called esp mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git pull git submodule update --init --recursive Now you can proceed to install the environment by using the provided script in esp-idf folder. This should be done only once. sh install.sh Every time you are to use the environment after opening a new Terminal, you should export some environment variables by running the export script provided in the esp-idf folder: . ./export.sh You are now ready to use the environment. idf.py is the front-end tool for everything: compiling, flashing , monitoring... You can now check the installed version by running: $ idf.py --version ESP-IDF v4.xxxxx","title":"Introduction to ESP-IDF and Platform IO (demo)"},{"location":"Subjects/IOTNA/demo/#introduction-to-esp-idf-and-platform-io-demo","text":"","title":"Introduction to ESP-IDF and Platform IO (demo)"},{"location":"Subjects/IOTNA/demo/#goals","text":"Meet the IDE we will be using during the Master: native ESP-IDF and the tool PlatformIO Learn how to run the virtual machine and install the environments Learn how to connect our ESP32 board to the computer and upload a binary","title":"Goals"},{"location":"Subjects/IOTNA/demo/#using-the-virtual-machine","text":"We have provided a virtual machine with some of the tools we will be using already installed. Note that you can install everything natively in your system, and I will run faster. We provide the virtual machine just in case you prefer not to install new software in your own computer. You can download the OVA file from Google Drive or Baidu Netdisk (with code 7spz). An OVA file contains a OVF (Open Virtualizaion Format) file so it can be opened in any virtualization framework. During the course, we will be using Oracle VM Virtualbox which is a free and open-source hosted hypervisor for x86 virtualization. In order to run the virtual machine just follow the steps: Download Virtual Box from this link . Install Virtual Box in your machine. Download the OVA file provided. Import the OVA file from Virtual Box (Use \"Import\" or \"Import Appliance\" from the File menu. Do not just drag the OVA file in the Virtual Box window) After importing the virtual machine is imported it should be listed in Virtual Box screen (the one named MIOT_VM_2022_CN ) Now, you can run the virtual machine. We have installed a recent version of Ubuntu operating system (Ubuntu 20.04.1 LTS). There is a sinlge user (named Ubuntu) whose password is ubuntu (small-caps).","title":"Using the Virtual Machine"},{"location":"Subjects/IOTNA/demo/#launching-visual-studio-code-and-platformio","text":"During this online demo, I will show you how to use Visual Studio Code and the PlatformIO plugin to create a new project, compile it and upload it to our board. You can install this environment in your own machine, which is recommended since virtualization introduces some overheads. You can download Visual Studio Code from this link . Once installed, you can easily install the PlatformIO plugin from the Extensions: Marketplace in the same Visual Studio Code window:","title":"Launching Visual Studio Code and PlatformIO"},{"location":"Subjects/IOTNA/demo/#installing-the-native-esp-idf-environment","text":"There is an alternative to PlatformIO: installing the native Espressif environment for ESP-IDF. You have all the steps to install and setup their environment in this link Just a summary of the information there provided (please check the website, because it could be updated), we include here the most relevant steps for the environment installation in the Ubuntu terminal machine. Open a Terminal and make sure your package system is up to date: sudo apt update sudo apt upgrade Run the following command to install the pre-requisites (note that you will be using sudo to run it with superuser privileges. The user Ubuntu has sudo privileges, so just use the same password as before when required: ubuntu ). sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util If you are installing the environment in your own Linux machine, make sure your user is also in the dilaout group. Install Python 3 and make it the default distribution: sudo apt-get install python3 python3-pip python3-setuptools sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 Obtain ESP-IDF sources. We will install it under a folder called esp mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git pull git submodule update --init --recursive Now you can proceed to install the environment by using the provided script in esp-idf folder. This should be done only once. sh install.sh Every time you are to use the environment after opening a new Terminal, you should export some environment variables by running the export script provided in the esp-idf folder: . ./export.sh You are now ready to use the environment. idf.py is the front-end tool for everything: compiling, flashing , monitoring... You can now check the installed version by running: $ idf.py --version ESP-IDF v4.xxxxx","title":"Installing the native ESP-IDF environment"},{"location":"Subjects/MDM/","text":"Massive Data Management All the information and documentation about Massive Data Management (MDM) can be found in this link","title":"MDM"},{"location":"Subjects/MDM/#massive-data-management","text":"All the information and documentation about Massive Data Management (MDM) can be found in this link","title":"Massive Data Management"},{"location":"Subjects/NP1/","text":"Networks and Protocols 1 General information This subject will cover the networking technologies used in IoT systems. Some specific goals if this subject are: 802.11 family Bluetooth Low Energy 802.15.4 and 6LoWPAN LPWAN, Lora This subject is complemented by NP2, where the transport and application layer protocolos for IoT in the Internet are covered Subject program and evaluation methodology Program and evaluation Professor Christian Tenllado (tenllado@ucm.es) Work paper work assignment Here you can find description about this individual assignment Final programming project (teams of 2 people) Once ready you will find here the details on the final project for this course. Work groups (for regular lab assignments) Here you can find the current work groups Quizzes For all quizzes will you are requested to use your e-mail address as name. All of them can be accessed directly from this link . Schedule Day/Month Topic Lab instructions Deliverable 19/01 Basic Concepts 20/01 Basic Concepts 2 and Wifi-1 Quiz 1 26/01 Wifi-1 Quiz 2 27/01 Wifi-2 Quiz 3 02/02 Week off (Chinese new year) 03/02 Week off (Chinese new year) 09/02 Lab 1. Introduction to ESP-IDF Lab 1. instructions Tasks 1.1-1.3 10/02 Lab 1. Introduction to ESP-IDF Lab 1. instructions Tasks 1.4-1.6 16/02 Lab 2. Wifi in ESP-IDF Lab 2. instructions Tasks 2.1-2.4 17/02 Lab 3. Wifi mesh and provisioning Lab 3. instructions Tasks 3.1-3.2 23/02 BLE-1 Quiz 24/02 Lab 3. Wifi mesh and provisioning Lab 3. instructions Tasks 3.3-3.4 02/03 BLE-2 and BLE-Mesh Quiz 03/03 Lab 4. Bluetooth Low Energy Lab 4. instructions Task 4.1 09/03 Lab 4. Bluetooth Low Energy Lab 4. instructions Task 4.2 10/03 Lab 5. Bluetooth Mesh Lab 5. instructions Task 5.1 16/03 Lab 5. Bluetooth Mesh Lab 5. instructions Task 5.2 17/03 802.15.4 , 6LoWPAN , 6LoWPAN-RPL Quiz 23/03 Lab 6. 6LoWPAN, RPL Lab 6. instructions 24/03 LPWAN Quiz 30/03 Work on Final Project 31/03 Work on Final Project 06/04 Work on Final Project 07/04 Work on Final Project","title":"NP1"},{"location":"Subjects/NP1/#networks-and-protocols-1","text":"","title":"Networks and Protocols 1"},{"location":"Subjects/NP1/#general-information","text":"This subject will cover the networking technologies used in IoT systems. Some specific goals if this subject are: 802.11 family Bluetooth Low Energy 802.15.4 and 6LoWPAN LPWAN, Lora This subject is complemented by NP2, where the transport and application layer protocolos for IoT in the Internet are covered","title":"General information"},{"location":"Subjects/NP1/#subject-program-and-evaluation-methodology","text":"Program and evaluation","title":"Subject program and evaluation methodology"},{"location":"Subjects/NP1/#professor","text":"Christian Tenllado (tenllado@ucm.es)","title":"Professor"},{"location":"Subjects/NP1/#work-paper-work-assignment","text":"Here you can find description about this individual assignment","title":"Work paper work assignment"},{"location":"Subjects/NP1/#final-programming-project-teams-of-2-people","text":"Once ready you will find here the details on the final project for this course.","title":"Final programming project (teams of 2 people)"},{"location":"Subjects/NP1/#work-groups-for-regular-lab-assignments","text":"Here you can find the current work groups","title":"Work groups (for regular lab assignments)"},{"location":"Subjects/NP1/#quizzes","text":"For all quizzes will you are requested to use your e-mail address as name. All of them can be accessed directly from this link .","title":"Quizzes"},{"location":"Subjects/NP1/#schedule","text":"Day/Month Topic Lab instructions Deliverable 19/01 Basic Concepts 20/01 Basic Concepts 2 and Wifi-1 Quiz 1 26/01 Wifi-1 Quiz 2 27/01 Wifi-2 Quiz 3 02/02 Week off (Chinese new year) 03/02 Week off (Chinese new year) 09/02 Lab 1. Introduction to ESP-IDF Lab 1. instructions Tasks 1.1-1.3 10/02 Lab 1. Introduction to ESP-IDF Lab 1. instructions Tasks 1.4-1.6 16/02 Lab 2. Wifi in ESP-IDF Lab 2. instructions Tasks 2.1-2.4 17/02 Lab 3. Wifi mesh and provisioning Lab 3. instructions Tasks 3.1-3.2 23/02 BLE-1 Quiz 24/02 Lab 3. Wifi mesh and provisioning Lab 3. instructions Tasks 3.3-3.4 02/03 BLE-2 and BLE-Mesh Quiz 03/03 Lab 4. Bluetooth Low Energy Lab 4. instructions Task 4.1 09/03 Lab 4. Bluetooth Low Energy Lab 4. instructions Task 4.2 10/03 Lab 5. Bluetooth Mesh Lab 5. instructions Task 5.1 16/03 Lab 5. Bluetooth Mesh Lab 5. instructions Task 5.2 17/03 802.15.4 , 6LoWPAN , 6LoWPAN-RPL Quiz 23/03 Lab 6. 6LoWPAN, RPL Lab 6. instructions 24/03 LPWAN Quiz 30/03 Work on Final Project 31/03 Work on Final Project 06/04 Work on Final Project 07/04 Work on Final Project","title":"Schedule"},{"location":"Subjects/NP1/FinalProject/","text":"Networks and Protocols (NP1 + NP2) Final Programming Project As a last exercise for the two subjects (NP1 and NP2) you will work in teams of 2 people on a project that shows what you have learned from these topics. You will develop (program) a system to monitor the amount of people in a room, by detecting their smartphones, uploading the data to an external server for analysis and visualization. In the following sections we describe what should be covered for the two subjects. Requirements for NP1 Your system should manage a sensor network, formed by your ESP32 nodes. We assume that you could have at least one node per room and that each room has a WiFi access point reachable. In this context: Your nodes should be able to connect to the AP using WiFi, with WPA2-PSK security. Your nodes should provide a provissioning option, so that you can configure the wifi SSID to connect to. You can use a softAP or a BLE provisioning method, that is up to you. Your nodes should use BLE to compute the number of other BLE devices in its range (an estimation of the number of people in its range), using the RSSI to compute the distance to the node (the student should research for methods to compute the distance). Alternatively the student can opt for using a different technology of his choice to estimate the number of people in the room. The node should be configured through the menuconfig system, to establish its parameters: Sampling period. Server where the samples should be sent to (see requirements for NP2). Range of valid distances. etc. Optional Parts for NP1 Optionally you can extend the project incorporating some extra features like the following (these are only ideas, you can also propose some others): Consider an scenario with larger rooms, in which one node is not enough and the wifi AP is not reachable on all points. In this scenario you can use the ESP's wifi-mesh technology to build a mesh of nodes in the room. Study the Over The Air (OTA) features of ESP and prepare your nodes to receive OTA updates from an external server. Together with NP2 you can consider to configure the nodes to trigger the OTA update through MQTT (or any other application protocol you are using). Add a GATT server that allows the node parameters to be configured with a BLE client. Requirements for NP2 The developed system will periodically publish the calculated data for the population of BLE devices in the room, sending it to an external server for further storage and analysis. Specifically, the minimum requirements related with NP2 include: You will select an application-level protocol among those studied in NP2 (or, alternatively, other similar protocols of your interest) and use it for data publishing. Servers/brokers to which data will be sent will be configured via menuconfig , together with the sending period and any other configurable parameter considered useful. You will select and use one of the two data representation methods studied in the course (JSON or CBOR). Data will be gathered by Node-RED and submitted to two different destinations: A dashboard of your election (e.g. Node-RED, Grafana, ...). A database (e.g. MongoDB), where it will be stored together with a timestamp. Optional Parts for NP2 Optionally you can extend the project incorporating some extra features like the following (these are only ideas, you can also propose some others): Use encryption at all levels of the communication (e.g. MQTT). Develop an alarm system that triggers under certain conditions (e.g. when the amount of BLE devices is out of a pre-established range), and sends a notification to the user using external services (e.g. SMS, e-mail, Telegram, ...). Implement bi-directional communication, with the possibility of externally modifying the behavior of the ESP32 (e.g. modifying sampling or sending period).","title":"Networks and Protocols (NP1 + NP2) Final Programming Project"},{"location":"Subjects/NP1/FinalProject/#networks-and-protocols-np1-np2-final-programming-project","text":"As a last exercise for the two subjects (NP1 and NP2) you will work in teams of 2 people on a project that shows what you have learned from these topics. You will develop (program) a system to monitor the amount of people in a room, by detecting their smartphones, uploading the data to an external server for analysis and visualization. In the following sections we describe what should be covered for the two subjects.","title":"Networks and Protocols (NP1 + NP2) Final Programming Project"},{"location":"Subjects/NP1/FinalProject/#requirements-for-np1","text":"Your system should manage a sensor network, formed by your ESP32 nodes. We assume that you could have at least one node per room and that each room has a WiFi access point reachable. In this context: Your nodes should be able to connect to the AP using WiFi, with WPA2-PSK security. Your nodes should provide a provissioning option, so that you can configure the wifi SSID to connect to. You can use a softAP or a BLE provisioning method, that is up to you. Your nodes should use BLE to compute the number of other BLE devices in its range (an estimation of the number of people in its range), using the RSSI to compute the distance to the node (the student should research for methods to compute the distance). Alternatively the student can opt for using a different technology of his choice to estimate the number of people in the room. The node should be configured through the menuconfig system, to establish its parameters: Sampling period. Server where the samples should be sent to (see requirements for NP2). Range of valid distances. etc.","title":"Requirements for NP1"},{"location":"Subjects/NP1/FinalProject/#optional-parts-for-np1","text":"Optionally you can extend the project incorporating some extra features like the following (these are only ideas, you can also propose some others): Consider an scenario with larger rooms, in which one node is not enough and the wifi AP is not reachable on all points. In this scenario you can use the ESP's wifi-mesh technology to build a mesh of nodes in the room. Study the Over The Air (OTA) features of ESP and prepare your nodes to receive OTA updates from an external server. Together with NP2 you can consider to configure the nodes to trigger the OTA update through MQTT (or any other application protocol you are using). Add a GATT server that allows the node parameters to be configured with a BLE client.","title":"Optional Parts for NP1"},{"location":"Subjects/NP1/FinalProject/#requirements-for-np2","text":"The developed system will periodically publish the calculated data for the population of BLE devices in the room, sending it to an external server for further storage and analysis. Specifically, the minimum requirements related with NP2 include: You will select an application-level protocol among those studied in NP2 (or, alternatively, other similar protocols of your interest) and use it for data publishing. Servers/brokers to which data will be sent will be configured via menuconfig , together with the sending period and any other configurable parameter considered useful. You will select and use one of the two data representation methods studied in the course (JSON or CBOR). Data will be gathered by Node-RED and submitted to two different destinations: A dashboard of your election (e.g. Node-RED, Grafana, ...). A database (e.g. MongoDB), where it will be stored together with a timestamp.","title":"Requirements for NP2"},{"location":"Subjects/NP1/FinalProject/#optional-parts-for-np2","text":"Optionally you can extend the project incorporating some extra features like the following (these are only ideas, you can also propose some others): Use encryption at all levels of the communication (e.g. MQTT). Develop an alarm system that triggers under certain conditions (e.g. when the amount of BLE devices is out of a pre-established range), and sends a notification to the user using external services (e.g. SMS, e-mail, Telegram, ...). Implement bi-directional communication, with the possibility of externally modifying the behavior of the ESP32 (e.g. modifying sampling or sending period).","title":"Optional Parts for NP2"},{"location":"Subjects/NP1/groups/","text":"Groups for lecture assignments We will be using the stable groups from NP1 to work during lectures (and after class). Group 1 Rol Full name Speaker BIN ZHANG Speaker (2) Youran Tian Recorder FENGFENG GU Auditor GONGLU ZOU Contributor HONGBIAO CAO Contributor WENYAN LIAO Group 2 Rol Full name Speaker Duan Zhen Recorder Hu Haho Auditor Liu Jinhua Contributor Weilin Zhang Contributor Huang Yujuan Contributor Jun Shou Group 3 Rol Full name Speaker GuanJIE Xiao Speaker (2) DongYang Xu Recorder ShaYuan Shuang Auditor Junyan Guo Contributor Zhijun Hao Contributor Xueqing Zhao Contributor Jiali Gao Group 4 Rol Full name Speaker JIEPING YOU Recorder QINGHONG YU Auditor SUIZHI LIU Contributor TIANFENG LI Contributor WEI REN Contributor XIAZU HU Group 5 Rol Full name Speaker ZHOU Ping Speaker (2) LIAO Yinghua Recorder PAN Jiayun Auditor ZHANG Yi Contributor Shuishi Zhou Contributor Yang Chu Group 6 Rol Full name Speaker Xiaolan Li Recorder Xionglan Luo Auditor Qiuji Chen Contributor Jianchuang Zhang Contributor Yan Zhao Contributor Yongtao He Contributor Zhao Hu","title":"Groups for lecture assignments"},{"location":"Subjects/NP1/groups/#groups-for-lecture-assignments","text":"We will be using the stable groups from NP1 to work during lectures (and after class).","title":"Groups for lecture assignments"},{"location":"Subjects/NP1/groups/#group-1","text":"Rol Full name Speaker BIN ZHANG Speaker (2) Youran Tian Recorder FENGFENG GU Auditor GONGLU ZOU Contributor HONGBIAO CAO Contributor WENYAN LIAO","title":"Group 1"},{"location":"Subjects/NP1/groups/#group-2","text":"Rol Full name Speaker Duan Zhen Recorder Hu Haho Auditor Liu Jinhua Contributor Weilin Zhang Contributor Huang Yujuan Contributor Jun Shou","title":"Group 2"},{"location":"Subjects/NP1/groups/#group-3","text":"Rol Full name Speaker GuanJIE Xiao Speaker (2) DongYang Xu Recorder ShaYuan Shuang Auditor Junyan Guo Contributor Zhijun Hao Contributor Xueqing Zhao Contributor Jiali Gao","title":"Group 3"},{"location":"Subjects/NP1/groups/#group-4","text":"Rol Full name Speaker JIEPING YOU Recorder QINGHONG YU Auditor SUIZHI LIU Contributor TIANFENG LI Contributor WEI REN Contributor XIAZU HU","title":"Group 4"},{"location":"Subjects/NP1/groups/#group-5","text":"Rol Full name Speaker ZHOU Ping Speaker (2) LIAO Yinghua Recorder PAN Jiayun Auditor ZHANG Yi Contributor Shuishi Zhou Contributor Yang Chu","title":"Group 5"},{"location":"Subjects/NP1/groups/#group-6","text":"Rol Full name Speaker Xiaolan Li Recorder Xionglan Luo Auditor Qiuji Chen Contributor Jianchuang Zhang Contributor Yan Zhao Contributor Yongtao He Contributor Zhao Hu","title":"Group 6"},{"location":"Subjects/NP1/paperProject/","text":"Group paper work Together with your lab group, you need to prepare a paper work, as explained in the slides of the first class Presentation . It is a documentation work in which you are requested to explore an document yourself on one of the networking technologies used for or focused on IoT systems. The technologies proposed are listed bellow. You are requested to focus the study on its use in your local area or China, however you can expand it to Asia or the whole world if you feel like doing it (not required). In both cases you should study not only the technical aspects of the technology, you should also include known use cases (in the case of choosing one of the technologies proposed below), expected growth of the technology, direct competitors and potential future market share. List of networking technologies you can consider The networking technologies for the paper work shall not overlap between groups, you should request one of the topics sending a mail to the professor (tenllado@ucm.es), who will confirm if you can choose the topic or if it has been already chosen by other group. The topics are: 5G Narrow Band IoT (NBIoT) LoRa SigFox Zigbee Thread and Open Thread DotDot and Thread Practical use case study of 6LoWPAN networks Network Technologies for Smart Buildings Network Technologies for Industry 4.0 Wifi Mesh technologies Network Technologies for Domotics (home automation) Practical use case of any of the studed technologies Deadline Originally 8th April. Delivering the project Once finished, please send me an email (to tenllado@ucm.es)","title":"Group paper work"},{"location":"Subjects/NP1/paperProject/#group-paper-work","text":"Together with your lab group, you need to prepare a paper work, as explained in the slides of the first class Presentation . It is a documentation work in which you are requested to explore an document yourself on one of the networking technologies used for or focused on IoT systems. The technologies proposed are listed bellow. You are requested to focus the study on its use in your local area or China, however you can expand it to Asia or the whole world if you feel like doing it (not required). In both cases you should study not only the technical aspects of the technology, you should also include known use cases (in the case of choosing one of the technologies proposed below), expected growth of the technology, direct competitors and potential future market share.","title":"Group paper work"},{"location":"Subjects/NP1/paperProject/#list-of-networking-technologies-you-can-consider","text":"The networking technologies for the paper work shall not overlap between groups, you should request one of the topics sending a mail to the professor (tenllado@ucm.es), who will confirm if you can choose the topic or if it has been already chosen by other group. The topics are: 5G Narrow Band IoT (NBIoT) LoRa SigFox Zigbee Thread and Open Thread DotDot and Thread Practical use case study of 6LoWPAN networks Network Technologies for Smart Buildings Network Technologies for Industry 4.0 Wifi Mesh technologies Network Technologies for Domotics (home automation) Practical use case of any of the studed technologies","title":"List of networking technologies you can consider"},{"location":"Subjects/NP1/paperProject/#deadline","text":"Originally 8th April.","title":"Deadline"},{"location":"Subjects/NP1/paperProject/#delivering-the-project","text":"Once finished, please send me an email (to tenllado@ucm.es)","title":"Delivering the project"},{"location":"Subjects/NP1/P1/","text":"Lab 1. Introduction to the ESP-IDF development environment ESP-IDF ( Espressif IoT Development Framework ) is the official development environment from Espressif for ESP32 and ESP32-S SoCs. It allows to develop efficient firmwares for said boards using the WiFi and Bluetooth communication interfaces, as well how to manage multiple characteristics of the SoCs that we will be covering in future practices. ESP-IDF uses FreeRTOS as RTOS for the construction of the firmware , although it adds a multitude of components to offer support for higher level interaction with communication protocols, both low and high level, most of them in the field of the Internet of Things. This lab assignment is intended to be a basic introduction to setting up running the ESP-IDF development environment on a Linux operating system, offering two basic alternatives: command line and a specific plugin for VSCode (PlatformIO). In addition, we will see in a superficial way the basic structure of a simple program developed using ESP-IDF, as well as examples basic for the start-up of the WiFi interface on an ESP32 board. Work flow. Commnad line toolset Installation of prerequisites ESP-IDF requires certain software packages installed on the system in order to develop the codes and download them onto the ESP32. Below we show the requirements and installation process for Ubuntu/Debian based machines (like the virtual machine used for this course), although the ESP-IDF documentation includes instructions for other distributions and operating systems, including Windows and MacOS. In your virtual machine, install the necessary packages using (like Super user): sudo apt install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util In addition, it is necessary for the user to belong to the dialout group (you can edit the /etc/group file by adding your user to the line that indicates the corresponding group, and starting again your session). Alternativelly you can use the adduser command. Check the version of python that your system is using: python --version If it is not a version 3 but a version 2, you should install python3 on your system and make it the default python. In modern debian based distros python3 is already de default and you can install the python-is-python3 package to have a symbolic link called python pointing to python3. sudo apt install python-is-python3 Obtaining ESP-IDF We will use the versions of ESP-IDF obtained directly from the official Github repository. For it, run from your home directory: mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git submodule update --init --recursive Installation of additional tools From the esp-idf directory, run the install.sh script to install the tools ( toolchain ) specific to your version: sh install.sh Environment preparation After the start of each session, you will need to set correct values for certain environment variables. Fortunately a script is provided ( export.sh ) which will allow you to set them automatically: . export.sh You can add this line to any login file so you don't have I run the command every time (for instance to your $HOME/.bashrc). In any case, at this point you should have access to a program called idf.py , that will be used to manage the workflow. Check it out. Project preparation In this first part, we will use a simple code example. The goal is not to analyze in detail the the structure of that code (at least not for now), but to use it to illustrate the typical workflow in an ESP-IDF project. Remember After executing the export.sh script, you will have an environment variable defined named IDF_PATH . Check its value and check that it points, effectively, to the IDF installation directory. We will use it at from now on to refer to it. To get started, take the hello_world example provided as part of the installation IDF basic, and copy it to any directory on the filesystem: cp -R $IDF_PATH/examples/get-started/hello_world $HOME/ cd $HOME/hello_world Build The basic build process uses the idf.py script: idf.py build If everything went well, the object files will have been generated and stored in the build directory, and the binaries will be ready to be flashed on the ESP32. Flash Connect the ESP32 using the microUSB cable, and if you are working in a virtual machine, you have to make it visible to the hosted OS (for example, in VirtualBox, through the menu Devices->USB->Silicon Labs USB to UART Bridge Controller ). In any case, the output of the dmesg command after connecting the device will provide you with information about the PORT that you should use in the flash process and subsequent monitoring. The basic flash process uses the idf.py script: idf.py -p flash PORT Monitoring If everything went well, the monitoring process will allow you to observe the output of the program that is running on the board. For this we use again the idf.py script: idf.py -p PORT monitor Note Check that, you can indeed carry out the compilation process, flash and monitoring the program on the ESP32 board. Remember that the EN button, right next to the microUSB connector, will force a resetting it. Work flow. PlatformIO and vscode IDE The above workflow can also be developed from other development environments. In our case, the main steps are shown below for ESP-IDF integration with VSCode, using PlatformIO . The virtual machines provided in the course already have the latest version of PlatformIO and ESP-IDF installed, so we refer the reader to the official PlatformIO documentation to perform such installation on other operating systems. Setting up a project The easiest way to create a new project is to press the button PlatformIO Home located at the bottom of the screen: Next, click on New Project and select as development board ESP DevkitC or Espressif ESP32 Dev Module . Select ESP-IDF as a development framework for the project: Adding files to a project Create a new main.c file in the src directory of your project, or modify the one that already exists using, for example, the following code: #include <string.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_wifi.h\" #include \"esp_event.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"lwip/err.h\" #include \"lwip/sys.h\" #define EXAMPLE_ESP_WIFI_SSID \"mywifissid\" #define EXAMPLE_ESP_WIFI_PASS \"mywifipass\" #define EXAMPLE_MAX_STA_CONN (3) static const char *TAG = \"wifi softAP\"; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_id == WIFI_EVENT_AP_STACONNECTED) { wifi_event_ap_staconnected_t* event = (wifi_event_ap_staconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" join, AID=%d\", MAC2STR(event->mac), event->aid); } else if (event_id == WIFI_EVENT_AP_STADISCONNECTED) { wifi_event_ap_stadisconnected_t* event = (wifi_event_ap_stadisconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" leave, AID=%d\", MAC2STR(event->mac), event->aid); } } void wifi_init_softap() { tcpip_adapter_init(); ESP_ERROR_CHECK(esp_event_loop_create_default()); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&cfg)); ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL)); wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); ESP_ERROR_CHECK(esp_wifi_start()); ESP_LOGI(TAG, \"wifi_init_softap finished. SSID:%s password:%s\", EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS); } void app_main() { //Initialize NVS esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK(ret); ESP_LOGI(TAG, \"ESP_WIFI_MODE_AP\"); wifi_init_softap(); } We will not analyze for the moment the operation of the code (we will do that later), it basically it establishes a wireless Access Point open to connections authenticated via WPA2. Project Build To build the project, display the Command Palette (menu View->Command Palette ) and run the PlatformIO: Build command from it. You can also press the Build button (in the form of check ) in the bottom bar of PlatformIO: If all went well, you should see a final message similar to the following in the system terminal: Project flashing To upload the project to the board, we can use the command PlatformIO: Upload through the command palette, or press the corresponding button on the bottom bar (with a symbol left arrow): Project monitoring Finally, we can monitor the project using the command PlatformIO: Monitor from the command palette or through the bottom bar, using the button with a plug as a symbol: Analysis of a simple project ( Hello world ) in ESP-IDF Note The following tasks can be performed from the command line or by using PlatformIO. We nevertheless suggest you to use the lower level command line toolset to become familiar with it. Look at the general structure of the hello_world directory that you compiled previously. Specifically, we will be interested in inspecting the basic structure of a main program for ESP-IDF, in this case hello_world_main.c . #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" void app_main(void) { printf(\"Hello world!\\n\"); /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } At a high level, the app_main function is the entry point to every program developed using ESP-IDF. More specifically, after the system load , the so called main task runs the code provided by the user and implemented in the app_main function. Both the amount of its stack and its priority can be configured by the developer through the ESP-IDF configuration system (as we will see later). Typically this function is used to carry out initial configuration tasks or to create and launch other tasks. Anyhow, as in this case, any functionality can be implemented inside the app_main function. In this example, some generic information about the SoC that is running the firmware is shown in first place: /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); Then, within a simple loop, the system displays a message and defers the execution of the task for a specified period of time using the vTaskDelay function from FreeRTOS. This function receives the number of clock ticks you want to delay. The example uses the constant portTIC_PERIOD_MS to compute the number of ticks for 1000 ms: for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } Finally, the task reboots the system after the completion of the main task: printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); Task 1.1 Modify the suspension period of the task so that it is larger or smaller, and check that this effectively modifies the behavior of the loaded firmware . Modify the program so that it is also showd on the screen wether the SoC has WiFi capabilities and includes FLASH memory (you can refer to the following page ). Task creation The previous project can be redesigned to create an additiona task to execute the logic of the program instead of having the main FreeRTOS task executing it. To do this, we need to briefly introduce the basic FreeRTOS API for task management. The xTaskCreate function (included in task.h ) creates a new task: BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); Specifically, it creates a new task and adds it to the list of ready to run tasks, receiving as parameters: pvTaskCode : a pointer to the input function for the task. Tasks are usually implemented as an infinite loop, and should not return or end abruptly. A task can be externally destroyed via its handler (last parameter in the creation), or internally (from the task code itself), as as shown in the following example taken directly from the FreeRTOS documentation: void vATaskFunction( void *pvParameters ) { for( ;; ) { -- Task application code here. -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS port attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete( NULL ); } pcName : Descriptive name (in string form) of the task to be executed, helpfull for debugging purposes. usStackDepth : size in words of the stack for the task. pvParameters : parameters to the entry function of the task. uxPriority : priority assigned to the task. pxCreatedTask : optional handle for the task. Thus, the functionality of the Hello, world program that we analyzed above could be restructured using a single task: void hello_task(void *pvParameter) { printf(\"Hello world!\\n\"); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_RATE_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } And the task could be created from the main task: void app_main() { nvs_flash_init(); xTaskCreate( &hello_task, \"hello_task\", 2048, NULL, 5, NULL ); } Task 1.2 Implement a modification of the hello_world program that uses two independent tasks with different functionality (in this case it is enough to only show a different messaga on the screen) and different suspension times. Check that, indeed, both tasks are run concurrently. Project customization ESP-IDF uses the kconfiglib library to provide a system of Simple and extensible compile-time project setup. To illustrate its operation, we will use the blink example, that can be found in the ESP-IDF distribution that you cloned earlier (copy the example to any point in your directory hierarchy before you begin). To configure the ESP-IDF project, simply use the following command: idf.py menuconfig Executing the above command will allow you to browse a set of general options, which will allow you to configure the characteristics specific to the project (for example, selecting the components that you want to enable in its build). Task Navigate through the options that appear in the setup menus to familiarize yourself with them. You will use them in future practices. In the blink project, notice that one of the menu options, called Example configuration , includes an option called Blink GPIO number . Beyond its functionality (it defines the number of GPIO pin to enable/disable), it is of interest to us that this configuration option will define at compile time the value of a constant (a C preprocessor macro, in this case CONFIG_BLINK_GPIO ) that can be used in any file of our project. Note Observe how the CONFIG_BLINK_GPIO constant is used in the code of the blink project. This configuration option is not part of the default options of ESP-IDF, but has been added by the developers of the blink project. Observe and study the format and content of the file main/Kconfig.projbuild , provided as part of the project. It defines the characteristics (name, range, default value and description) of the new configuration option. Task 1.3 Modify the hello_world project so that it defines two configuration options, that will allow to specify the wait time for each of the two tasks that you have defined in your previous solution (Task 1.2). Make use of them in your code and verify that indeed its modification through the menu system allows a customization of the behavior of your codes. Management of WiFi networks. Example 1. WiFi network scanning As an example, and in preparation for the codes with which we will work in future lab assignments, we are going to analyze a concrete example of a firmware that scans the available wireless networks within the reach of the ESP32 node, and reports them through the serial port (we will seem them printed on the screen if we monitor the node). It will report their main characteristics for each of the networks detected. Task 1.4 Copy the example located in the directory examples/wifi/scan to other directory from your home folder. Before compiling it, change the maximum number of networks to scan through in the example setup menu to 20. Create a WiFi access point with your smartphone. Compile the code, flash it and monitor the output, and verify that your network is correctly scanned. Observe its operation. Actually, the firmware just scans a subset of the available networks, reporting some of their characteristics (for example, SSID, Authentication Mode, or Primary Channel). Task 1.5 Analyze the code for the wifi_scan function (main task). Specifically, focus on the lines that enable and configure scanning of networks. Try to understand the general operation of the program, consulting and pointing out the role of each line, with special interest to those functions prefixed with esp_wifi_ * . Write down in a text file the role of each of them, consulting the official documentation . Management of WiFi networks. Example 2. Network event management In this second example you will create a firmware that connects the ESP32 as a station to an existing access point. This example will allow you to observe, broadly speaking, the event management system in FreeRTOS/ESP-IDF, that we use to respond to the network events such as obtaining an IP address or successfully connect to an access point. Task Copy the station example located in the directory examples/wifi/getting_started to another folder in your home directory. Before compiling it, modify the SSID of the network to which it will try to connect, as well as the chosen password through the system setup menus (you can use the same access point you created before with your smartphone). Observe its operation. The firmware just initializes the device in station mode (as opposed to the Access Point mode), making a connection to the preconfigured access point through the setup menu. Analyze the code for the wifi_init_sta function. This function, which implements the main task, is basically divided into two parts: Event management . Observe the mechanism by which the reception of an event is associated with the execution of a specific handler function previously registered. Configuration of the connection to an access point . The connection configuration is made through the corresponding fields of a wifi_config_t structure. Look at the basic fields you need, how the use of WPA2 is enforced and how it collects connection data (SSID and password) through the configuration system. Observe also how the wireless communication system is initialized by the esp_wifi_start() call. Task 1.6 Modify the firmware so that it can use a different handler for the event of acquiring an IP address and the rest of the events of the WiFi system that are already being handled. Check that, the output associated with said event continues to be observed, even when both functions are different.","title":"Lab 1. Introduction to the ESP-IDF development environment"},{"location":"Subjects/NP1/P1/#lab-1-introduction-to-the-esp-idf-development-environment","text":"ESP-IDF ( Espressif IoT Development Framework ) is the official development environment from Espressif for ESP32 and ESP32-S SoCs. It allows to develop efficient firmwares for said boards using the WiFi and Bluetooth communication interfaces, as well how to manage multiple characteristics of the SoCs that we will be covering in future practices. ESP-IDF uses FreeRTOS as RTOS for the construction of the firmware , although it adds a multitude of components to offer support for higher level interaction with communication protocols, both low and high level, most of them in the field of the Internet of Things. This lab assignment is intended to be a basic introduction to setting up running the ESP-IDF development environment on a Linux operating system, offering two basic alternatives: command line and a specific plugin for VSCode (PlatformIO). In addition, we will see in a superficial way the basic structure of a simple program developed using ESP-IDF, as well as examples basic for the start-up of the WiFi interface on an ESP32 board.","title":"Lab 1. Introduction to the ESP-IDF development environment"},{"location":"Subjects/NP1/P1/#work-flow-commnad-line-toolset","text":"","title":"Work flow. Commnad line toolset"},{"location":"Subjects/NP1/P1/#installation-of-prerequisites","text":"ESP-IDF requires certain software packages installed on the system in order to develop the codes and download them onto the ESP32. Below we show the requirements and installation process for Ubuntu/Debian based machines (like the virtual machine used for this course), although the ESP-IDF documentation includes instructions for other distributions and operating systems, including Windows and MacOS. In your virtual machine, install the necessary packages using (like Super user): sudo apt install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util In addition, it is necessary for the user to belong to the dialout group (you can edit the /etc/group file by adding your user to the line that indicates the corresponding group, and starting again your session). Alternativelly you can use the adduser command. Check the version of python that your system is using: python --version If it is not a version 3 but a version 2, you should install python3 on your system and make it the default python. In modern debian based distros python3 is already de default and you can install the python-is-python3 package to have a symbolic link called python pointing to python3. sudo apt install python-is-python3","title":"Installation of prerequisites"},{"location":"Subjects/NP1/P1/#obtaining-esp-idf","text":"We will use the versions of ESP-IDF obtained directly from the official Github repository. For it, run from your home directory: mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git submodule update --init --recursive","title":"Obtaining ESP-IDF"},{"location":"Subjects/NP1/P1/#installation-of-additional-tools","text":"From the esp-idf directory, run the install.sh script to install the tools ( toolchain ) specific to your version: sh install.sh","title":"Installation of additional tools"},{"location":"Subjects/NP1/P1/#environment-preparation","text":"After the start of each session, you will need to set correct values for certain environment variables. Fortunately a script is provided ( export.sh ) which will allow you to set them automatically: . export.sh You can add this line to any login file so you don't have I run the command every time (for instance to your $HOME/.bashrc). In any case, at this point you should have access to a program called idf.py , that will be used to manage the workflow. Check it out.","title":"Environment preparation"},{"location":"Subjects/NP1/P1/#project-preparation","text":"In this first part, we will use a simple code example. The goal is not to analyze in detail the the structure of that code (at least not for now), but to use it to illustrate the typical workflow in an ESP-IDF project. Remember After executing the export.sh script, you will have an environment variable defined named IDF_PATH . Check its value and check that it points, effectively, to the IDF installation directory. We will use it at from now on to refer to it. To get started, take the hello_world example provided as part of the installation IDF basic, and copy it to any directory on the filesystem: cp -R $IDF_PATH/examples/get-started/hello_world $HOME/ cd $HOME/hello_world","title":"Project preparation"},{"location":"Subjects/NP1/P1/#build","text":"The basic build process uses the idf.py script: idf.py build If everything went well, the object files will have been generated and stored in the build directory, and the binaries will be ready to be flashed on the ESP32.","title":"Build"},{"location":"Subjects/NP1/P1/#flash","text":"Connect the ESP32 using the microUSB cable, and if you are working in a virtual machine, you have to make it visible to the hosted OS (for example, in VirtualBox, through the menu Devices->USB->Silicon Labs USB to UART Bridge Controller ). In any case, the output of the dmesg command after connecting the device will provide you with information about the PORT that you should use in the flash process and subsequent monitoring. The basic flash process uses the idf.py script: idf.py -p flash PORT","title":"Flash"},{"location":"Subjects/NP1/P1/#monitoring","text":"If everything went well, the monitoring process will allow you to observe the output of the program that is running on the board. For this we use again the idf.py script: idf.py -p PORT monitor Note Check that, you can indeed carry out the compilation process, flash and monitoring the program on the ESP32 board. Remember that the EN button, right next to the microUSB connector, will force a resetting it.","title":"Monitoring"},{"location":"Subjects/NP1/P1/#work-flow-platformio-and-vscode-ide","text":"The above workflow can also be developed from other development environments. In our case, the main steps are shown below for ESP-IDF integration with VSCode, using PlatformIO . The virtual machines provided in the course already have the latest version of PlatformIO and ESP-IDF installed, so we refer the reader to the official PlatformIO documentation to perform such installation on other operating systems.","title":"Work flow. PlatformIO and vscode IDE"},{"location":"Subjects/NP1/P1/#setting-up-a-project","text":"The easiest way to create a new project is to press the button PlatformIO Home located at the bottom of the screen: Next, click on New Project and select as development board ESP DevkitC or Espressif ESP32 Dev Module . Select ESP-IDF as a development framework for the project:","title":"Setting up a project"},{"location":"Subjects/NP1/P1/#adding-files-to-a-project","text":"Create a new main.c file in the src directory of your project, or modify the one that already exists using, for example, the following code: #include <string.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_wifi.h\" #include \"esp_event.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"lwip/err.h\" #include \"lwip/sys.h\" #define EXAMPLE_ESP_WIFI_SSID \"mywifissid\" #define EXAMPLE_ESP_WIFI_PASS \"mywifipass\" #define EXAMPLE_MAX_STA_CONN (3) static const char *TAG = \"wifi softAP\"; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_id == WIFI_EVENT_AP_STACONNECTED) { wifi_event_ap_staconnected_t* event = (wifi_event_ap_staconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" join, AID=%d\", MAC2STR(event->mac), event->aid); } else if (event_id == WIFI_EVENT_AP_STADISCONNECTED) { wifi_event_ap_stadisconnected_t* event = (wifi_event_ap_stadisconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" leave, AID=%d\", MAC2STR(event->mac), event->aid); } } void wifi_init_softap() { tcpip_adapter_init(); ESP_ERROR_CHECK(esp_event_loop_create_default()); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&cfg)); ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL)); wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); ESP_ERROR_CHECK(esp_wifi_start()); ESP_LOGI(TAG, \"wifi_init_softap finished. SSID:%s password:%s\", EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS); } void app_main() { //Initialize NVS esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK(ret); ESP_LOGI(TAG, \"ESP_WIFI_MODE_AP\"); wifi_init_softap(); } We will not analyze for the moment the operation of the code (we will do that later), it basically it establishes a wireless Access Point open to connections authenticated via WPA2.","title":"Adding files to a project"},{"location":"Subjects/NP1/P1/#project-build","text":"To build the project, display the Command Palette (menu View->Command Palette ) and run the PlatformIO: Build command from it. You can also press the Build button (in the form of check ) in the bottom bar of PlatformIO: If all went well, you should see a final message similar to the following in the system terminal:","title":"Project Build"},{"location":"Subjects/NP1/P1/#project-flashing","text":"To upload the project to the board, we can use the command PlatformIO: Upload through the command palette, or press the corresponding button on the bottom bar (with a symbol left arrow):","title":"Project flashing"},{"location":"Subjects/NP1/P1/#project-monitoring","text":"Finally, we can monitor the project using the command PlatformIO: Monitor from the command palette or through the bottom bar, using the button with a plug as a symbol:","title":"Project monitoring"},{"location":"Subjects/NP1/P1/#analysis-of-a-simple-project-hello-world-in-esp-idf","text":"Note The following tasks can be performed from the command line or by using PlatformIO. We nevertheless suggest you to use the lower level command line toolset to become familiar with it. Look at the general structure of the hello_world directory that you compiled previously. Specifically, we will be interested in inspecting the basic structure of a main program for ESP-IDF, in this case hello_world_main.c . #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" void app_main(void) { printf(\"Hello world!\\n\"); /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } At a high level, the app_main function is the entry point to every program developed using ESP-IDF. More specifically, after the system load , the so called main task runs the code provided by the user and implemented in the app_main function. Both the amount of its stack and its priority can be configured by the developer through the ESP-IDF configuration system (as we will see later). Typically this function is used to carry out initial configuration tasks or to create and launch other tasks. Anyhow, as in this case, any functionality can be implemented inside the app_main function. In this example, some generic information about the SoC that is running the firmware is shown in first place: /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); Then, within a simple loop, the system displays a message and defers the execution of the task for a specified period of time using the vTaskDelay function from FreeRTOS. This function receives the number of clock ticks you want to delay. The example uses the constant portTIC_PERIOD_MS to compute the number of ticks for 1000 ms: for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } Finally, the task reboots the system after the completion of the main task: printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); Task 1.1 Modify the suspension period of the task so that it is larger or smaller, and check that this effectively modifies the behavior of the loaded firmware . Modify the program so that it is also showd on the screen wether the SoC has WiFi capabilities and includes FLASH memory (you can refer to the following page ).","title":"Analysis of a simple project (Hello world) in ESP-IDF"},{"location":"Subjects/NP1/P1/#task-creation","text":"The previous project can be redesigned to create an additiona task to execute the logic of the program instead of having the main FreeRTOS task executing it. To do this, we need to briefly introduce the basic FreeRTOS API for task management. The xTaskCreate function (included in task.h ) creates a new task: BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); Specifically, it creates a new task and adds it to the list of ready to run tasks, receiving as parameters: pvTaskCode : a pointer to the input function for the task. Tasks are usually implemented as an infinite loop, and should not return or end abruptly. A task can be externally destroyed via its handler (last parameter in the creation), or internally (from the task code itself), as as shown in the following example taken directly from the FreeRTOS documentation: void vATaskFunction( void *pvParameters ) { for( ;; ) { -- Task application code here. -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS port attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete( NULL ); } pcName : Descriptive name (in string form) of the task to be executed, helpfull for debugging purposes. usStackDepth : size in words of the stack for the task. pvParameters : parameters to the entry function of the task. uxPriority : priority assigned to the task. pxCreatedTask : optional handle for the task. Thus, the functionality of the Hello, world program that we analyzed above could be restructured using a single task: void hello_task(void *pvParameter) { printf(\"Hello world!\\n\"); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_RATE_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } And the task could be created from the main task: void app_main() { nvs_flash_init(); xTaskCreate( &hello_task, \"hello_task\", 2048, NULL, 5, NULL ); } Task 1.2 Implement a modification of the hello_world program that uses two independent tasks with different functionality (in this case it is enough to only show a different messaga on the screen) and different suspension times. Check that, indeed, both tasks are run concurrently.","title":"Task creation"},{"location":"Subjects/NP1/P1/#project-customization","text":"ESP-IDF uses the kconfiglib library to provide a system of Simple and extensible compile-time project setup. To illustrate its operation, we will use the blink example, that can be found in the ESP-IDF distribution that you cloned earlier (copy the example to any point in your directory hierarchy before you begin). To configure the ESP-IDF project, simply use the following command: idf.py menuconfig Executing the above command will allow you to browse a set of general options, which will allow you to configure the characteristics specific to the project (for example, selecting the components that you want to enable in its build). Task Navigate through the options that appear in the setup menus to familiarize yourself with them. You will use them in future practices. In the blink project, notice that one of the menu options, called Example configuration , includes an option called Blink GPIO number . Beyond its functionality (it defines the number of GPIO pin to enable/disable), it is of interest to us that this configuration option will define at compile time the value of a constant (a C preprocessor macro, in this case CONFIG_BLINK_GPIO ) that can be used in any file of our project. Note Observe how the CONFIG_BLINK_GPIO constant is used in the code of the blink project. This configuration option is not part of the default options of ESP-IDF, but has been added by the developers of the blink project. Observe and study the format and content of the file main/Kconfig.projbuild , provided as part of the project. It defines the characteristics (name, range, default value and description) of the new configuration option. Task 1.3 Modify the hello_world project so that it defines two configuration options, that will allow to specify the wait time for each of the two tasks that you have defined in your previous solution (Task 1.2). Make use of them in your code and verify that indeed its modification through the menu system allows a customization of the behavior of your codes.","title":"Project customization"},{"location":"Subjects/NP1/P1/#management-of-wifi-networks-example-1-wifi-network-scanning","text":"As an example, and in preparation for the codes with which we will work in future lab assignments, we are going to analyze a concrete example of a firmware that scans the available wireless networks within the reach of the ESP32 node, and reports them through the serial port (we will seem them printed on the screen if we monitor the node). It will report their main characteristics for each of the networks detected. Task 1.4 Copy the example located in the directory examples/wifi/scan to other directory from your home folder. Before compiling it, change the maximum number of networks to scan through in the example setup menu to 20. Create a WiFi access point with your smartphone. Compile the code, flash it and monitor the output, and verify that your network is correctly scanned. Observe its operation. Actually, the firmware just scans a subset of the available networks, reporting some of their characteristics (for example, SSID, Authentication Mode, or Primary Channel). Task 1.5 Analyze the code for the wifi_scan function (main task). Specifically, focus on the lines that enable and configure scanning of networks. Try to understand the general operation of the program, consulting and pointing out the role of each line, with special interest to those functions prefixed with esp_wifi_ * . Write down in a text file the role of each of them, consulting the official documentation .","title":"Management of WiFi networks. Example 1. WiFi network scanning"},{"location":"Subjects/NP1/P1/#management-of-wifi-networks-example-2-network-event-management","text":"In this second example you will create a firmware that connects the ESP32 as a station to an existing access point. This example will allow you to observe, broadly speaking, the event management system in FreeRTOS/ESP-IDF, that we use to respond to the network events such as obtaining an IP address or successfully connect to an access point. Task Copy the station example located in the directory examples/wifi/getting_started to another folder in your home directory. Before compiling it, modify the SSID of the network to which it will try to connect, as well as the chosen password through the system setup menus (you can use the same access point you created before with your smartphone). Observe its operation. The firmware just initializes the device in station mode (as opposed to the Access Point mode), making a connection to the preconfigured access point through the setup menu. Analyze the code for the wifi_init_sta function. This function, which implements the main task, is basically divided into two parts: Event management . Observe the mechanism by which the reception of an event is associated with the execution of a specific handler function previously registered. Configuration of the connection to an access point . The connection configuration is made through the corresponding fields of a wifi_config_t structure. Look at the basic fields you need, how the use of WPA2 is enforced and how it collects connection data (SSID and password) through the configuration system. Observe also how the wireless communication system is initialized by the esp_wifi_start() call. Task 1.6 Modify the firmware so that it can use a different handler for the event of acquiring an IP address and the rest of the events of the WiFi system that are already being handled. Check that, the output associated with said event continues to be observed, even when both functions are different.","title":"Management of WiFi networks. Example 2. Network event management"},{"location":"Subjects/NP1/P2/","text":"Lab 2. WiFi in ESP32 Goals Familiarize yourself with the workflow of the WiFi driver in ESP-IDF. Understand the difference between station and AP modes. Develop firmware that can work as AP for others and as station to connect to another AP. Understand the network scanning mechanisms in ESP-IDF. Introduction The ESP-IDF WiFi libraries and components provide support to configure and monitor 802.11 connections on ESP32 boards. This includes settings for: Station mode (WiFi client mode, or STA ). In this case, the ESP32 connects to a preconfigured access point. AP mode (also called softAP or Access Point mode). In this case, other stations can connect to the ESP32. AP-STA combined mode, where ESP32 is concurrently acting as an access point and a station connected to another access point. Various security modes in both client mode and AP mode (WPA, WPA2, WEP, etc.) Access point scanning (active and passive). Key provisioning and WPS mode. Promiscuous mode for IEEE 802.11 packet monitoring. In the present lab we will study through basic examples the main features supported by the WiFi driver. All these characteristics can be used later for the development of codes and more complex projects with minimal modifications. ESP32 Wi-Fi Programming Model The ESP32 Wi-Fi programming model can be described with the following figure: The Wi-Fi driver can be considered a black box that knows nothing about high-layer code, such as the TCP/IP stack, application task, event task, etc. The application task (code) generally calls Wi-Fi driver APIs to initialize Wi-Fi and handles Wi-Fi events when necessary. Wi-Fi driver receives API calls, handles them, and post events to the application. Wi-Fi event handling is based on the esp_event library . Events are sent by the Wi-Fi driver to the default event loop . Application may handle these events in callbacks registered using esp_event_handler_register() . Wi-Fi events are also handled by esp_netif component to provide a set of default behaviors. For example, when Wi-Fi station connects to an AP, esp_netif will automatically start the DHCP client by default (even though this Default behavior can be customized to, for example, assign an IP address statically). Note All the API mentioned below is described in depth in this link . It is advisable to have this information during the process as well as in this lab document. WiFi events The following list shows the description of the wifi events that are handled in the example codes we work through in this lab assignment. WIFI_EVENT_SCAN_DONE The scan-done event is triggered by esp_wifi_scan_start() and will arise in the following scenarios: - The scan is completed, e.g., the target AP is found successfully, or all channels have been scanned. - The scan is stopped by esp_wifi_scan_stop() . - The esp_wifi_scan_start() is called before the scan is completed. A new scan will override the current scan and a scan-done event will be generated. The scan-done event will not arise in the following scenarios: - It is a blocked scan. - The scan is caused by esp_wifi_connect() . Upon receiving this event, the event task does nothing. The application event callback needs to call esp_wifi_scan_get_ap_num() and esp_wifi_scan_get_ap_records() to fetch the scanned AP list and trigger the Wi-Fi driver to free the internal memory which is allocated during the scan (do not forget to do this!). Refer to ESP32 Wi-Fi Scan for a more detailed description. WIFI_EVENT_STA_START If esp_wifi_start() returns ESP_OK and the current Wi-Fi mode is station or station/AP, then this event will arise. Upon receiving this event, the event task will initialize the LwIP network interface (netif). Generally, the application event callback needs to call esp_wifi_connect() to connect to the configured AP. WIFI_EVENT_STA_STOP If esp_wifi_stop() returns ESP_OK and the current Wi-Fi mode is station or station/AP, then this event will arise. Upon receiving this event, the event task will release the station\u2019s IP address, stop the DHCP client, remove TCP/UDP-related connections and clear the LwIP station netif, etc. The application event callback generally does not need to do anything. WIFI_EVENT_STA_CONNECTED If esp_wifi_connect() returns ESP_OK and the station successfully connects to the target AP, the connection event will arise. Upon receiving this event, the event task starts the DHCP client and begins the DHCP process of getting the IP address. Then, the Wi-Fi driver is ready for sending and receiving data. This moment is good for beginning the application work, provided that the application does not depend on LwIP, namely the IP address. However, if the application is LwIP-based, then you need to wait until the got ip event WIFI_EVENT_STA_GOT_IP comes in. WIFI_EVENT_STA_DISCONNECTED This event can be generated in the following scenarios: When esp_wifi_disconnect() , or esp_wifi_stop() is called and the station is already connected to the AP. When esp_wifi_connect() is called, but the Wi-Fi driver fails to set up a connection with the AP due to certain reasons, e.g. the scan fails to find the target AP, authentication times out, etc. If there are more than one AP with the same SSID, the disconnected event is raised after the station fails to connect all of the found APs. When the Wi-Fi connection is disrupted because of specific reasons, e.g., the station continuously loses N beacons, the AP kicks off the station, the AP\u2019s authentication mode is changed, etc. Upon receiving this event, the default behavior of the event task is to: - Shut down the station\u2019s LwIP netif. Notify the LwIP task to clear the UDP/TCP connections which cause the wrong status to all sockets. For socket-based applications, the application callback can choose to close all sockets and re-create them, if necessary, upon receiving this event. The most common event handle code for this event in application is to call esp_wifi_connect() to reconnect the Wi-Fi. However, if the event is raised because esp_wifi_disconnect() is called, the application should not call esp_wifi_connect() to reconnect. It\u2019s application\u2019s responsibility to distinguish whether the event is caused by esp_wifi_disconnect() or other reasons. IP_EVENT_STA_GOT_IP (was WIFI_EVENT_STA_GOT_IP ) This event arises when the DHCP client successfully gets the IPV4 address from the DHCP server, or when the IPV4 address is changed. The event means that everything is ready and the application can begin its tasks (e.g., creating sockets). The IPV4 may be changed because of the following reasons: - The DHCP client fails to renew/rebind the IPV4 address, and the station\u2019s IPV4 is reset to 0. - The DHCP client rebinds to a different address. - The static-configured IPV4 address is changed. Whether the IPV4 address is changed or NOT is indicated by field ip_change of ip_event_got_ip_t. The socket is based on the IPV4 address, which means that, if the IPV4 changes, all sockets relating to this IPV4 will become abnormal. Upon receiving this event, the application needs to close all sockets and recreate the application when the IPV4 changes to a valid one. IP_STA_LOST_IP (was WIFI_EVENT_STA_LOST_IP ) This event arises when the IPV4 address become invalid. IP_STA_LOST_IP doesn\u2019t arise immediately after the Wi-Fi disconnects, instead it starts an IPV4 address lost timer, if the IPV4 address is got before ip lost timer expires, IP_EVENT_STA_LOST_IP doesn\u2019t happen. Otherwise, the event arises when IPV4 address lost timer expires. Generally the application don\u2019t need to care about this event, it is just a debug event to let the application know that the IPV4 address is lost. WIFI_EVENT_STA_START If esp_wifi_start() returns ESP_OK and the current Wi-Fi mode is station or station/AP, then this event will arise. Upon receiving this event, the event task will initialize the LwIP network interface (netif). Generally, the application event callback needs to call esp_wifi_connect() to connect to the configured AP. WIFI_EVENT_AP_START Similar to WIFI_EVENT_STA_START WIFI_EVENT_AP_STACONNECTED Every time a station is connected to ESP32 AP, the WIFI_EVENT_AP_STACONNECTED will arise. Upon receiving this event, the event task will do nothing, and the application callback can also ignore it. However, you may want to do something, for example, to get the info of the connected STA, etc. WIFI_EVENT_AP_STADISCONNECTED This event can happen in the following scenarios: - The application calls esp_wifi_disconnect() , or esp_wifi_deauth_sta() , to manually disconnect the station. - The Wi-Fi driver kicks off the station, e.g. because the AP has not received any packets in the past five minutes, etc. The time can be modified by esp_wifi_set_inactive_time() . - The station kicks off the AP. When this event happens, the event task will do nothing, but the application event callback needs to do something, e.g., close the socket which is related to this station, etc. Station Mode The figure describes some usual scenarios in station mode: The main phases in this mode are analyzed below (not all of them have to be present necessarily in all settings). 1. WiFi/LwIP Init Phase The following 1-5 steps are the recommended sequence to initialize a Wi-Fi-/LwIP-based application: The main task calls esp_netif_init() to create an LwIP core task and initialize LwIP-related work. The main task calls esp_event_loop_create() to create a system Event task and initialize an application event\u2019s callback function. In the scenario above, the application event\u2019s callback function does nothing but relaying the event to the application task. The main task calls esp_netif_create_default_wifi_ap() or esp_netif_create_default_wifi_sta() to create default network interface instance binding station or AP with TCP/IP stack. The main task calls esp_wifi_init() to create the Wi-Fi driver task and initialize the Wi-Fi driver. The main task calls OS API to create the application task. However, it is NOT a must-follow sequence, which means that you can create the application task in step 1 and put all other initializations in the application task. Moreover, you may not want to create the application task in the initialization phase if the application task depends on the sockets. Rather, you can defer the task creation until the IP is obtained. 2. WiFi Configuraci\u00f3n Phase Once the Wi-Fi driver is initialized, you can start configuring the Wi-Fi driver. In this scenario, the mode is station, so you may need to call esp_wifi_set_mode() ( WIFI_MODE_STA ) to configure the Wi-Fi mode as station. You can call other esp_wifi_set_xxx APIs to configure more settings, such as the protocol mode, country code, bandwidth, etc. Refer to ESP32 Wi-Fi Configuration for more information on the operation modes. Generally, we configure the Wi-Fi driver before setting up the Wi-Fi connection, but this is NOT mandatory, which means that you can configure the Wi-Fi connection anytime, provided that the Wi-Fi driver is initialized successfully. However, if the configuration does not need to change after the Wi-Fi connection is set up, you should configure the Wi-Fi driver at this stage, because the configuration APIs (such as esp_wifi_set_protocol() ) will cause the Wi-Fi to reconnect, which may not be desirable. The routine esp_wifi_set_config () allows you to configure the basic aspects of the WiFi connection. For example, the following code performs a basic WiFi setup by providing SSID, password, and authentication mode before configuring the connection: wifi_config_t wifi_config = { .sta = { .ssid = EXAMPLE_ESP_WIFI_SSID, .password = EXAMPLE_ESP_WIFI_PASS, .threshold.authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .capable = true, .required = false }, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) ); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) ); 3. WiFi Start Phase Call esp_wifi_start() to start the Wi-Fi driver. The Wi-Fi driver posts WIFI_EVENT_STA_START to the event task; then, the event task will do some common things and will call the application event callback function. The application event callback function relays the WIFI_EVENT_STA_START to the application task. We recommend that you call esp_wifi_connect() . However, you can also call esp_wifi_connect() in other phrases after the WIFI_EVENT_STA_START arises. 4. WiFi Connect Phase Once esp_wifi_connect() is called, the Wi-Fi driver will start the internal scan/connection process. If the internal scan/connection process is successful, the WIFI_EVENT_STA_CONNECTED will be generated. In the event task, it starts the DHCP client, which will finally trigger the DHCP process. In the above-mentioned scenario, the application event callback will relay the event to the application task. Generally, the application needs to do nothing, and you can do whatever you want, e.g., print a log, etc. In step 2, the Wi-Fi connection may fail because, for example, the password is wrong, the AP is not found, etc. In a case like this, WIFI_EVENT_STA_DISCONNECTED will arise and the reason for such a failure will be provided. For handling events that disrupt Wi-Fi connection, please refer to phase 6. 5. Wi-Fi Got IP Phase Once the DHCP client is initialized in step 4.2, the got IP phase will begin. If the IP address is successfully received from the DHCP server, then IP_EVENT_STA_GOT_IP will arise and the event task will perform common handling. In the application event callback, IP_EVENT_STA_GOT_IP is relayed to the application task. For LwIP-based applications, this event is very special and means that everything is ready for the application to begin its tasks, e.g. creating the TCP/UDP socket, etc. A very common mistake is to initialize the socket before IP_EVENT_STA_GOT_IP is received. DO NOT start the socket-related work before the IP is received. 6. WiFi Disconnect Phase When the Wi-Fi connection is disrupted, e.g. because the AP is powered off, the RSSI is poor, etc., WIFI_EVENT_STA_DISCONNECTED will arise. In the scenario described above, the application event callback function relays WIFI_EVENT_STA_DISCONNECTED to the application task. We recommend that esp_wifi_connect() be called to reconnect the Wi-Fi, close all sockets and re-create them if necessary. 7. WiFi IP Change Phase If the IP address is changed, the IP_EVENT_STA_GOT_IP will arise with ip_change field set to true in the ip_event_got_ip_t structure passed to the event handler. This event is important to the application. When it occurs, the timing is good for closing all created sockets and recreating them. 8. WiFi Deinit Phase Call esp_wifi_disconnect() to disconnect the Wi-Fi connectivity. Call esp_wifi_stop() to stop the Wi-Fi driver. Call esp_wifi_deinit() to unload the Wi-Fi driver. Analysis of an example ( wifi/getting_started/station ) Task 2.1 Analyze the station example, compile it and flash it. Study the treatment of events that it carries out, and how these are emitted for real cases. To do this, try the following things: - connect your ESP32 with an existing access point - connect your ESP32 with a non-existent access point - turn off the access point while the IP is granted Do it while you monitor the ESP32 to see the screen messages of the events handlers. If there is no message for one of them modify the code to handle it. Deliver the code and a brief report commenting your observations (pdf format). Access Point Mode The following figure roughly describes some of the main scenarios that can occur in AP (access point) mode: The workflow is very similar to that of station mode, with the difference basic type of WiFi configuration to perform ( WIFI_MODE_AP ) and obviously configuration parameters. Take a look at the following configuration example: wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .channel = EXAMPLE_ESP_WIFI_CHANNEL, .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); For more information on the configuration parameters of an Access Point, check AP Basic Configuration . Analysis of an example ( wifi/getting_started/softAP ) Task 2.2 Analyze the softAP example, compile it and flash it. Study the treatment of events that it carries out, and how these are emitted for real cases. To do it, connect different clients ( stations ), either ESP32 or any another device, and analyze the generated events and their response. If there is no message printed for any of them, add the corresponding handling code. Deliver the code and a small report documenting your observations (pdf format). Combined STA and AP Mode ESP-IDF supports a mixed mode of connection, in which the ESP32 is both an access point (AP) and a station ( station ). This mode is configured using the ESP_MODE_APSTA parameter in the invocation of the routine esp_wifi_set_mode() . Obviously, the code will require two independent wifi_config_t structures, one with the data associated with the point access (field .ap ) mode and another with the fields associated with the station mode ( .sta field). In addition, it will be necessary to invoke the configuration routine ( esp_wifi_set_config ) with each of these structures. And finally, you also need to invoke the initialization of netif both in station mode ( esp_netif_create_default_wifi_sta() ) an in AP mode ( esp_netif_create_default_wifi_ap() ). Exercise: develop a station/AP mixed node Task 2.3 Modify the station example so that the ESP32 behaves at the same time as a station and as an access point. Add the necessary configuration options to be able to set all the parameters via menuconfig . Check that the ESP32 actually connects to the point access and that at the same time it is possible to connect another device to it as a station (for example, your mobile phone). Deliver the developed code. Scanning WiFi networks WiFi Scanning Modes The WiFi network scanning mode (i.e. invoking the routine esp_wifi_scan_start() ) is only supported currently in station or station/AP modes. The different types of network scanning modes are: Mode Description Active Scan Scan by sending a probe request. The default scan is an active scan. Passive Scan No probe request is sent out. Just switch to the specific channel and wait for a beacon. Application can enable it via the scan_type field of wifi_scan_config_t. Foreground Scan This scan is applicable when there is no Wi-Fi connection in station mode. Foreground or background scanning is controlled by the Wi-Fi driver and cannot be configured by the application. Background Scan This scan is applicable when there is a Wi-Fi connection in station mode or in station/AP mode. Whether it is a foreground scan or background scan depends on the Wi-Fi driver and cannot be configured by the application. All-Channel Scan It scans all of the channels. If the channel field of wifi_scan_config_t is set to 0, it is an all-channel scan. Specific Channel Scan It scans specific channels only. If the channel field of wifi_scan_config_t set to 1-14, it is a specific-channel scan. The scan modes in above table can be combined arbitrarily, so we totally have 8 different scans: All-Channel Background Active Scan All-Channel Background Passive Scan All-Channel Foreground Active Scan All-Channel Foreground Passive Scan Specific-Channel Background Active Scan Specific-Channel Background Passive Scan Specific-Channel Foreground Active Scan Specific-Channel Foreground Passive Scan Scan Configuration The scan type and other per-scan attributes are configured by esp_wifi_scan_start() . The table below provides a detailed description of wifi_scan_config_t . Field Description ssid If the SSID is not NULL it is only the AP with the same SSID that can be scanned. bssid If the BSSID is not NULL it is only the AP with the same BSSID that can be scanned. channel If channel is 0 there will be an all-channel scan; otherwise there will be a specific-channel scan. show_hidden If show_hidden is 0 the scan ignores the AP with a hidden SSID; otherwise the scan considers the hidden AP a normal one. scan_type If scan_type is WIFI_SCAN_TYPE_ACTIVE the scan is active ; otherwise it is a passive one. scan_time This field is used to control how long the scan dwells on each channel. See Scan Configuration for more details Scan All APs on All Channels (Foreground) The following figure describes a basic scan over all channels in foreground (remember that it can only occur in station mode when it is not yet connected to an AP). 1. Scan Configuration Phase Call esp_wifi_set_country() to set the country info if the default country info is not what you want, refer to Wi-Fi Country Code. Call esp_wifi_scan_start() to configure the scan. To do so, you can refer to Scan Configuration. Since this is an all-channel scan, just set the SSID/BSSID/channel to 0. 2. WiFi Driver's Internal Scan Phase The Wi-Fi driver switches to channel 1, in case the scan type is WIFI_SCAN_TYPE_ACTIVE , and broadcasts a probe request. Otherwise, the Wi-Fi will wait for a beacon from the APs. The Wi-Fi driver will stay in channel 1 for some time. The dwell time is configured in min/max time, with default value being 120 ms. The Wi-Fi driver switches to channel 2 and performs the same operation as in step 2.1. The Wi-Fi driver scans the last channel N, where N is determined by the country code which is configured in step 1.1. 3. Scan-Done Event Handling Phase When all channels are scanned, WIFI_EVENT_SCAN_DONE will arise. The application\u2019s event callback function notifies the application task that WIFI_EVENT_SCAN_DONE is received. esp_wifi_scan_get_ap_num() is called to get the number of APs that have been found in this scan. Then, it allocates enough entries and calls esp_wifi_scan_get_ap_records() to get the AP records. Please note that the AP records in the Wi-Fi driver will be freed, once esp_wifi_scan_get_ap_records() is called. Do not call esp_wifi_scan_get_ap_records() twice for a single scan-done event. If esp_wifi_scan_get_ap_records() is not called when the scan-done event occurs, the AP records allocated by the Wi-Fi driver will not be freed. So, make sure you call esp_wifi_scan_get_ap_records() , yet only once. Analysis of an example ( wifi/scan ) Analyze the scan example, and try to observe the flow detailed above. Task 2.4 Compile, flash and run the scan sample. See if the results are what you expected in your home environment. Study and modify the waiting times in the scan and see the effect on the scan time. Deliver a brief report with your observations (pdf format).","title":"Lab 2. WiFi in ESP32"},{"location":"Subjects/NP1/P2/#lab-2-wifi-in-esp32","text":"","title":"Lab 2. WiFi in ESP32"},{"location":"Subjects/NP1/P2/#goals","text":"Familiarize yourself with the workflow of the WiFi driver in ESP-IDF. Understand the difference between station and AP modes. Develop firmware that can work as AP for others and as station to connect to another AP. Understand the network scanning mechanisms in ESP-IDF.","title":"Goals"},{"location":"Subjects/NP1/P2/#introduction","text":"The ESP-IDF WiFi libraries and components provide support to configure and monitor 802.11 connections on ESP32 boards. This includes settings for: Station mode (WiFi client mode, or STA ). In this case, the ESP32 connects to a preconfigured access point. AP mode (also called softAP or Access Point mode). In this case, other stations can connect to the ESP32. AP-STA combined mode, where ESP32 is concurrently acting as an access point and a station connected to another access point. Various security modes in both client mode and AP mode (WPA, WPA2, WEP, etc.) Access point scanning (active and passive). Key provisioning and WPS mode. Promiscuous mode for IEEE 802.11 packet monitoring. In the present lab we will study through basic examples the main features supported by the WiFi driver. All these characteristics can be used later for the development of codes and more complex projects with minimal modifications.","title":"Introduction"},{"location":"Subjects/NP1/P2/#esp32-wi-fi-programming-model","text":"The ESP32 Wi-Fi programming model can be described with the following figure: The Wi-Fi driver can be considered a black box that knows nothing about high-layer code, such as the TCP/IP stack, application task, event task, etc. The application task (code) generally calls Wi-Fi driver APIs to initialize Wi-Fi and handles Wi-Fi events when necessary. Wi-Fi driver receives API calls, handles them, and post events to the application. Wi-Fi event handling is based on the esp_event library . Events are sent by the Wi-Fi driver to the default event loop . Application may handle these events in callbacks registered using esp_event_handler_register() . Wi-Fi events are also handled by esp_netif component to provide a set of default behaviors. For example, when Wi-Fi station connects to an AP, esp_netif will automatically start the DHCP client by default (even though this Default behavior can be customized to, for example, assign an IP address statically). Note All the API mentioned below is described in depth in this link . It is advisable to have this information during the process as well as in this lab document.","title":"ESP32 Wi-Fi Programming Model"},{"location":"Subjects/NP1/P2/#wifi-events","text":"The following list shows the description of the wifi events that are handled in the example codes we work through in this lab assignment. WIFI_EVENT_SCAN_DONE The scan-done event is triggered by esp_wifi_scan_start() and will arise in the following scenarios: - The scan is completed, e.g., the target AP is found successfully, or all channels have been scanned. - The scan is stopped by esp_wifi_scan_stop() . - The esp_wifi_scan_start() is called before the scan is completed. A new scan will override the current scan and a scan-done event will be generated. The scan-done event will not arise in the following scenarios: - It is a blocked scan. - The scan is caused by esp_wifi_connect() . Upon receiving this event, the event task does nothing. The application event callback needs to call esp_wifi_scan_get_ap_num() and esp_wifi_scan_get_ap_records() to fetch the scanned AP list and trigger the Wi-Fi driver to free the internal memory which is allocated during the scan (do not forget to do this!). Refer to ESP32 Wi-Fi Scan for a more detailed description. WIFI_EVENT_STA_START If esp_wifi_start() returns ESP_OK and the current Wi-Fi mode is station or station/AP, then this event will arise. Upon receiving this event, the event task will initialize the LwIP network interface (netif). Generally, the application event callback needs to call esp_wifi_connect() to connect to the configured AP. WIFI_EVENT_STA_STOP If esp_wifi_stop() returns ESP_OK and the current Wi-Fi mode is station or station/AP, then this event will arise. Upon receiving this event, the event task will release the station\u2019s IP address, stop the DHCP client, remove TCP/UDP-related connections and clear the LwIP station netif, etc. The application event callback generally does not need to do anything. WIFI_EVENT_STA_CONNECTED If esp_wifi_connect() returns ESP_OK and the station successfully connects to the target AP, the connection event will arise. Upon receiving this event, the event task starts the DHCP client and begins the DHCP process of getting the IP address. Then, the Wi-Fi driver is ready for sending and receiving data. This moment is good for beginning the application work, provided that the application does not depend on LwIP, namely the IP address. However, if the application is LwIP-based, then you need to wait until the got ip event WIFI_EVENT_STA_GOT_IP comes in. WIFI_EVENT_STA_DISCONNECTED This event can be generated in the following scenarios: When esp_wifi_disconnect() , or esp_wifi_stop() is called and the station is already connected to the AP. When esp_wifi_connect() is called, but the Wi-Fi driver fails to set up a connection with the AP due to certain reasons, e.g. the scan fails to find the target AP, authentication times out, etc. If there are more than one AP with the same SSID, the disconnected event is raised after the station fails to connect all of the found APs. When the Wi-Fi connection is disrupted because of specific reasons, e.g., the station continuously loses N beacons, the AP kicks off the station, the AP\u2019s authentication mode is changed, etc. Upon receiving this event, the default behavior of the event task is to: - Shut down the station\u2019s LwIP netif. Notify the LwIP task to clear the UDP/TCP connections which cause the wrong status to all sockets. For socket-based applications, the application callback can choose to close all sockets and re-create them, if necessary, upon receiving this event. The most common event handle code for this event in application is to call esp_wifi_connect() to reconnect the Wi-Fi. However, if the event is raised because esp_wifi_disconnect() is called, the application should not call esp_wifi_connect() to reconnect. It\u2019s application\u2019s responsibility to distinguish whether the event is caused by esp_wifi_disconnect() or other reasons. IP_EVENT_STA_GOT_IP (was WIFI_EVENT_STA_GOT_IP ) This event arises when the DHCP client successfully gets the IPV4 address from the DHCP server, or when the IPV4 address is changed. The event means that everything is ready and the application can begin its tasks (e.g., creating sockets). The IPV4 may be changed because of the following reasons: - The DHCP client fails to renew/rebind the IPV4 address, and the station\u2019s IPV4 is reset to 0. - The DHCP client rebinds to a different address. - The static-configured IPV4 address is changed. Whether the IPV4 address is changed or NOT is indicated by field ip_change of ip_event_got_ip_t. The socket is based on the IPV4 address, which means that, if the IPV4 changes, all sockets relating to this IPV4 will become abnormal. Upon receiving this event, the application needs to close all sockets and recreate the application when the IPV4 changes to a valid one. IP_STA_LOST_IP (was WIFI_EVENT_STA_LOST_IP ) This event arises when the IPV4 address become invalid. IP_STA_LOST_IP doesn\u2019t arise immediately after the Wi-Fi disconnects, instead it starts an IPV4 address lost timer, if the IPV4 address is got before ip lost timer expires, IP_EVENT_STA_LOST_IP doesn\u2019t happen. Otherwise, the event arises when IPV4 address lost timer expires. Generally the application don\u2019t need to care about this event, it is just a debug event to let the application know that the IPV4 address is lost. WIFI_EVENT_STA_START If esp_wifi_start() returns ESP_OK and the current Wi-Fi mode is station or station/AP, then this event will arise. Upon receiving this event, the event task will initialize the LwIP network interface (netif). Generally, the application event callback needs to call esp_wifi_connect() to connect to the configured AP. WIFI_EVENT_AP_START Similar to WIFI_EVENT_STA_START WIFI_EVENT_AP_STACONNECTED Every time a station is connected to ESP32 AP, the WIFI_EVENT_AP_STACONNECTED will arise. Upon receiving this event, the event task will do nothing, and the application callback can also ignore it. However, you may want to do something, for example, to get the info of the connected STA, etc. WIFI_EVENT_AP_STADISCONNECTED This event can happen in the following scenarios: - The application calls esp_wifi_disconnect() , or esp_wifi_deauth_sta() , to manually disconnect the station. - The Wi-Fi driver kicks off the station, e.g. because the AP has not received any packets in the past five minutes, etc. The time can be modified by esp_wifi_set_inactive_time() . - The station kicks off the AP. When this event happens, the event task will do nothing, but the application event callback needs to do something, e.g., close the socket which is related to this station, etc.","title":"WiFi events"},{"location":"Subjects/NP1/P2/#station-mode","text":"The figure describes some usual scenarios in station mode: The main phases in this mode are analyzed below (not all of them have to be present necessarily in all settings). 1. WiFi/LwIP Init Phase The following 1-5 steps are the recommended sequence to initialize a Wi-Fi-/LwIP-based application: The main task calls esp_netif_init() to create an LwIP core task and initialize LwIP-related work. The main task calls esp_event_loop_create() to create a system Event task and initialize an application event\u2019s callback function. In the scenario above, the application event\u2019s callback function does nothing but relaying the event to the application task. The main task calls esp_netif_create_default_wifi_ap() or esp_netif_create_default_wifi_sta() to create default network interface instance binding station or AP with TCP/IP stack. The main task calls esp_wifi_init() to create the Wi-Fi driver task and initialize the Wi-Fi driver. The main task calls OS API to create the application task. However, it is NOT a must-follow sequence, which means that you can create the application task in step 1 and put all other initializations in the application task. Moreover, you may not want to create the application task in the initialization phase if the application task depends on the sockets. Rather, you can defer the task creation until the IP is obtained. 2. WiFi Configuraci\u00f3n Phase Once the Wi-Fi driver is initialized, you can start configuring the Wi-Fi driver. In this scenario, the mode is station, so you may need to call esp_wifi_set_mode() ( WIFI_MODE_STA ) to configure the Wi-Fi mode as station. You can call other esp_wifi_set_xxx APIs to configure more settings, such as the protocol mode, country code, bandwidth, etc. Refer to ESP32 Wi-Fi Configuration for more information on the operation modes. Generally, we configure the Wi-Fi driver before setting up the Wi-Fi connection, but this is NOT mandatory, which means that you can configure the Wi-Fi connection anytime, provided that the Wi-Fi driver is initialized successfully. However, if the configuration does not need to change after the Wi-Fi connection is set up, you should configure the Wi-Fi driver at this stage, because the configuration APIs (such as esp_wifi_set_protocol() ) will cause the Wi-Fi to reconnect, which may not be desirable. The routine esp_wifi_set_config () allows you to configure the basic aspects of the WiFi connection. For example, the following code performs a basic WiFi setup by providing SSID, password, and authentication mode before configuring the connection: wifi_config_t wifi_config = { .sta = { .ssid = EXAMPLE_ESP_WIFI_SSID, .password = EXAMPLE_ESP_WIFI_PASS, .threshold.authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .capable = true, .required = false }, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) ); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) ); 3. WiFi Start Phase Call esp_wifi_start() to start the Wi-Fi driver. The Wi-Fi driver posts WIFI_EVENT_STA_START to the event task; then, the event task will do some common things and will call the application event callback function. The application event callback function relays the WIFI_EVENT_STA_START to the application task. We recommend that you call esp_wifi_connect() . However, you can also call esp_wifi_connect() in other phrases after the WIFI_EVENT_STA_START arises. 4. WiFi Connect Phase Once esp_wifi_connect() is called, the Wi-Fi driver will start the internal scan/connection process. If the internal scan/connection process is successful, the WIFI_EVENT_STA_CONNECTED will be generated. In the event task, it starts the DHCP client, which will finally trigger the DHCP process. In the above-mentioned scenario, the application event callback will relay the event to the application task. Generally, the application needs to do nothing, and you can do whatever you want, e.g., print a log, etc. In step 2, the Wi-Fi connection may fail because, for example, the password is wrong, the AP is not found, etc. In a case like this, WIFI_EVENT_STA_DISCONNECTED will arise and the reason for such a failure will be provided. For handling events that disrupt Wi-Fi connection, please refer to phase 6. 5. Wi-Fi Got IP Phase Once the DHCP client is initialized in step 4.2, the got IP phase will begin. If the IP address is successfully received from the DHCP server, then IP_EVENT_STA_GOT_IP will arise and the event task will perform common handling. In the application event callback, IP_EVENT_STA_GOT_IP is relayed to the application task. For LwIP-based applications, this event is very special and means that everything is ready for the application to begin its tasks, e.g. creating the TCP/UDP socket, etc. A very common mistake is to initialize the socket before IP_EVENT_STA_GOT_IP is received. DO NOT start the socket-related work before the IP is received. 6. WiFi Disconnect Phase When the Wi-Fi connection is disrupted, e.g. because the AP is powered off, the RSSI is poor, etc., WIFI_EVENT_STA_DISCONNECTED will arise. In the scenario described above, the application event callback function relays WIFI_EVENT_STA_DISCONNECTED to the application task. We recommend that esp_wifi_connect() be called to reconnect the Wi-Fi, close all sockets and re-create them if necessary. 7. WiFi IP Change Phase If the IP address is changed, the IP_EVENT_STA_GOT_IP will arise with ip_change field set to true in the ip_event_got_ip_t structure passed to the event handler. This event is important to the application. When it occurs, the timing is good for closing all created sockets and recreating them. 8. WiFi Deinit Phase Call esp_wifi_disconnect() to disconnect the Wi-Fi connectivity. Call esp_wifi_stop() to stop the Wi-Fi driver. Call esp_wifi_deinit() to unload the Wi-Fi driver.","title":"Station Mode"},{"location":"Subjects/NP1/P2/#analysis-of-an-example-wifigetting_startedstation","text":"Task 2.1 Analyze the station example, compile it and flash it. Study the treatment of events that it carries out, and how these are emitted for real cases. To do this, try the following things: - connect your ESP32 with an existing access point - connect your ESP32 with a non-existent access point - turn off the access point while the IP is granted Do it while you monitor the ESP32 to see the screen messages of the events handlers. If there is no message for one of them modify the code to handle it. Deliver the code and a brief report commenting your observations (pdf format).","title":"Analysis of an example (wifi/getting_started/station)"},{"location":"Subjects/NP1/P2/#access-point-mode","text":"The following figure roughly describes some of the main scenarios that can occur in AP (access point) mode: The workflow is very similar to that of station mode, with the difference basic type of WiFi configuration to perform ( WIFI_MODE_AP ) and obviously configuration parameters. Take a look at the following configuration example: wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .channel = EXAMPLE_ESP_WIFI_CHANNEL, .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); For more information on the configuration parameters of an Access Point, check AP Basic Configuration .","title":"Access Point Mode"},{"location":"Subjects/NP1/P2/#analysis-of-an-example-wifigetting_startedsoftap","text":"Task 2.2 Analyze the softAP example, compile it and flash it. Study the treatment of events that it carries out, and how these are emitted for real cases. To do it, connect different clients ( stations ), either ESP32 or any another device, and analyze the generated events and their response. If there is no message printed for any of them, add the corresponding handling code. Deliver the code and a small report documenting your observations (pdf format).","title":"Analysis of an example (wifi/getting_started/softAP)"},{"location":"Subjects/NP1/P2/#combined-sta-and-ap-mode","text":"ESP-IDF supports a mixed mode of connection, in which the ESP32 is both an access point (AP) and a station ( station ). This mode is configured using the ESP_MODE_APSTA parameter in the invocation of the routine esp_wifi_set_mode() . Obviously, the code will require two independent wifi_config_t structures, one with the data associated with the point access (field .ap ) mode and another with the fields associated with the station mode ( .sta field). In addition, it will be necessary to invoke the configuration routine ( esp_wifi_set_config ) with each of these structures. And finally, you also need to invoke the initialization of netif both in station mode ( esp_netif_create_default_wifi_sta() ) an in AP mode ( esp_netif_create_default_wifi_ap() ).","title":"Combined STA and AP Mode"},{"location":"Subjects/NP1/P2/#exercise-develop-a-stationap-mixed-node","text":"Task 2.3 Modify the station example so that the ESP32 behaves at the same time as a station and as an access point. Add the necessary configuration options to be able to set all the parameters via menuconfig . Check that the ESP32 actually connects to the point access and that at the same time it is possible to connect another device to it as a station (for example, your mobile phone). Deliver the developed code.","title":"Exercise: develop a station/AP mixed node"},{"location":"Subjects/NP1/P2/#scanning-wifi-networks","text":"","title":"Scanning WiFi networks"},{"location":"Subjects/NP1/P2/#wifi-scanning-modes","text":"The WiFi network scanning mode (i.e. invoking the routine esp_wifi_scan_start() ) is only supported currently in station or station/AP modes. The different types of network scanning modes are: Mode Description Active Scan Scan by sending a probe request. The default scan is an active scan. Passive Scan No probe request is sent out. Just switch to the specific channel and wait for a beacon. Application can enable it via the scan_type field of wifi_scan_config_t. Foreground Scan This scan is applicable when there is no Wi-Fi connection in station mode. Foreground or background scanning is controlled by the Wi-Fi driver and cannot be configured by the application. Background Scan This scan is applicable when there is a Wi-Fi connection in station mode or in station/AP mode. Whether it is a foreground scan or background scan depends on the Wi-Fi driver and cannot be configured by the application. All-Channel Scan It scans all of the channels. If the channel field of wifi_scan_config_t is set to 0, it is an all-channel scan. Specific Channel Scan It scans specific channels only. If the channel field of wifi_scan_config_t set to 1-14, it is a specific-channel scan. The scan modes in above table can be combined arbitrarily, so we totally have 8 different scans: All-Channel Background Active Scan All-Channel Background Passive Scan All-Channel Foreground Active Scan All-Channel Foreground Passive Scan Specific-Channel Background Active Scan Specific-Channel Background Passive Scan Specific-Channel Foreground Active Scan Specific-Channel Foreground Passive Scan","title":"WiFi Scanning Modes"},{"location":"Subjects/NP1/P2/#scan-configuration","text":"The scan type and other per-scan attributes are configured by esp_wifi_scan_start() . The table below provides a detailed description of wifi_scan_config_t . Field Description ssid If the SSID is not NULL it is only the AP with the same SSID that can be scanned. bssid If the BSSID is not NULL it is only the AP with the same BSSID that can be scanned. channel If channel is 0 there will be an all-channel scan; otherwise there will be a specific-channel scan. show_hidden If show_hidden is 0 the scan ignores the AP with a hidden SSID; otherwise the scan considers the hidden AP a normal one. scan_type If scan_type is WIFI_SCAN_TYPE_ACTIVE the scan is active ; otherwise it is a passive one. scan_time This field is used to control how long the scan dwells on each channel. See Scan Configuration for more details","title":"Scan Configuration"},{"location":"Subjects/NP1/P2/#scan-all-aps-on-all-channels-foreground","text":"The following figure describes a basic scan over all channels in foreground (remember that it can only occur in station mode when it is not yet connected to an AP). 1. Scan Configuration Phase Call esp_wifi_set_country() to set the country info if the default country info is not what you want, refer to Wi-Fi Country Code. Call esp_wifi_scan_start() to configure the scan. To do so, you can refer to Scan Configuration. Since this is an all-channel scan, just set the SSID/BSSID/channel to 0. 2. WiFi Driver's Internal Scan Phase The Wi-Fi driver switches to channel 1, in case the scan type is WIFI_SCAN_TYPE_ACTIVE , and broadcasts a probe request. Otherwise, the Wi-Fi will wait for a beacon from the APs. The Wi-Fi driver will stay in channel 1 for some time. The dwell time is configured in min/max time, with default value being 120 ms. The Wi-Fi driver switches to channel 2 and performs the same operation as in step 2.1. The Wi-Fi driver scans the last channel N, where N is determined by the country code which is configured in step 1.1. 3. Scan-Done Event Handling Phase When all channels are scanned, WIFI_EVENT_SCAN_DONE will arise. The application\u2019s event callback function notifies the application task that WIFI_EVENT_SCAN_DONE is received. esp_wifi_scan_get_ap_num() is called to get the number of APs that have been found in this scan. Then, it allocates enough entries and calls esp_wifi_scan_get_ap_records() to get the AP records. Please note that the AP records in the Wi-Fi driver will be freed, once esp_wifi_scan_get_ap_records() is called. Do not call esp_wifi_scan_get_ap_records() twice for a single scan-done event. If esp_wifi_scan_get_ap_records() is not called when the scan-done event occurs, the AP records allocated by the Wi-Fi driver will not be freed. So, make sure you call esp_wifi_scan_get_ap_records() , yet only once.","title":"Scan All APs on All Channels (Foreground)"},{"location":"Subjects/NP1/P2/#analysis-of-an-example-wifiscan","text":"Analyze the scan example, and try to observe the flow detailed above. Task 2.4 Compile, flash and run the scan sample. See if the results are what you expected in your home environment. Study and modify the waiting times in the scan and see the effect on the scan time. Deliver a brief report with your observations (pdf format).","title":"Analysis of an example (wifi/scan)"},{"location":"Subjects/NP1/P3/","text":"Lab 3. WiFi. Advanced Concepts (WiFi Mesh, provisioning and low power mode) Goals This lab assignment is divided into three main parts, that address three advanced topics related to WiFi. The goals for each of these parts are the following: WiFi MESH Review the basic concepts for building a self-managed WiFi Mesh network. Present the basic API for creating applications based on the ESP-MESH stack. Observe an ESP-MESH network in operation, as well as its capabilities autoconfiguration. Provisioning Understand and experiment with different modes of provisioning of WiFi credentials, via BLE and via softAP . Check the exchange of keys in clear making provisions from command line, as well as observe the utility (and the necessity) of sending encrypted credentials. Energy saving Understand the three power operating modes for the WiFi of the ESP32. Observe the influence of these operating modes in the latency of the connection. Part 1. WiFi Mesh (ESP MESH) The ESP-MESH stack is built on top of the WiFi driver (that is, it obviously makes use of the WiFi services), and in some cases also makes use of IP stack services ( lwIP ), as for example in the root node, which is the only node that has IP communication with an edge router . The following diagram shows the Mesh stack situation in ESP-IDF: Like any other ESP-IDF component, ESP-MESH communicates with applications through its own events: The type mesh_event_id_t defines all the possible events that may arise in the different phases of the life cycle of a network (for example, for a given node, connection or disconnection from its parent node, or from one of its child nodes). Event handlers for the ESP-MESH events are registered with the esp_event_handler_register() . Some typical events are for example, the connection of a parent node ( MESH_EVENT_PARENT_CONNECTED ) or of a child ( MESH_EVENT_CHILD_CONNECTED ), indicating, respectively, that a node can start emitting upward in the graph, or downward. Similarly, in a root node, the reception of the events IP_EVENT_STA_GOT_IP and IP_EVENT_STA_LOST_IP indicate that said root node may or may not send data to the external IP network. Events MESH_EVENT_STARTED : mesh is started MESH_EVENT_STOPPED : mesh is stopped MESH_EVENT_CHANNEL_SWITCH : channel switch MESH_EVENT_CHILD_CONNECTED : a child is connected on softAP interface MESH_EVENT_CHILD_DISCONNECTED : a child is disconnected on softAP interface MESH_EVENT_ROUTING_TABLE_ADD : routing table is changed by adding newly joined children MESH_EVENT_ROUTING_TABLE_REMOVE : routing table is changed by removing leave children MESH_EVENT_PARENT_CONNECTED : parent is connected on station interface MESH_EVENT_PARENT_DISCONNECTED : parent is disconnected on station interface MESH_EVENT_NO_PARENT_FOUND : no parent found MESH_EVENT_LAYER_CHANGE : layer changes over the mesh network MESH_EVENT_TODS_STATE : state represents whether the root is able to access external IP network MESH_EVENT_VOTE_STARTED : the process of voting a new root is started either by children or by the root MESH_EVENT_VOTE_STOPPED : the process of voting a new root is stopped MESH_EVENT_ROOT_ADDRESS : the root address is obtained. It is posted by mesh stack automatically. MESH_EVENT_ROOT_SWITCH_REQ : root switch request sent from a new voted root candidate MESH_EVENT_ROOT_SWITCH_ACK : root switch acknowledgment responds the above request sent from current root MESH_EVENT_ROOT_ASKED_YIELD : the root is asked yield by a more powerful existing root. If self organized is disabled and this device is specified to be a root by users, users should set a new parent for this device. if self organized is enabled, this device will find a new parent by itself, users could ignore this event. MESH_EVENT_ROOT_FIXED : when devices join a network, if the setting of Fixed Root for one device is different from that of its parent, the device will update the setting the same as its parent\u2019s. Fixed Root Setting of each device is variable as that setting changes of the root. MESH_EVENT_SCAN_DONE : if self-organized networking is disabled, user can call esp_wifi_scan_start() to trigger this event, and add the corresponding scan done handler in this event. MESH_EVENT_NETWORK_STATE : network state, such as whether current mesh network has a root. MESH_EVENT_STOP_RECONNECTION : the root stops reconnecting to the router and non-root devices stop reconnecting to their parents. MESH_EVENT_FIND_NETWORK : when the channel field in mesh configuration is set to zero, mesh stack will perform a full channel scan to find a mesh network that can join, and return the channel value after finding it. MESH_EVENT_ROUTER_SWITCH : if users specify BSSID of the router in mesh configuration, when the root connects to another router with the same SSID, this event will be posted and the new router information is attached. MESH_EVENT_PS_PARENT_DUTY : parent duty MESH_EVENT_PS_CHILD_DUTY : child duty MESH_EVENT_PS_DEVICE_DUTY : device duty LwIP and ESP-WIFI-MESH The application can access the ESP-WIFI-MESH stack directly without having to go through the LwIP stack. The LwIP stack is only required by the root node to transmit/receive data to/from an external IP network. However, since every node can potentially become the root node (due to automatic root node selection), each node must still initialize the LwIP stack. Each node is required to initialize LwIP by calling tcpip_adapter_init() . In order to prevent non-root node access to LwIP, the application should stop the following services after LwIP initialization: DHCP server service on the softAP interface. DHCP client service on the station interface. The following code snippet demonstrates how to initialize LwIP for ESP-WIFI-MESH applications. /* tcpip initialization */ tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); ESP-WIFI-MESH requires a root node to be connected with a router. Therefore, in the event that a node becomes the root, the corresponding handler must start the DHCP client service and immediately obtain an IP address. Doing so will allow other nodes to begin transmitting/receiving packets to/from the external IP network. However, this step is unnecessary if static IP settings are used. Writing an ESP-WIFI-MESH Application The prerequisites for starting ESP-WIFI-MESH is to initialize LwIP and Wi-Fi, The following code snippet demonstrates the necessary prerequisite steps before ESP-WIFI-MESH itself can be initialized. tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); /* event initialization */ ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Wi-Fi initialization */ wifi_init_config_t config = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&config)); /* register IP events handler */ ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH)); ESP_ERROR_CHECK(esp_wifi_start()); After initializing LwIP and Wi-Fi, the process of getting an ESP-WIFI-MESH network up and running can be summarized into the following three steps: Initialize Mesh Configuring an ESP-WIFI-MESH Network Start Mesh 1. Initialize Mesh The following code snippet demonstrates how to initialize ESP-WIFI-MESH: /* mesh initialization */ ESP_ERROR_CHECK(esp_mesh_init()); /* register mesh events handler */ ESP_ERROR_CHECK(esp_event_handler_register(MESH_EVENT, ESP_EVENT_ANY_ID, &mesh_event_handler, NULL)); 2. Configuring an ESP-WIFI-MESH Network ESP-WIFI-MESH is configured via esp_mesh_set_config() which receives its arguments using the mesh_cfg_t structure. The structure contains the following parameters used to configure ESP-WIFI-MESH: Parameter Description Channel Range from 1 to 14 Mesh ID ID of ESP-WIFI-MESH Network, see mesh_addr_t Router Router Configuration, see mesh_router_t Mesh AP Mesh AP Configuration, see mesh_ap_cfg_t Crypto Functions Crypto Functions for Mesh IE, see mesh_crypto_funcs_t The following code snippet shows an example of how to configure ESP-WIFI-MESH: /* Mesh ID */ static const uint8_t MESH_ID = { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 }; /* Enable the Mesh IE encryption by default */ mesh_cfg_t cfg = MESH_INIT_CONFIG_DEFAULT(); /* mesh ID */ memcpy((uint8_t *) &cfg.mesh_id, MESH_ID, 6); /* channel (must match the router's channel) */ cfg.channel = CONFIG_MESH_CHANNEL; /* router */ cfg.router.ssid_len = strlen(CONFIG_MESH_ROUTER_SSID); memcpy((uint8_t *) &cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len); memcpy((uint8_t *) &cfg.router.password, CONFIG_MESH_ROUTER_PASSWD, strlen(CONFIG_MESH_ROUTER_PASSWD)); /* mesh softAP */ cfg.mesh_ap.max_connection = CONFIG_MESH_AP_CONNECTIONS; memcpy((uint8_t *) &cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD, strlen(CONFIG_MESH_AP_PASSWD)); ESP_ERROR_CHECK(esp_mesh_set_config(&cfg)); 3. Start Mesh The following code snippet demonstrates how to start ESP-WIFI-MESH: /* mesh start */ ESP_ERROR_CHECK(esp_mesh_start()); After starting ESP-WIFI-MESH, the application should check for ESP-WIFI-MESH events to determine when it has connected to the network. After connecting, the application can start transmitting and receiving packets over the ESP-WIFI-MESH network using esp_mesh_send() and esp_mesh_recv() . Task 3.1 The most convenient way to observe the behavior of a WiFi network Mesh is to deploy an infrastructure with a sufficient number of nodes belonging to to the same network. Unfortunately, this requires having of said nodes in a close space and given the conditions of this curse that will not be possible. In this lab experience, each of you will deploy small WiFi Mesh network with only two nodes, using your ESP32 nodes as elements of the network. We start by copying the example examples/mesh/internal_communication to another directory from our home folder. Then we configure the project for: Connect to an access point generated with your own smartphone or your home wifi router ( Router SSID and Router password ). Configure the ESP-MESH network to use WPA2_PSK and select as password password . At this time, we will not make any changes to the code in the example. Compile your code. Flash the two ESP nodes you have and monitor the output of both nodes in two different terminals (use the command line toolset here for convenience). If you have the possibility, try to physically arrange the nodes in a way that one has better connection with your smartphone/router than the other (play with distance or obstacles). For each node annotate the following information: MAC addresses of the STA and SoftAP interfaces (you will see it in the first outgoing messages). Layer of the topology in which your node is located (you will observe it in [L: XX] format for sending and receiving data). If the root node has been chosen, also note this circumstance and the IP assigned by the router (see the response to the corresponding event). Also, take note of the ID of the Mesh network that was used. Before collecting this information make sure that the topology has converged. Draw a graph of your small wifi mesh network. Next, turn off the root node and wait for the network to converge again. Verify that the other node became the new root node. Now reconnect the node you disconnected previously, and see how it reconnects to the mesh. Is it again the root node? Annotate it and discuss why you think it is or is not the root node again. Part 2. WiFi Provisioning ESP-IDF provides a specific component that offers a WiFi provisioning service. This component provides APIs that control Wi-Fi provisioning service for receiving and configuring Wi-Fi credentials over SoftAP or BLE transport via secure Protocol Communication (protocomm) sessions. The set of wifi_prov_mgr_ APIs help in quickly implementing a provisioning service having necessary features with minimal amount of code and sufficient flexibility. To complete this part of the lab assignment you will have to work with the example examples/provisioning/wifi-prov-mgr . Initialization of the provisioning service The wifi_prov_mgr_init() function must be called to configure and initialize the provisioning manager before any other wifi_prov_mgr_ API functions. Note that the manager relies on other components of IDF, namely NVS, TCP/IP, Event Loop and Wi-Fi (and optionally mDNS), hence these must be initialized beforehand. The manager can be de-initialized at any moment by making a call to wifi_prov_mgr_deinit() . An initialization example could be: wifi_prov_mgr_config_t config = { .scheme = wifi_prov_scheme_ble, .scheme_event_handler = WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM }; ESP_ERR_CHECK( wifi_prov_mgr_init(config) ); The configuration structure wifi_prov_mgr_config_t has a few fields to specify the behavior desired of the manager. The scheme field is used to specify the provisioning scheme. Each scheme corresponds to one of the modes of transport supported by protocomm: wifi_prov_scheme_ble : BLE transport and GATT Server for handling provisioning commands wifi_prov_scheme_softap : Wi-Fi SoftAP transport and HTTP Server for handling provisioning commands wifi_prov_scheme_console : Serial transport and console for handling provisioning commands We refer you to WiFi Provisioning Initialization for additional information on the fields of the wifi_prov_mgr_config_t structure. Check Provisioning State Whether device is provisioned or not can be checked at runtime by calling wifi_prov_mgr_is_provisioned() . This internally checks if the Wi-Fi credentials are stored in NVS. Although there are different methods to delete the provisioning information stored in NVS, we will use the mechanism provided by idf.py to delete its content. To do this, we will execute: idf.py erase_flash Start Provisioning Service At the time of starting provisioning we need to specify a service name and the corresponding key. These translate to : Wi-Fi SoftAP SSID and passphrase, respectively, when scheme is wifi_prov_scheme_softap BLE Device name (service key is ignored) when scheme is wifi_prov_scheme_ble Also, since internally the manager uses protocomm , we have the option of choosing one of the security features provided by it : Security 1 is secure communication which consists of a prior handshake involving X25519 key exchange along with authentication using a proof of possession (pop), followed by AES-CTR for encryption/decryption of subsequent messages Security 0 is simply plain text communication. In this case the pop is simply ignored See Provisioning for details about the security features. The following code snippet shows an example of Provisioning Service initialization: const char *service_name = \"my_device\"; const char *service_key = \"password\"; wifi_prov_security_t security = WIFI_PROV_SECURITY_1; const char *pop = \"abcd1234\"; ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); The provisioning service will automatically finish only if it receives valid Wi-Fi AP credentials followed by successfully connection of device to the AP (IP obtained). Regardless of that, the provisioning service can be stopped at any moment by making a call to wifi_prov_mgr_stop_provisioning() . Waiting For Completion Typically, the main application will wait for the provisioning to finish, then de-initialize the manager to free up resources and finally start executing its own logic. There are two ways for making this possible: The simpler way is to use a blocking call to wifi_prov_mgr_wait() . // Start provisioning service ESP_ERROR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); // Wait for service to complete wifi_prov_mgr_wait(); // Finally de-initialize the manager wifi_prov_mgr_deinit(); // From here, the usual application logic would starts // ... The second mechanism is based on events (i.e., is asynchronous/non blocking). The default event loop handler to catch WIFI_PROV_EVENT and call wifi_prov_mgr_deinit() when event ID is WIFI_PROV_END : static void event_handler(void* arg, esp_event_base_t event_base, int event_id, void* event_data) { if (event_base == WIFI_PROV_EVENT && event_id == WIFI_PROV_END) { /* De-initialize manager once provisioning is finished */ wifi_prov_mgr_deinit(); } } Provisioning tools for mobile devices There are applications prepared by Espressif to carry out the process provisioning over ESP32. These applications are available both for Android and IOS devices, for BLE and/or SoftAP transports: Android: BLE Transport . SoftAP Transport . IOS: BLE Transport . SoftAP Transport . Task 3.2 Provision your ESP32 devices using the credentials that correspond to your WiFi network (home wifi or smartphone) using the applications corresponding to your mobile device, for both BLE and SoftAP transports. Write down a small report (pdf formta) describing the process, including the screenshots corresponding to the ESP32 output that show that the provisioning was successful. Remember, before each repetition of the experiment, use the command idf.py erase_flash to remove provisioning information from previous sessions. Check the operation of the different security levels. These applications work by means of a very simple communication with the unprovisioned ESP32, whose mechanisms depend on the transport being used. In the case of BLE, a GATT table is created with different characteristics used to write (send) data to the device. We will see what a GATT table is in next lab assignment. In the case of the softAP transport, a series of endpoints are created (HTTP URIs) that allow, in a simple way, to read and write the data that we want to communicate to the other end of the communication. The following table summarizes the endpoints created by the standard versions of the provisioning protocol (they can be adapted to include additional information to exchange): Endpoint (BLE + GATT Server) URI (SoftAP + HTTP) Session establishment prov-session http://IP:80/prov-session Network scanning available prov-scan http://IP:80/prov-scan Provisioning configuration prov-config http://IP:80/prov-config Protocol version proto-ver http://IP:80/proto-ver The details of this type of provisioning protocol remain as additional exercise to the student, and go beyond the goals of the assignment. However, it would be advisable to have a mechanism that allows them to be observed, and determine, for example in the case of SoftAP, if the exchange of credentials is done as plain text (plaintext) or encrypted, which could pose serious security problems for the user of a device mobile, since the credentials of connection to the WiFi network would be exposed. To analyze this security issue, we will use our laptop/pc as provisioning device. We ha to connect the laptop/pc to the provisioning SSID of the ESP32 node and use a command line tool provided with the ESP-IDF toolset, called esp_prov.py , which can be found in the directory tools/esp_prov . Note Before using the program, you must install the respective dependencies using the commands (from the tools/esp_prov directory): pip install -r requirements.txt pip install -r requirements_linux_extra.txt Its use is simple, and can be consulted by running python esp_prov.py -h . Basically a provisioning session using softAP on a device with IP 192.168.4.1 , without layer security (encryption) and providing the SSID and key SSID_EXAMPLE/KEY_EXAMPLE would result in: python esp_prov.py --transport softap --service_name \"192.168.4.1:80\" --sec_ver 0 --ssid SSID_EJEMPLO --passphrase CLAVE_EJEMPLO Task 3.3 Perform the provisioning process from the command line using the above indications. Use Wireshark to analyze the provisioning traffic and find evidences of the clear delivery of the network credentials between the provisioner and the device (text mode, without encryption) and the use of the endpoints/URIs previously mentioned. Create a small report (pdf format) describing the process and showing the evidences you found. Next, try with safe mode (option --sec_ver 1 ) and see how the keys exchanged are now encrypted. Add the corresponding comments to your report. Part 3. WiFi Power States Station mode Currently, ESP32 Wi-Fi supports the Modem-sleep mode which refers to the legacy power-saving mode in the IEEE 802.11 protocol. Modem-sleep mode works in station-only mode and the station must connect to the AP first. If the Modem-sleep mode is enabled, station will switch between active and sleep state periodically. In sleep state, RF, PHY and BB are turned off in order to reduce power consumption. Station can keep connection with AP in modem-sleep mode. Modem-sleep mode includes minimum and maximum power save modes. In minimum power save mode, station wakes up every DTIM to receive beacon. Broadcast data will not be lost because it is transmitted after DTIM. However, it can not save much more power if DTIM is short for DTIM is determined by AP. In maximum power save mode, station wakes up every listen interval to receive beacon. This listen interval can be set longer than the AP DTIM period. Broadcast data may be lost because station may be in sleep state at DTIM time. If listen interval is longer, more power is saved but broadcast data is more easy to lose. Listen interval can be configured by calling API esp_wifi_set_config() before connecting to AP. AP mode Currently ESP32 AP doesn\u2019t support all of the power save feature defined in Wi-Fi specification. To be specific, the AP only caches unicast data for the stations connect to this AP, but doesn\u2019t cache the multicast data for the stations. If stations connected to the ESP32 AP are power save enabled, they may experience multicast packet loss. In the future, all power save features will be supported on ESP32 AP. Example The example examples/wifi/power_save uses a simple code to illustrate the configuration of a station in the Modem-sleep mode, and you can select between the minimum and maximum submodes. These submodes can be configured through the configuration menu. In addition, an option is offered to modify the listening time in the case of the maximum submode. Task 3.4 Compile, flash, and run the sample code using all the three configurations available: no savings, minimum savings and maximum savings. In the case of maximum savings, vary the listening time so that it takes different values. In all cases, connect your ESP32 to an access point and, from a laptop connected to the same AP, execute a series of pings towards the station. Analyze the relation between the mode, DTIM, listen times and the ping response time, showing graphical represntations when possible. Deliver a small report in pdf format.","title":"Lab 3. WiFi. Advanced Concepts (WiFi Mesh, provisioning and low power mode)"},{"location":"Subjects/NP1/P3/#lab-3-wifi-advanced-concepts-wifi-mesh-provisioning-and-low-power-mode","text":"","title":"Lab 3. WiFi. Advanced Concepts (WiFi Mesh, provisioning and low power mode)"},{"location":"Subjects/NP1/P3/#goals","text":"This lab assignment is divided into three main parts, that address three advanced topics related to WiFi. The goals for each of these parts are the following: WiFi MESH Review the basic concepts for building a self-managed WiFi Mesh network. Present the basic API for creating applications based on the ESP-MESH stack. Observe an ESP-MESH network in operation, as well as its capabilities autoconfiguration. Provisioning Understand and experiment with different modes of provisioning of WiFi credentials, via BLE and via softAP . Check the exchange of keys in clear making provisions from command line, as well as observe the utility (and the necessity) of sending encrypted credentials. Energy saving Understand the three power operating modes for the WiFi of the ESP32. Observe the influence of these operating modes in the latency of the connection.","title":"Goals"},{"location":"Subjects/NP1/P3/#part-1-wifi-mesh-esp-mesh","text":"The ESP-MESH stack is built on top of the WiFi driver (that is, it obviously makes use of the WiFi services), and in some cases also makes use of IP stack services ( lwIP ), as for example in the root node, which is the only node that has IP communication with an edge router . The following diagram shows the Mesh stack situation in ESP-IDF: Like any other ESP-IDF component, ESP-MESH communicates with applications through its own events: The type mesh_event_id_t defines all the possible events that may arise in the different phases of the life cycle of a network (for example, for a given node, connection or disconnection from its parent node, or from one of its child nodes). Event handlers for the ESP-MESH events are registered with the esp_event_handler_register() . Some typical events are for example, the connection of a parent node ( MESH_EVENT_PARENT_CONNECTED ) or of a child ( MESH_EVENT_CHILD_CONNECTED ), indicating, respectively, that a node can start emitting upward in the graph, or downward. Similarly, in a root node, the reception of the events IP_EVENT_STA_GOT_IP and IP_EVENT_STA_LOST_IP indicate that said root node may or may not send data to the external IP network.","title":"Part 1. WiFi Mesh (ESP MESH)"},{"location":"Subjects/NP1/P3/#events","text":"MESH_EVENT_STARTED : mesh is started MESH_EVENT_STOPPED : mesh is stopped MESH_EVENT_CHANNEL_SWITCH : channel switch MESH_EVENT_CHILD_CONNECTED : a child is connected on softAP interface MESH_EVENT_CHILD_DISCONNECTED : a child is disconnected on softAP interface MESH_EVENT_ROUTING_TABLE_ADD : routing table is changed by adding newly joined children MESH_EVENT_ROUTING_TABLE_REMOVE : routing table is changed by removing leave children MESH_EVENT_PARENT_CONNECTED : parent is connected on station interface MESH_EVENT_PARENT_DISCONNECTED : parent is disconnected on station interface MESH_EVENT_NO_PARENT_FOUND : no parent found MESH_EVENT_LAYER_CHANGE : layer changes over the mesh network MESH_EVENT_TODS_STATE : state represents whether the root is able to access external IP network MESH_EVENT_VOTE_STARTED : the process of voting a new root is started either by children or by the root MESH_EVENT_VOTE_STOPPED : the process of voting a new root is stopped MESH_EVENT_ROOT_ADDRESS : the root address is obtained. It is posted by mesh stack automatically. MESH_EVENT_ROOT_SWITCH_REQ : root switch request sent from a new voted root candidate MESH_EVENT_ROOT_SWITCH_ACK : root switch acknowledgment responds the above request sent from current root MESH_EVENT_ROOT_ASKED_YIELD : the root is asked yield by a more powerful existing root. If self organized is disabled and this device is specified to be a root by users, users should set a new parent for this device. if self organized is enabled, this device will find a new parent by itself, users could ignore this event. MESH_EVENT_ROOT_FIXED : when devices join a network, if the setting of Fixed Root for one device is different from that of its parent, the device will update the setting the same as its parent\u2019s. Fixed Root Setting of each device is variable as that setting changes of the root. MESH_EVENT_SCAN_DONE : if self-organized networking is disabled, user can call esp_wifi_scan_start() to trigger this event, and add the corresponding scan done handler in this event. MESH_EVENT_NETWORK_STATE : network state, such as whether current mesh network has a root. MESH_EVENT_STOP_RECONNECTION : the root stops reconnecting to the router and non-root devices stop reconnecting to their parents. MESH_EVENT_FIND_NETWORK : when the channel field in mesh configuration is set to zero, mesh stack will perform a full channel scan to find a mesh network that can join, and return the channel value after finding it. MESH_EVENT_ROUTER_SWITCH : if users specify BSSID of the router in mesh configuration, when the root connects to another router with the same SSID, this event will be posted and the new router information is attached. MESH_EVENT_PS_PARENT_DUTY : parent duty MESH_EVENT_PS_CHILD_DUTY : child duty MESH_EVENT_PS_DEVICE_DUTY : device duty","title":"Events"},{"location":"Subjects/NP1/P3/#lwip-and-esp-wifi-mesh","text":"The application can access the ESP-WIFI-MESH stack directly without having to go through the LwIP stack. The LwIP stack is only required by the root node to transmit/receive data to/from an external IP network. However, since every node can potentially become the root node (due to automatic root node selection), each node must still initialize the LwIP stack. Each node is required to initialize LwIP by calling tcpip_adapter_init() . In order to prevent non-root node access to LwIP, the application should stop the following services after LwIP initialization: DHCP server service on the softAP interface. DHCP client service on the station interface. The following code snippet demonstrates how to initialize LwIP for ESP-WIFI-MESH applications. /* tcpip initialization */ tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); ESP-WIFI-MESH requires a root node to be connected with a router. Therefore, in the event that a node becomes the root, the corresponding handler must start the DHCP client service and immediately obtain an IP address. Doing so will allow other nodes to begin transmitting/receiving packets to/from the external IP network. However, this step is unnecessary if static IP settings are used.","title":"LwIP and ESP-WIFI-MESH"},{"location":"Subjects/NP1/P3/#writing-an-esp-wifi-mesh-application","text":"The prerequisites for starting ESP-WIFI-MESH is to initialize LwIP and Wi-Fi, The following code snippet demonstrates the necessary prerequisite steps before ESP-WIFI-MESH itself can be initialized. tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); /* event initialization */ ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Wi-Fi initialization */ wifi_init_config_t config = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&config)); /* register IP events handler */ ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH)); ESP_ERROR_CHECK(esp_wifi_start()); After initializing LwIP and Wi-Fi, the process of getting an ESP-WIFI-MESH network up and running can be summarized into the following three steps: Initialize Mesh Configuring an ESP-WIFI-MESH Network Start Mesh","title":"Writing an ESP-WIFI-MESH Application"},{"location":"Subjects/NP1/P3/#1-initialize-mesh","text":"The following code snippet demonstrates how to initialize ESP-WIFI-MESH: /* mesh initialization */ ESP_ERROR_CHECK(esp_mesh_init()); /* register mesh events handler */ ESP_ERROR_CHECK(esp_event_handler_register(MESH_EVENT, ESP_EVENT_ANY_ID, &mesh_event_handler, NULL));","title":"1. Initialize Mesh"},{"location":"Subjects/NP1/P3/#2-configuring-an-esp-wifi-mesh-network","text":"ESP-WIFI-MESH is configured via esp_mesh_set_config() which receives its arguments using the mesh_cfg_t structure. The structure contains the following parameters used to configure ESP-WIFI-MESH: Parameter Description Channel Range from 1 to 14 Mesh ID ID of ESP-WIFI-MESH Network, see mesh_addr_t Router Router Configuration, see mesh_router_t Mesh AP Mesh AP Configuration, see mesh_ap_cfg_t Crypto Functions Crypto Functions for Mesh IE, see mesh_crypto_funcs_t The following code snippet shows an example of how to configure ESP-WIFI-MESH: /* Mesh ID */ static const uint8_t MESH_ID = { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 }; /* Enable the Mesh IE encryption by default */ mesh_cfg_t cfg = MESH_INIT_CONFIG_DEFAULT(); /* mesh ID */ memcpy((uint8_t *) &cfg.mesh_id, MESH_ID, 6); /* channel (must match the router's channel) */ cfg.channel = CONFIG_MESH_CHANNEL; /* router */ cfg.router.ssid_len = strlen(CONFIG_MESH_ROUTER_SSID); memcpy((uint8_t *) &cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len); memcpy((uint8_t *) &cfg.router.password, CONFIG_MESH_ROUTER_PASSWD, strlen(CONFIG_MESH_ROUTER_PASSWD)); /* mesh softAP */ cfg.mesh_ap.max_connection = CONFIG_MESH_AP_CONNECTIONS; memcpy((uint8_t *) &cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD, strlen(CONFIG_MESH_AP_PASSWD)); ESP_ERROR_CHECK(esp_mesh_set_config(&cfg));","title":"2. Configuring an ESP-WIFI-MESH Network"},{"location":"Subjects/NP1/P3/#3-start-mesh","text":"The following code snippet demonstrates how to start ESP-WIFI-MESH: /* mesh start */ ESP_ERROR_CHECK(esp_mesh_start()); After starting ESP-WIFI-MESH, the application should check for ESP-WIFI-MESH events to determine when it has connected to the network. After connecting, the application can start transmitting and receiving packets over the ESP-WIFI-MESH network using esp_mesh_send() and esp_mesh_recv() . Task 3.1 The most convenient way to observe the behavior of a WiFi network Mesh is to deploy an infrastructure with a sufficient number of nodes belonging to to the same network. Unfortunately, this requires having of said nodes in a close space and given the conditions of this curse that will not be possible. In this lab experience, each of you will deploy small WiFi Mesh network with only two nodes, using your ESP32 nodes as elements of the network. We start by copying the example examples/mesh/internal_communication to another directory from our home folder. Then we configure the project for: Connect to an access point generated with your own smartphone or your home wifi router ( Router SSID and Router password ). Configure the ESP-MESH network to use WPA2_PSK and select as password password . At this time, we will not make any changes to the code in the example. Compile your code. Flash the two ESP nodes you have and monitor the output of both nodes in two different terminals (use the command line toolset here for convenience). If you have the possibility, try to physically arrange the nodes in a way that one has better connection with your smartphone/router than the other (play with distance or obstacles). For each node annotate the following information: MAC addresses of the STA and SoftAP interfaces (you will see it in the first outgoing messages). Layer of the topology in which your node is located (you will observe it in [L: XX] format for sending and receiving data). If the root node has been chosen, also note this circumstance and the IP assigned by the router (see the response to the corresponding event). Also, take note of the ID of the Mesh network that was used. Before collecting this information make sure that the topology has converged. Draw a graph of your small wifi mesh network. Next, turn off the root node and wait for the network to converge again. Verify that the other node became the new root node. Now reconnect the node you disconnected previously, and see how it reconnects to the mesh. Is it again the root node? Annotate it and discuss why you think it is or is not the root node again.","title":"3. Start Mesh"},{"location":"Subjects/NP1/P3/#part-2-wifi-provisioning","text":"ESP-IDF provides a specific component that offers a WiFi provisioning service. This component provides APIs that control Wi-Fi provisioning service for receiving and configuring Wi-Fi credentials over SoftAP or BLE transport via secure Protocol Communication (protocomm) sessions. The set of wifi_prov_mgr_ APIs help in quickly implementing a provisioning service having necessary features with minimal amount of code and sufficient flexibility. To complete this part of the lab assignment you will have to work with the example examples/provisioning/wifi-prov-mgr .","title":"Part 2. WiFi Provisioning"},{"location":"Subjects/NP1/P3/#initialization-of-the-provisioning-service","text":"The wifi_prov_mgr_init() function must be called to configure and initialize the provisioning manager before any other wifi_prov_mgr_ API functions. Note that the manager relies on other components of IDF, namely NVS, TCP/IP, Event Loop and Wi-Fi (and optionally mDNS), hence these must be initialized beforehand. The manager can be de-initialized at any moment by making a call to wifi_prov_mgr_deinit() . An initialization example could be: wifi_prov_mgr_config_t config = { .scheme = wifi_prov_scheme_ble, .scheme_event_handler = WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM }; ESP_ERR_CHECK( wifi_prov_mgr_init(config) ); The configuration structure wifi_prov_mgr_config_t has a few fields to specify the behavior desired of the manager. The scheme field is used to specify the provisioning scheme. Each scheme corresponds to one of the modes of transport supported by protocomm: wifi_prov_scheme_ble : BLE transport and GATT Server for handling provisioning commands wifi_prov_scheme_softap : Wi-Fi SoftAP transport and HTTP Server for handling provisioning commands wifi_prov_scheme_console : Serial transport and console for handling provisioning commands We refer you to WiFi Provisioning Initialization for additional information on the fields of the wifi_prov_mgr_config_t structure.","title":"Initialization of the provisioning service"},{"location":"Subjects/NP1/P3/#check-provisioning-state","text":"Whether device is provisioned or not can be checked at runtime by calling wifi_prov_mgr_is_provisioned() . This internally checks if the Wi-Fi credentials are stored in NVS. Although there are different methods to delete the provisioning information stored in NVS, we will use the mechanism provided by idf.py to delete its content. To do this, we will execute: idf.py erase_flash","title":"Check Provisioning State"},{"location":"Subjects/NP1/P3/#start-provisioning-service","text":"At the time of starting provisioning we need to specify a service name and the corresponding key. These translate to : Wi-Fi SoftAP SSID and passphrase, respectively, when scheme is wifi_prov_scheme_softap BLE Device name (service key is ignored) when scheme is wifi_prov_scheme_ble Also, since internally the manager uses protocomm , we have the option of choosing one of the security features provided by it : Security 1 is secure communication which consists of a prior handshake involving X25519 key exchange along with authentication using a proof of possession (pop), followed by AES-CTR for encryption/decryption of subsequent messages Security 0 is simply plain text communication. In this case the pop is simply ignored See Provisioning for details about the security features. The following code snippet shows an example of Provisioning Service initialization: const char *service_name = \"my_device\"; const char *service_key = \"password\"; wifi_prov_security_t security = WIFI_PROV_SECURITY_1; const char *pop = \"abcd1234\"; ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); The provisioning service will automatically finish only if it receives valid Wi-Fi AP credentials followed by successfully connection of device to the AP (IP obtained). Regardless of that, the provisioning service can be stopped at any moment by making a call to wifi_prov_mgr_stop_provisioning() .","title":"Start Provisioning Service"},{"location":"Subjects/NP1/P3/#waiting-for-completion","text":"Typically, the main application will wait for the provisioning to finish, then de-initialize the manager to free up resources and finally start executing its own logic. There are two ways for making this possible: The simpler way is to use a blocking call to wifi_prov_mgr_wait() . // Start provisioning service ESP_ERROR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); // Wait for service to complete wifi_prov_mgr_wait(); // Finally de-initialize the manager wifi_prov_mgr_deinit(); // From here, the usual application logic would starts // ... The second mechanism is based on events (i.e., is asynchronous/non blocking). The default event loop handler to catch WIFI_PROV_EVENT and call wifi_prov_mgr_deinit() when event ID is WIFI_PROV_END : static void event_handler(void* arg, esp_event_base_t event_base, int event_id, void* event_data) { if (event_base == WIFI_PROV_EVENT && event_id == WIFI_PROV_END) { /* De-initialize manager once provisioning is finished */ wifi_prov_mgr_deinit(); } }","title":"Waiting For Completion"},{"location":"Subjects/NP1/P3/#provisioning-tools-for-mobile-devices","text":"There are applications prepared by Espressif to carry out the process provisioning over ESP32. These applications are available both for Android and IOS devices, for BLE and/or SoftAP transports: Android: BLE Transport . SoftAP Transport . IOS: BLE Transport . SoftAP Transport . Task 3.2 Provision your ESP32 devices using the credentials that correspond to your WiFi network (home wifi or smartphone) using the applications corresponding to your mobile device, for both BLE and SoftAP transports. Write down a small report (pdf formta) describing the process, including the screenshots corresponding to the ESP32 output that show that the provisioning was successful. Remember, before each repetition of the experiment, use the command idf.py erase_flash to remove provisioning information from previous sessions. Check the operation of the different security levels. These applications work by means of a very simple communication with the unprovisioned ESP32, whose mechanisms depend on the transport being used. In the case of BLE, a GATT table is created with different characteristics used to write (send) data to the device. We will see what a GATT table is in next lab assignment. In the case of the softAP transport, a series of endpoints are created (HTTP URIs) that allow, in a simple way, to read and write the data that we want to communicate to the other end of the communication. The following table summarizes the endpoints created by the standard versions of the provisioning protocol (they can be adapted to include additional information to exchange): Endpoint (BLE + GATT Server) URI (SoftAP + HTTP) Session establishment prov-session http://IP:80/prov-session Network scanning available prov-scan http://IP:80/prov-scan Provisioning configuration prov-config http://IP:80/prov-config Protocol version proto-ver http://IP:80/proto-ver The details of this type of provisioning protocol remain as additional exercise to the student, and go beyond the goals of the assignment. However, it would be advisable to have a mechanism that allows them to be observed, and determine, for example in the case of SoftAP, if the exchange of credentials is done as plain text (plaintext) or encrypted, which could pose serious security problems for the user of a device mobile, since the credentials of connection to the WiFi network would be exposed. To analyze this security issue, we will use our laptop/pc as provisioning device. We ha to connect the laptop/pc to the provisioning SSID of the ESP32 node and use a command line tool provided with the ESP-IDF toolset, called esp_prov.py , which can be found in the directory tools/esp_prov . Note Before using the program, you must install the respective dependencies using the commands (from the tools/esp_prov directory): pip install -r requirements.txt pip install -r requirements_linux_extra.txt Its use is simple, and can be consulted by running python esp_prov.py -h . Basically a provisioning session using softAP on a device with IP 192.168.4.1 , without layer security (encryption) and providing the SSID and key SSID_EXAMPLE/KEY_EXAMPLE would result in: python esp_prov.py --transport softap --service_name \"192.168.4.1:80\" --sec_ver 0 --ssid SSID_EJEMPLO --passphrase CLAVE_EJEMPLO Task 3.3 Perform the provisioning process from the command line using the above indications. Use Wireshark to analyze the provisioning traffic and find evidences of the clear delivery of the network credentials between the provisioner and the device (text mode, without encryption) and the use of the endpoints/URIs previously mentioned. Create a small report (pdf format) describing the process and showing the evidences you found. Next, try with safe mode (option --sec_ver 1 ) and see how the keys exchanged are now encrypted. Add the corresponding comments to your report.","title":"Provisioning tools for mobile devices"},{"location":"Subjects/NP1/P3/#part-3-wifi-power-states","text":"","title":"Part 3. WiFi Power States"},{"location":"Subjects/NP1/P3/#station-mode","text":"Currently, ESP32 Wi-Fi supports the Modem-sleep mode which refers to the legacy power-saving mode in the IEEE 802.11 protocol. Modem-sleep mode works in station-only mode and the station must connect to the AP first. If the Modem-sleep mode is enabled, station will switch between active and sleep state periodically. In sleep state, RF, PHY and BB are turned off in order to reduce power consumption. Station can keep connection with AP in modem-sleep mode. Modem-sleep mode includes minimum and maximum power save modes. In minimum power save mode, station wakes up every DTIM to receive beacon. Broadcast data will not be lost because it is transmitted after DTIM. However, it can not save much more power if DTIM is short for DTIM is determined by AP. In maximum power save mode, station wakes up every listen interval to receive beacon. This listen interval can be set longer than the AP DTIM period. Broadcast data may be lost because station may be in sleep state at DTIM time. If listen interval is longer, more power is saved but broadcast data is more easy to lose. Listen interval can be configured by calling API esp_wifi_set_config() before connecting to AP.","title":"Station mode"},{"location":"Subjects/NP1/P3/#ap-mode","text":"Currently ESP32 AP doesn\u2019t support all of the power save feature defined in Wi-Fi specification. To be specific, the AP only caches unicast data for the stations connect to this AP, but doesn\u2019t cache the multicast data for the stations. If stations connected to the ESP32 AP are power save enabled, they may experience multicast packet loss. In the future, all power save features will be supported on ESP32 AP.","title":"AP mode"},{"location":"Subjects/NP1/P3/#example","text":"The example examples/wifi/power_save uses a simple code to illustrate the configuration of a station in the Modem-sleep mode, and you can select between the minimum and maximum submodes. These submodes can be configured through the configuration menu. In addition, an option is offered to modify the listening time in the case of the maximum submode. Task 3.4 Compile, flash, and run the sample code using all the three configurations available: no savings, minimum savings and maximum savings. In the case of maximum savings, vary the listening time so that it takes different values. In all cases, connect your ESP32 to an access point and, from a laptop connected to the same AP, execute a series of pings towards the station. Analyze the relation between the mode, DTIM, listen times and the ping response time, showing graphical represntations when possible. Deliver a small report in pdf format.","title":"Example"},{"location":"Subjects/NP1/P4/","text":"Lab 4. Bluetooth Low Energy (BLE) Goals Dissect in detail a GATT table construction firmware (GATT server) using the ESP-IDF API. Learn to use gatttool to interact with the GATT server. Modify the GATT server to accept notification requests from the client, and to publish updated values for a certain characteristic on demand. GATT Sever Implementation Introduction In this lab assignmet, we will deploy a GATT server using the ESP-IDF API. This API exposes the functionalities of Bluedroid, the Bluetooth stack (including BLE) that provides ESP-IDF for the development of Bluetooth applications. We will use the example from examples/bluetooth/bluedroid/ble/gatt_server_service_table , which example implements a Bluetooth Low Energy (BLE) Generic Attribute (GATT) Server using a table-like data structure to define the server services and characteristics such as the one shown in the figure below Therefore, it demonstrates a practical way to define the server functionality in one place instead of adding services and characteristics one by one. This example implements the Heart Rate Profile as defined by the Traditional Profile Specifications . We will therefore display three characteristics. Of them, the most important for us will be the heart rate measurement value, with its value ( Heart Rate Measurement Value ) and its notification settings ( Heart Rate Measurement Notification Configuration ). Due to the complexity of the code (at least in its initial part), this document follows the program workflow and breaks down the code in order to make sense of every section and reasoning behind the implementation. Includes Let\u2019s start by taking a look at the included headers: #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"freertos/event_groups.h\" #include \"esp_system.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"esp_bt.h\" #include \"esp_gap_ble_api.h\" #include \"esp_gatts_api.h\" #include \"esp_bt_main.h\" #include \"gatts_table_creat_demo.h\" #include \"esp_gatt_common_api.h\" These includes are required for the FreeRTOS and underlaying system components to run, including logging functionality and a library to store data in non-volatile flash memory. We are interested in bt.h , esp_bt_main.h , esp_gap_ble_api.h and esp_gatts_api.h which expose the BLE APIs required to implement this example. esp_bt.h : implements BT controller and VHCI configuration procedures from the host side. esp_bt_main.h : implements initialization and enabling of the Bluedroid stack. esp_gap_ble_api.h : implements GAP configuration such as advertising and connection parameters. esp_gatts_api.h : implements GATT Server configuration such as creating services and characteristics. Service Table The header file gatts_table_creat_demo.h is where an enumeration of the services and characteristics is created: enum { IDX_SVC, IDX_CHAR_A, IDX_CHAR_VAL_A, IDX_CHAR_CFG_A, IDX_CHAR_B, IDX_CHAR_VAL_B, IDX_CHAR_C, IDX_CHAR_VAL_C, HRS_IDX_NB, }; The enumeration elements are set up in the same order as the Heart Rate Profile attributes, starting with the service followed by the characteristics of that service. In addition, the Heart Rate Measurement characteristic has a Client Characteristic Configuration (CCC) descriptor which is an additional attribute that describes if the characteristic has notifications enabled. The enumeration index can be used to identify each element later when creating the actual attributes table. In summary, the elements are described as follows: IDX_SVC : Heart Rate Service index IDX_CHAR_A : Heart Rate Measurement characteristic index IDX_CHAR_VAL_A : Heart Rate Measurement characteristic value index IDX_CHAR_CFG_A : Heart Rate Measurement notifications configuration (CCC) index IDX_CHAR_B : Heart Rate Body Sensor Location characteristic index IDX_CHAR_VAL_B : Heart Rate Body Sensor Location characteristic value index IDX_CHAR_C : Heart Rate Control Point characteristic index IDX_CHAR_VAL_C : Heart Rate Control Point characteristic value index IDX_NB : Number of table elements. Main Entry Point The entry point to this example is the app_main() function: void app_main(void) { esp_err_t ret; /* Initialize NVS. */ ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK( ret ); ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT)); esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bluedroid_init(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s init bluetooth failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bluedroid_enable(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable bluetooth failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_ble_gatts_register_callback(gatts_event_handler); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gatts register error, error code = %x\", ret); return; } ret = esp_ble_gap_register_callback(gap_event_handler); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gap register error, error code = %x\", ret); return; } ret = esp_ble_gatts_app_register(ESP_APP_ID); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gatts app register error, error code = %x\", ret); return; } esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500); if (local_mtu_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"set local MTU failed, error code = %x\", local_mtu_ret); } } The main function starts by initializing the non-volatile storage library in order to be able to save parameters in flash memory. ret = nvs_flash_init(); BT Controller and Stack Initialization The main function also initializes the BT controller by first creating a BT controller configuration structure named esp_bt_controller_config_t with default settings generated by the BT_CONTROLLER_INIT_CONFIG_DEFAULT() macro. The BT controller implements the Host Controller Interface (HCI) on the controller side, the Link Layer (LL) and the Physical Layer (PHY). The BT Controller is invisible to the user applications and deals with the lower layers of the BLE stack. The controller configuration includes setting the BT controller stack size, priority and HCI baud rate. With the settings created, the BT controller is initialized and enabled with the esp_bt_controller_init() function: esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); Next, the controller is enabled in BLE Mode. ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); There are four Bluetooth modes supported: ESP_BT_MODE_IDLE : Bluetooth not running ESP_BT_MODE_BLE : BLE mode ESP_BT_MODE_CLASSIC_BT : BT Classic mode ESP_BT_MODE_BTDM : Dual mode (BLE + BT Classic) After the initialization of the BT controller, the Bluedroid stack, which includes the common definitions and APIs for both BT Classic and BLE, is initialized and enabled by using: ret = esp_bluedroid_init(); ret = esp_bluedroid_enable(); The Bluetooth stack is up and running at this point in the program flow, however the functionality of the application has not been defined yet. The functionality is defined by reacting to events such as what happens when another device tries to read or write parameters and establish a connection. The two main managers of events are the GAP and GATT event handlers. The application needs to register a callback function for each event handler in order to let the application know which functions are going to handle the GAP and GATT events: esp_ble_gatts_register_callback(gatts_event_handler); esp_ble_gap_register_callback(gap_event_handler); The functions gatts_event_handler() and gap_event_handler() handle all the events that are pushed to the application from the BLE stack. Application Profiles This example implements one Application Profile for the Heart Rate Service. An Application Profile is a way to group functionality which is designed to be used by one client application, for example one smartphone mobile app. In this way, different types of profiles can be accommodated in one server. The Application Profile ID, which is an user-assigned number to identify each profile, is used to register the profile in the stack, in this example the ID is 0x55. #define PROFILE_NUM 1 #define PROFILE_APP_IDX 0 #define ESP_APP_ID 0x55 The profiles are stored in the heart_rate_profile_tab array. Since there is only one profile in this example, one element is stored in the array with index zero as defined by the PROFILE_APP_IDX . Additionally, the profile event handler callback function is initialized. Each application on the GATT server uses a different interface, represented by the gatts_if parameter. For initialization, this parameter is set to ESP_GATT_IF_NONE , later when the application is registered, the gatts_if parameter is updated with the corresponding interface generated by the stack. /* One gatt-based profile one app_id and one gatts_if, this array will store the gatts_if returned by ESP_GATTS_REG_EVT */ static struct gatts_profile_inst heart_rate_profile_tab[PROFILE_NUM] = { [PROFILE_APP_IDX] = { .gatts_cb = gatts_profile_event_handler, .gatts_if = ESP_GATT_IF_NONE, /* Not get the gatt_if, so initial is ESP_GATT_IF_NONE */ }, }; The application registration takes place inside app_main() using the esp_ble_gatts_app_register() function: esp_ble_gatts_app_register(ESP_HEART_RATE_APP_ID); Setting GAP Parameters The register application event is the first one that is triggered during the lifetime of the program. This example uses this event to configure advertising parameters upon registration in the profile event handler. The functions used to achieve this are: esp_ble_gap_set_device_name() : used to set the advertised device name. esp_ble_gap_config_adv_data() : used to configure standard advertising data. The function used to configure standard Bluetooth Specification advertisement parameters is esp_ble_gap_config_adv_data() which takes a pointer to an esp_ble_adv_data_t structure. The esp_ble_adv_data_t data structure for advertising data has the following definition: typedef struct { bool set_scan_rsp; /*!< Set this advertising data as scan response or not*/ bool include_name; /*!< Advertising data include device name or not */ bool include_txpower; /*!< Advertising data include TX power */ int min_interval; /*!< Advertising data show slave preferred connection min interval */ int max_interval; /*!< Advertising data show slave preferred connection max interval */ int appearance; /*!< External appearance of device */ uint16_t manufacturer_len; /*!< Manufacturer data length */ uint8_t *p_manufacturer_data; /*!< Manufacturer data point */ uint16_t service_data_len; /*!< Service data length */ uint8_t *p_service_data; /*!< Service data point */ uint16_t service_uuid_len; /*!< Service uuid length */ uint8_t *p_service_uuid; /*!< Service uuid array point */ uint8_t flag; /*!< Advertising flag of discovery mode, see BLE_ADV_DATA_FLAG detail */ } esp_ble_adv_data_t; In this example, the structure is initialized as follows: static esp_ble_adv_data_t heart_rate_adv_config = { .set_scan_rsp = false, .include_name = true, .include_txpower = true, .min_interval = 0x0006, .max_interval = 0x0010, .appearance = 0x00, .manufacturer_len = 0, //TEST_MANUFACTURER_DATA_LEN, .p_manufacturer_data = NULL, //&test_manufacturer[0], .service_data_len = 0, .p_service_data = NULL, .service_uuid_len = sizeof(heart_rate_service_uuid), .p_service_uuid = heart_rate_service_uuid, .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT), }; The minimum and maximum slave preferred connection intervals are set in units of 1.25 ms. In this example, the minimum slave preferred connection interval is defined as 0x0006 * 1.25 ms = 7.5 ms and the maximum slave preferred connection interval is initialized as 0x0010 * 1.25 ms = 20 ms. An advertising payload can be up to 31 bytes of data. It is possible that some of the parameters surpass the 31-byte advertisement packet limit which causes the stack to cut the message and leave some of the parameters out. To solve this, usually the longer parameters are stored in the scan response, which can be configured using the same esp_ble_gap_config_adv_data() function and an additional esp_ble_adv_data_t type structure with the .set_scan_rsp parameter is set to true. Finally, to set the device name the esp_ble_gap_set_device_name() function is used. The registering event handler is shown as follows: static void gatts_profile_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { ESP_LOGE(GATTS_TABLE_TAG, \"event = %x\\n\",event); switch (event) { case ESP_GATTS_REG_EVT: ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME); ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); esp_ble_gap_config_adv_data(&heart_rate_adv_config); ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); ... GAP Event Handler Once the advertising data have been set, the ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT is triggered and managed by the GAP event handler. Moreover, an ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT is triggered as well if the scan response is also set. Once the configuration of the advertising and scan response data has been set, the handler can use any of these events to start advertising, which is done using the esp_ble_gap_start_advertising() function: static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param) { ESP_LOGE(GATTS_TABLE_TAG, \"GAP_EVT, event %d\\n\", event); switch (event) { case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT: esp_ble_gap_start_advertising(&heart_rate_adv_params); break; case ESP_GAP_BLE_ADV_START_COMPLETE_EVT: //advertising start complete event to indicate advertising start successfully or failed if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTS_TABLE_TAG, \"Advertising start failed\\n\"); } break; default: break; } } The function to start advertising takes a structure of type esp_ble_adv_params_t with the advertising parameters required. /// Advertising parameters typedef struct { uint16_t adv_int_min; /*!< Minimum advertising interval for undirected and low duty cycle directed advertising. Range: 0x0020 to 0x4000 Default: N = 0x0800 (1.28 second) Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec */ uint16_t adv_int_max; /*!< Maximum advertising interval for undirected and low duty cycle directed advertising. Range: 0x0020 to 0x4000 Default: N = 0x0800 (1.28 second) Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec */ esp_ble_adv_type_t adv_type; /*!< Advertising type */ esp_ble_addr_type_t own_addr_type; /*!< Owner bluetooth device address type */ esp_bd_addr_t peer_addr; /*!< Peer device bluetooth device address */ esp_ble_addr_type_t peer_addr_type; /*!< Peer device bluetooth device address type */ esp_ble_adv_channel_t channel_map; /*!< Advertising channel map */ esp_ble_adv_filter_t adv_filter_policy; /*!< Advertising filter policy */ } esp_ble_adv_params_t; Note that esp_ble_gap_config_adv_data() configures the data that is advertised to the client and takes an esp_ble_adv_data_t structure , while esp_ble_gap_start_advertising() makes the server to actually start advertising and takes an esp_ble_adv_params_t structure. The advertising data is the information that is shown to the client, while the advertising parameters are the configuration required by the BLE stack to execute. For this example, the advertisement parameters are initialized as follows: static esp_ble_adv_params_t heart_rate_adv_params = { .adv_int_min = 0x20, .adv_int_max = 0x40, .adv_type = ADV_TYPE_IND, .own_addr_type = BLE_ADDR_TYPE_PUBLIC, //.peer_addr = //.peer_addr_type = .channel_map = ADV_CHNL_ALL, .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY, }; These parameters configure the advertising interval between 20 ms to 40 ms. The advertisement is of type ADV_IND, which is generic, not directed to a particular central device and advertises the server as connectable. The address type is public, uses all channels and allows both scan and connection requests from any central. If the advertising started successfully, an ESP_GAP_BLE_ADV_START_COMPLETE_EVT event is generated which in this example is used to check if the advertising status is indeed advertising or otherwise print an error message. ... case ESP_GAP_BLE_ADV_START_COMPLETE_EVT: //advertising start complete event to indicate advertising start successfully or failed if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTS_TABLE_TAG, \"Advertising start failed\\n\"); } break; ... GATT Event Handlers When an Application Profile is registered, an ESP_GATTS_REG_EVT event is triggered. The parameters of the ESP_GATTS_REG_EVT are: esp_gatt_status_t status; /*!< Operation status */ uint16_t app_id; /*!< Application id which input in register API */ In addition to the previous parameters, the event also contains the GATT interface assigned by the BLE stack. The event is captured by the gatts_event_handler() which stores the generated interface in the profile table and then forwards it to the corresponding profile event handler. static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { ESP_LOGI(GATTS_TABLE_TAG, \"EVT %d, gatts if %d\\n\", event, gatts_if); /* If event is register event, store the gatts_if for each profile */ if (event == ESP_GATTS_REG_EVT) { if (param->reg.status == ESP_GATT_OK) { heart_rate_profile_tab[HEART_PROFILE_APP_IDX].gatts_if = gatts_if; } else { ESP_LOGI(GATTS_TABLE_TAG, \"Reg app failed, app_id %04x, status %d\\n\", param->reg.app_id, param->reg.status); return; } } do { int idx; for (idx = 0; idx < HEART_PROFILE_NUM; idx++) { if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */ gatts_if == heart_rate_profile_tab[idx].gatts_if) { if (heart_rate_profile_tab[idx].gatts_cb) { heart_rate_profile_tab[idx].gatts_cb(event, gatts_if, param); } } } } while (0); } Creating Services and Characteristics with the Attribute Table The register event is used to create a table of profile attributes by employing the esp_ble_gatts_create_attr_tab() function. This function takes an argument of type esp_gatts_attr_db_t which corresponds to a look up table keyed by the enumeration values defined in the header file. The esp_gatts_attr_db_t structure has two members: esp_attr_control_t attr_control; /*!< The attribute control type*/ esp_attr_desc_t att_desc; /*!< The attribute type*/ The attr_control is the auto-respond parameter which can be set as ESP_GATT_AUTO_RSP to allow the BLE stack to take care of responding messages when read or write events arrive. The other option is ESP_GATT_RSP_BY_APP which allows to manually respond to messages using the esp_ble_gatts_send_response() function. The att_desc is the attribute description which is made of: uint16_t uuid_length; /*!< UUID length */ uint8_t *uuid_p; /*!< UUID value */ uint16_t perm; /*!< Attribute permission */ uint16_t max_length; /*!< Maximum length of the element*/ uint16_t length; /*!< Current length of the element*/ uint8_t *value; /*!< Element value array*/ For example, the first element of the table in this example is the service attribute: [HRS_IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&heart_rate_svc}}, The initialization values are: [HRS_IDX_SVC] : Named or designated initializer in the enum table. ESP_GATT_AUTO_RSP : Auto respond configuration, set to respond automatically by the stack. ESP_UUID_LEN_16 : UUID length set to 16 bits. (uint8_t *)&primary_service_uuid : UUID to identify the service as a primary one (0x2800). ESP_GATT_PERM_READ : Read Permission for the service. sizeof(uint16_t) : Maximum length of the service UUID (16 bits). sizeof(heart_rate_svc) : Current service length set to the size of the variable heart_rate_svc , which is 16 bits. (uint8_t *)&heart_rate_svc : Service attribute value set to the variable heart_rate_svc which contains the Heart Rate Service UUID (0x180D). The rest of the attributes is initialized in the same way. Some attributes also have the NOTIFY property which is set by &char_prop_notify . The complete table structure is initialized as follows: /// Full HRS Database Description - Used to add attributes into the database static const esp_gatts_attr_db_t heart_rate_gatt_db[HRS_IDX_NB] = { // Heart Rate Service Declaration [HRS_IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&heart_rate_svc}}, // Heart Rate Measurement Characteristic Declaration [HRS_IDX_HR_MEAS_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_notify}}, // Heart Rate Measurement Characteristic Value [HRS_IDX_HR_MEAS_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&heart_rate_meas_uuid, ESP_GATT_PERM_READ, HRPS_HT_MEAS_MAX_LEN,0, NULL}}, // Heart Rate Measurement Characteristic - Client Characteristic Configuration Descriptor [HRS_IDX_HR_MEAS_NTF_CFG] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE, sizeof(uint16_t),sizeof(heart_measurement_ccc), (uint8_t *)heart_measurement_ccc}}, // Body Sensor Location Characteristic Declaration [HRS_IDX_BOBY_SENSOR_LOC_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read}}, // Body Sensor Location Characteristic Value [HRS_IDX_BOBY_SENSOR_LOC_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&body_sensor_location_uuid, ESP_GATT_PERM_READ, sizeof(uint8_t), sizeof(body_sensor_loc_val), (uint8_t *)body_sensor_loc_val}}, // Heart Rate Control Point Characteristic Declaration [HRS_IDX_HR_CTNL_PT_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write}}, // Heart Rate Control Point Characteristic Value [HRS_IDX_HR_CTNL_PT_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&heart_rate_ctrl_point, ESP_GATT_PERM_WRITE|ESP_GATT_PERM_READ, sizeof(uint8_t), sizeof(heart_ctrl_point), (uint8_t *)heart_ctrl_point}}, }; Starting the Service When the attribute table is created, an ESP_GATTS_CREAT_ATTR_TAB_EVT event is triggered. This event has the following parameters: esp_gatt_status_t status; /*!< Operation status */ esp_bt_uuid_t svc_uuid; /*!< Service uuid type */ uint16_t num_handle; /*!< The number of the attribute handle to be added to the gatts database */ uint16_t *handles; /*!< The number to the handles */ This example uses this event to print information and to check that the size of the created table equals the number of elements in the enumeration HRS_IDX_NB. If the table is correctly created, the attribute handles are copied into the handle table heart_rate_handle_table and the service is started using the esp_ble_gatts_start_service() function: case ESP_GATTS_CREAT_ATTR_TAB_EVT:{ ESP_LOGI(GATTS_TABLE_TAG, \"The number handle =%x\\n\",param->add_attr_tab.num_handle); if (param->add_attr_tab.status != ESP_GATT_OK){ ESP_LOGE(GATTS_TABLE_TAG, \"Create attribute table failed, error code=0x%x\", param->add_attr_tab.status); } else if (param->add_attr_tab.num_handle != HRS_IDX_NB){ ESP_LOGE(GATTS_TABLE_TAG, \"Create attribute table abnormally, num_handle (%d) \\ doesn't equal to HRS_IDX_NB(%d)\", param->add_attr_tab.num_handle, HRS_IDX_NB); } else { memcpy(heart_rate_handle_table, param->add_attr_tab.handles, sizeof(heart_rate_handle_table)); esp_ble_gatts_start_service(heart_rate_handle_table[HRS_IDX_SVC]); } break; The handles stored in the handles pointer of the event parameters are numbers that identify each attribute. The handles can be used to know which characteristic is being read or written to, therefore they can be passed around and to upper layers of the application to handle different actions. Finally, the heart_rate_handle_table contains the Application Profile in the form of a structure with information about the attribute parameters as well as GATT interface, connection ID, permissions and application ID. The profile structure is shown as follows, note that not all members are used in this example: struct gatts_profile_inst { esp_gatts_cb_t gatts_cb; uint16_t gatts_if; uint16_t app_id; uint16_t conn_id; uint16_t service_handle; esp_gatt_srvc_id_t service_id; uint16_t char_handle; esp_bt_uuid_t char_uuid; esp_gatt_perm_t perm; esp_gatt_char_prop_t property; uint16_t descr_handle; esp_bt_uuid_t descr_uuid; }; Interaction with the GATT Server There are many tools that allow you to manage the connection to the GATT server. On Linux, we will use hcitool and gatttool . In Windows, you can use a tool called Bluetooth LE Explorer , that implements, albeit graphically, the same functionality. For this part of the lab assignment, you have to make visible the bluetooth controller of your host machine (laptop/pc) to the virtual machine used for the course. Using hcitool and gatttool in client mode Scanning available devices: hcitool hcitool is a command line tool that allows you to manage the Bluetooth interface of the computer on which it is running. In our case, We will need to determine the Bluetooth MAC address of our server. To do this, first of all, we will perform a scan of the devices BLE available in the environment using the command: sudo hcitool lescan Note This command will not work if you did not make the bluetooth controller available to the virtual machine. If all went well, one line per available BLE device in the announcement phase will be displayed. Among them, we must find our device, and annotate its MAC address. Task Edit the file main/gatts_table_creat_demo.c and modify the name of your device, which will be announced in each emmited advertisment packet in the advertising phase. You can achieve this by modifying the corresponding field of the structure raw_adv_data . Next, compile and flash the example, and start a session of scanning of BLE devices using the command: sudo hcitool lescan You should see your device on one of the output lines. Write down or remember its MAC address. Interacting with the GATT server: gatttool . Task 4.1 Write a small pdf report documenting all the steps and Tasks in this section. Once the Bluetooth MAC address of the device is obtained, we must proceed in two phases. The first one is to pair it to the ESP device. The second, the interaction with the GATT table. In both cases, you will use the gatttool tool from the command line. To start a gatttool session, we'll invoke the tool in interactive mode, using the command: gatttool -b MAC -I This will open an interactive console, waiting for the corresponding commands. To perform the pairing, and considering that the Bluetooth MAC is already known, we will use the connect command. If everything went well, we should observe a change in the color of the prompt, and the Connection successful message. At this point, see how the debugging output of ESP32 shows the messages corresponding to the pairing process. From the gatttool terminal, you can run the command help to get help (in the form of a list of available commands): gatttool -b 24:6F:28:36:60:B2 -I [24:6F:28:36:60:B2][LE]> connect Attempting to connect to 24:6F:28:36:60:B2 Connection successful [24:6F:28:36:60:B2][LE]> help help Show this help exit Exit interactive mode quit Exit interactive mode connect [address [address type]] Connect to a remote device disconnect Disconnect from a remote device primary [UUID] Primary Service Discovery included [start hnd [end hnd]] Find Included Services characteristics [start hnd [end hnd [UUID]]] Characteristics Discovery char-desc [start hnd] [end hnd] Characteristics Descriptor Discovery char-read-hnd <handle> Characteristics Value/Descriptor Read by handle char-read-uuid <UUID> [start hnd] [end hnd] Characteristics Value/Descriptor Read by UUID char-write-req <handle> <new value> Characteristic Value Write (Write Request) char-write-cmd <handle> <new value> Characteristic Value Write (No response) sec-level [low | medium | high] Set security level. Default: low mtu <value> Exchange MTU for GATT/ATT We'll start by looking at the list of GATT server features. Task Using the corresponding command ( characteristics ), consult and write down the features available on your GATT server. One of these characteristics will be of crucial interest, since it will allow us access, through its UUID, the instant heart rate measurement value, as well as as well as the notification settings on that value. To determine which of the lines is the one that interests us, look at the returned UUID value for each of them, and determine, based on the macro GATTS_CHAR_UUID_TEST_A which one is it. To interact with this feature, we will need to know its handler, to use it as a parameter in the gatttool commands. This handler is shown, for each line, after the string char value handle . Task The handler that allows reading the Heart Rate Value has associated a handler of type character. Write its value down. To read the value of the characteristic we can use the read command, using the annotated handler as argument ( char-read-hnd handler ). Task Read the heart rate monitoring value characteristic. What do you obtain? You should observe a four-byte return value with value 0x00. These values correspond to those of the char_value variable in your code. Modify them, rebuild the project and flash it on the ESP32. Repeat the read. Did you read the new value? Task Now try to write to the characteristic. Use the command char-write-cmd handler value , where value is, for example, 11223344 . It's possible? Why? We will now write to its client configuration characteristic descriptor. Its hancler is the handler of the characteristic's value plus one. For instance, if the handle for the value is 0x0001 , its cliente configuration characteristic would have the handle 0x0002 . Task Try now to write to the client configuration characteristic. Use the command char-write-cmd handler value , where value is, for example, 0100 . It's possible? Why? Task 4.2 As you may have noticed, it is possible to read from the monitoring value, and write to config value. We will use this last feature to configure notifications about the monitoring value. This way, each time the value changes, the clients that have activated the notifications will receive the new value. To achieve this we need to modify some parts of our code. Specifically, we will need: Create a new task that periodically modifies the heart rate value (in our case generating a new random value). This task will consist of an infinite loop that, generates a new value for the characteristic and correctly updates the gatt table. Then, if notifications have been activated, it sends the new value to the clients: static void publish_data_task(void *pvParameters) { while (1) { ESP_LOGI(\"APP\", \"Sending data...\"); // Paso 1: Actualizo valor... // Paso 2: Si notificaci\u00f3n activa... // Paso 3: Env\u00edo datos... // Paso 4: Duermo un segundo... vTaskDelay( 1000. / portTICK_PERIOD_MS); } } This routine should be created in response to the connection event by a client, using, for example, the invocation to: xTaskCreate(&publish_data_task, \"publish_data_task\", 4096, NULL, 5, NULL); The update of the value, carried out periodically and randomly, will modify byte 1 of the heart rate value, taking a random value between 0 and 255 (as an additional note, current heart rate monitors support values higher for heart rate, although the configuration of this functionality is outside the scope of practice), and then update the internal gatt table using the esp_ble_gatts_set_attr_value function. The verification of the activation or not of the notification is done by consulting the two bytes of the corresponding client configuration characteristic. If these values are 0x01 and 0x00 (positions 0 and 1, respectively), the notifications are active, and therefore, the notification shall be sent. You will need to use the function esp_ble_gatts_get_attr_value to read this descriptor. To send the notification, we will use the following function: esp_ble_gatts_send_indicate(heart_rate_profile_tab[0].gatts_if, heart_rate_profile_tab[0].conn_id, heart_rate_handle_table[IDX_CHAR_VAL_A], sizeof(char_value), char_value, false); The activation of notifications from gatttool will be done by writing the value 0x0100 in the client configuration characteristic, this is: char-write-cmd HANDLER 0100 If you also modify the UUIDs by those provided in the specification of Bluetooth for the Heart Rate Service , and everything has been configured correctly, your ESP32 should be able to interface with any heart rate monitor to, for example, Android. To do this, use the following UUIDs: static const uint16_t GATTS_SERVICE_UUID_TEST = 0x180D; //0x00FF; static const uint16_t GATTS_CHAR_UUID_TEST_A = 0x2A37; //0xFF01; static const uint16_t GATTS_CHAR_UUID_TEST_B = 0x2A38; //0xFF02; static const uint16_t GATTS_CHAR_UUID_TEST_C = 0x2A39; //0xFF03; Deliver the modified code with a small pdf report showing how you activate the notifications with gatttool, and how the node then sends a new value every second.","title":"Lab 4. Bluetooth Low Energy (BLE)"},{"location":"Subjects/NP1/P4/#lab-4-bluetooth-low-energy-ble","text":"","title":"Lab 4. Bluetooth Low Energy (BLE)"},{"location":"Subjects/NP1/P4/#goals","text":"Dissect in detail a GATT table construction firmware (GATT server) using the ESP-IDF API. Learn to use gatttool to interact with the GATT server. Modify the GATT server to accept notification requests from the client, and to publish updated values for a certain characteristic on demand.","title":"Goals"},{"location":"Subjects/NP1/P4/#gatt-sever-implementation","text":"","title":"GATT Sever Implementation"},{"location":"Subjects/NP1/P4/#introduction","text":"In this lab assignmet, we will deploy a GATT server using the ESP-IDF API. This API exposes the functionalities of Bluedroid, the Bluetooth stack (including BLE) that provides ESP-IDF for the development of Bluetooth applications. We will use the example from examples/bluetooth/bluedroid/ble/gatt_server_service_table , which example implements a Bluetooth Low Energy (BLE) Generic Attribute (GATT) Server using a table-like data structure to define the server services and characteristics such as the one shown in the figure below Therefore, it demonstrates a practical way to define the server functionality in one place instead of adding services and characteristics one by one. This example implements the Heart Rate Profile as defined by the Traditional Profile Specifications . We will therefore display three characteristics. Of them, the most important for us will be the heart rate measurement value, with its value ( Heart Rate Measurement Value ) and its notification settings ( Heart Rate Measurement Notification Configuration ). Due to the complexity of the code (at least in its initial part), this document follows the program workflow and breaks down the code in order to make sense of every section and reasoning behind the implementation.","title":"Introduction"},{"location":"Subjects/NP1/P4/#includes","text":"Let\u2019s start by taking a look at the included headers: #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"freertos/event_groups.h\" #include \"esp_system.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"esp_bt.h\" #include \"esp_gap_ble_api.h\" #include \"esp_gatts_api.h\" #include \"esp_bt_main.h\" #include \"gatts_table_creat_demo.h\" #include \"esp_gatt_common_api.h\" These includes are required for the FreeRTOS and underlaying system components to run, including logging functionality and a library to store data in non-volatile flash memory. We are interested in bt.h , esp_bt_main.h , esp_gap_ble_api.h and esp_gatts_api.h which expose the BLE APIs required to implement this example. esp_bt.h : implements BT controller and VHCI configuration procedures from the host side. esp_bt_main.h : implements initialization and enabling of the Bluedroid stack. esp_gap_ble_api.h : implements GAP configuration such as advertising and connection parameters. esp_gatts_api.h : implements GATT Server configuration such as creating services and characteristics.","title":"Includes"},{"location":"Subjects/NP1/P4/#service-table","text":"The header file gatts_table_creat_demo.h is where an enumeration of the services and characteristics is created: enum { IDX_SVC, IDX_CHAR_A, IDX_CHAR_VAL_A, IDX_CHAR_CFG_A, IDX_CHAR_B, IDX_CHAR_VAL_B, IDX_CHAR_C, IDX_CHAR_VAL_C, HRS_IDX_NB, }; The enumeration elements are set up in the same order as the Heart Rate Profile attributes, starting with the service followed by the characteristics of that service. In addition, the Heart Rate Measurement characteristic has a Client Characteristic Configuration (CCC) descriptor which is an additional attribute that describes if the characteristic has notifications enabled. The enumeration index can be used to identify each element later when creating the actual attributes table. In summary, the elements are described as follows: IDX_SVC : Heart Rate Service index IDX_CHAR_A : Heart Rate Measurement characteristic index IDX_CHAR_VAL_A : Heart Rate Measurement characteristic value index IDX_CHAR_CFG_A : Heart Rate Measurement notifications configuration (CCC) index IDX_CHAR_B : Heart Rate Body Sensor Location characteristic index IDX_CHAR_VAL_B : Heart Rate Body Sensor Location characteristic value index IDX_CHAR_C : Heart Rate Control Point characteristic index IDX_CHAR_VAL_C : Heart Rate Control Point characteristic value index IDX_NB : Number of table elements.","title":"Service Table"},{"location":"Subjects/NP1/P4/#main-entry-point","text":"The entry point to this example is the app_main() function: void app_main(void) { esp_err_t ret; /* Initialize NVS. */ ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK( ret ); ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT)); esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bluedroid_init(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s init bluetooth failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bluedroid_enable(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable bluetooth failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_ble_gatts_register_callback(gatts_event_handler); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gatts register error, error code = %x\", ret); return; } ret = esp_ble_gap_register_callback(gap_event_handler); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gap register error, error code = %x\", ret); return; } ret = esp_ble_gatts_app_register(ESP_APP_ID); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gatts app register error, error code = %x\", ret); return; } esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500); if (local_mtu_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"set local MTU failed, error code = %x\", local_mtu_ret); } } The main function starts by initializing the non-volatile storage library in order to be able to save parameters in flash memory. ret = nvs_flash_init();","title":"Main Entry Point"},{"location":"Subjects/NP1/P4/#bt-controller-and-stack-initialization","text":"The main function also initializes the BT controller by first creating a BT controller configuration structure named esp_bt_controller_config_t with default settings generated by the BT_CONTROLLER_INIT_CONFIG_DEFAULT() macro. The BT controller implements the Host Controller Interface (HCI) on the controller side, the Link Layer (LL) and the Physical Layer (PHY). The BT Controller is invisible to the user applications and deals with the lower layers of the BLE stack. The controller configuration includes setting the BT controller stack size, priority and HCI baud rate. With the settings created, the BT controller is initialized and enabled with the esp_bt_controller_init() function: esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); Next, the controller is enabled in BLE Mode. ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); There are four Bluetooth modes supported: ESP_BT_MODE_IDLE : Bluetooth not running ESP_BT_MODE_BLE : BLE mode ESP_BT_MODE_CLASSIC_BT : BT Classic mode ESP_BT_MODE_BTDM : Dual mode (BLE + BT Classic) After the initialization of the BT controller, the Bluedroid stack, which includes the common definitions and APIs for both BT Classic and BLE, is initialized and enabled by using: ret = esp_bluedroid_init(); ret = esp_bluedroid_enable(); The Bluetooth stack is up and running at this point in the program flow, however the functionality of the application has not been defined yet. The functionality is defined by reacting to events such as what happens when another device tries to read or write parameters and establish a connection. The two main managers of events are the GAP and GATT event handlers. The application needs to register a callback function for each event handler in order to let the application know which functions are going to handle the GAP and GATT events: esp_ble_gatts_register_callback(gatts_event_handler); esp_ble_gap_register_callback(gap_event_handler); The functions gatts_event_handler() and gap_event_handler() handle all the events that are pushed to the application from the BLE stack.","title":"BT Controller and Stack Initialization"},{"location":"Subjects/NP1/P4/#application-profiles","text":"This example implements one Application Profile for the Heart Rate Service. An Application Profile is a way to group functionality which is designed to be used by one client application, for example one smartphone mobile app. In this way, different types of profiles can be accommodated in one server. The Application Profile ID, which is an user-assigned number to identify each profile, is used to register the profile in the stack, in this example the ID is 0x55. #define PROFILE_NUM 1 #define PROFILE_APP_IDX 0 #define ESP_APP_ID 0x55 The profiles are stored in the heart_rate_profile_tab array. Since there is only one profile in this example, one element is stored in the array with index zero as defined by the PROFILE_APP_IDX . Additionally, the profile event handler callback function is initialized. Each application on the GATT server uses a different interface, represented by the gatts_if parameter. For initialization, this parameter is set to ESP_GATT_IF_NONE , later when the application is registered, the gatts_if parameter is updated with the corresponding interface generated by the stack. /* One gatt-based profile one app_id and one gatts_if, this array will store the gatts_if returned by ESP_GATTS_REG_EVT */ static struct gatts_profile_inst heart_rate_profile_tab[PROFILE_NUM] = { [PROFILE_APP_IDX] = { .gatts_cb = gatts_profile_event_handler, .gatts_if = ESP_GATT_IF_NONE, /* Not get the gatt_if, so initial is ESP_GATT_IF_NONE */ }, }; The application registration takes place inside app_main() using the esp_ble_gatts_app_register() function: esp_ble_gatts_app_register(ESP_HEART_RATE_APP_ID);","title":"Application Profiles"},{"location":"Subjects/NP1/P4/#setting-gap-parameters","text":"The register application event is the first one that is triggered during the lifetime of the program. This example uses this event to configure advertising parameters upon registration in the profile event handler. The functions used to achieve this are: esp_ble_gap_set_device_name() : used to set the advertised device name. esp_ble_gap_config_adv_data() : used to configure standard advertising data. The function used to configure standard Bluetooth Specification advertisement parameters is esp_ble_gap_config_adv_data() which takes a pointer to an esp_ble_adv_data_t structure. The esp_ble_adv_data_t data structure for advertising data has the following definition: typedef struct { bool set_scan_rsp; /*!< Set this advertising data as scan response or not*/ bool include_name; /*!< Advertising data include device name or not */ bool include_txpower; /*!< Advertising data include TX power */ int min_interval; /*!< Advertising data show slave preferred connection min interval */ int max_interval; /*!< Advertising data show slave preferred connection max interval */ int appearance; /*!< External appearance of device */ uint16_t manufacturer_len; /*!< Manufacturer data length */ uint8_t *p_manufacturer_data; /*!< Manufacturer data point */ uint16_t service_data_len; /*!< Service data length */ uint8_t *p_service_data; /*!< Service data point */ uint16_t service_uuid_len; /*!< Service uuid length */ uint8_t *p_service_uuid; /*!< Service uuid array point */ uint8_t flag; /*!< Advertising flag of discovery mode, see BLE_ADV_DATA_FLAG detail */ } esp_ble_adv_data_t; In this example, the structure is initialized as follows: static esp_ble_adv_data_t heart_rate_adv_config = { .set_scan_rsp = false, .include_name = true, .include_txpower = true, .min_interval = 0x0006, .max_interval = 0x0010, .appearance = 0x00, .manufacturer_len = 0, //TEST_MANUFACTURER_DATA_LEN, .p_manufacturer_data = NULL, //&test_manufacturer[0], .service_data_len = 0, .p_service_data = NULL, .service_uuid_len = sizeof(heart_rate_service_uuid), .p_service_uuid = heart_rate_service_uuid, .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT), }; The minimum and maximum slave preferred connection intervals are set in units of 1.25 ms. In this example, the minimum slave preferred connection interval is defined as 0x0006 * 1.25 ms = 7.5 ms and the maximum slave preferred connection interval is initialized as 0x0010 * 1.25 ms = 20 ms. An advertising payload can be up to 31 bytes of data. It is possible that some of the parameters surpass the 31-byte advertisement packet limit which causes the stack to cut the message and leave some of the parameters out. To solve this, usually the longer parameters are stored in the scan response, which can be configured using the same esp_ble_gap_config_adv_data() function and an additional esp_ble_adv_data_t type structure with the .set_scan_rsp parameter is set to true. Finally, to set the device name the esp_ble_gap_set_device_name() function is used. The registering event handler is shown as follows: static void gatts_profile_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { ESP_LOGE(GATTS_TABLE_TAG, \"event = %x\\n\",event); switch (event) { case ESP_GATTS_REG_EVT: ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME); ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); esp_ble_gap_config_adv_data(&heart_rate_adv_config); ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); ...","title":"Setting GAP Parameters"},{"location":"Subjects/NP1/P4/#gap-event-handler","text":"Once the advertising data have been set, the ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT is triggered and managed by the GAP event handler. Moreover, an ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT is triggered as well if the scan response is also set. Once the configuration of the advertising and scan response data has been set, the handler can use any of these events to start advertising, which is done using the esp_ble_gap_start_advertising() function: static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param) { ESP_LOGE(GATTS_TABLE_TAG, \"GAP_EVT, event %d\\n\", event); switch (event) { case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT: esp_ble_gap_start_advertising(&heart_rate_adv_params); break; case ESP_GAP_BLE_ADV_START_COMPLETE_EVT: //advertising start complete event to indicate advertising start successfully or failed if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTS_TABLE_TAG, \"Advertising start failed\\n\"); } break; default: break; } } The function to start advertising takes a structure of type esp_ble_adv_params_t with the advertising parameters required. /// Advertising parameters typedef struct { uint16_t adv_int_min; /*!< Minimum advertising interval for undirected and low duty cycle directed advertising. Range: 0x0020 to 0x4000 Default: N = 0x0800 (1.28 second) Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec */ uint16_t adv_int_max; /*!< Maximum advertising interval for undirected and low duty cycle directed advertising. Range: 0x0020 to 0x4000 Default: N = 0x0800 (1.28 second) Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec */ esp_ble_adv_type_t adv_type; /*!< Advertising type */ esp_ble_addr_type_t own_addr_type; /*!< Owner bluetooth device address type */ esp_bd_addr_t peer_addr; /*!< Peer device bluetooth device address */ esp_ble_addr_type_t peer_addr_type; /*!< Peer device bluetooth device address type */ esp_ble_adv_channel_t channel_map; /*!< Advertising channel map */ esp_ble_adv_filter_t adv_filter_policy; /*!< Advertising filter policy */ } esp_ble_adv_params_t; Note that esp_ble_gap_config_adv_data() configures the data that is advertised to the client and takes an esp_ble_adv_data_t structure , while esp_ble_gap_start_advertising() makes the server to actually start advertising and takes an esp_ble_adv_params_t structure. The advertising data is the information that is shown to the client, while the advertising parameters are the configuration required by the BLE stack to execute. For this example, the advertisement parameters are initialized as follows: static esp_ble_adv_params_t heart_rate_adv_params = { .adv_int_min = 0x20, .adv_int_max = 0x40, .adv_type = ADV_TYPE_IND, .own_addr_type = BLE_ADDR_TYPE_PUBLIC, //.peer_addr = //.peer_addr_type = .channel_map = ADV_CHNL_ALL, .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY, }; These parameters configure the advertising interval between 20 ms to 40 ms. The advertisement is of type ADV_IND, which is generic, not directed to a particular central device and advertises the server as connectable. The address type is public, uses all channels and allows both scan and connection requests from any central. If the advertising started successfully, an ESP_GAP_BLE_ADV_START_COMPLETE_EVT event is generated which in this example is used to check if the advertising status is indeed advertising or otherwise print an error message. ... case ESP_GAP_BLE_ADV_START_COMPLETE_EVT: //advertising start complete event to indicate advertising start successfully or failed if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTS_TABLE_TAG, \"Advertising start failed\\n\"); } break; ...","title":"GAP Event Handler"},{"location":"Subjects/NP1/P4/#gatt-event-handlers","text":"When an Application Profile is registered, an ESP_GATTS_REG_EVT event is triggered. The parameters of the ESP_GATTS_REG_EVT are: esp_gatt_status_t status; /*!< Operation status */ uint16_t app_id; /*!< Application id which input in register API */ In addition to the previous parameters, the event also contains the GATT interface assigned by the BLE stack. The event is captured by the gatts_event_handler() which stores the generated interface in the profile table and then forwards it to the corresponding profile event handler. static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { ESP_LOGI(GATTS_TABLE_TAG, \"EVT %d, gatts if %d\\n\", event, gatts_if); /* If event is register event, store the gatts_if for each profile */ if (event == ESP_GATTS_REG_EVT) { if (param->reg.status == ESP_GATT_OK) { heart_rate_profile_tab[HEART_PROFILE_APP_IDX].gatts_if = gatts_if; } else { ESP_LOGI(GATTS_TABLE_TAG, \"Reg app failed, app_id %04x, status %d\\n\", param->reg.app_id, param->reg.status); return; } } do { int idx; for (idx = 0; idx < HEART_PROFILE_NUM; idx++) { if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */ gatts_if == heart_rate_profile_tab[idx].gatts_if) { if (heart_rate_profile_tab[idx].gatts_cb) { heart_rate_profile_tab[idx].gatts_cb(event, gatts_if, param); } } } } while (0); }","title":"GATT Event Handlers"},{"location":"Subjects/NP1/P4/#creating-services-and-characteristics-with-the-attribute-table","text":"The register event is used to create a table of profile attributes by employing the esp_ble_gatts_create_attr_tab() function. This function takes an argument of type esp_gatts_attr_db_t which corresponds to a look up table keyed by the enumeration values defined in the header file. The esp_gatts_attr_db_t structure has two members: esp_attr_control_t attr_control; /*!< The attribute control type*/ esp_attr_desc_t att_desc; /*!< The attribute type*/ The attr_control is the auto-respond parameter which can be set as ESP_GATT_AUTO_RSP to allow the BLE stack to take care of responding messages when read or write events arrive. The other option is ESP_GATT_RSP_BY_APP which allows to manually respond to messages using the esp_ble_gatts_send_response() function. The att_desc is the attribute description which is made of: uint16_t uuid_length; /*!< UUID length */ uint8_t *uuid_p; /*!< UUID value */ uint16_t perm; /*!< Attribute permission */ uint16_t max_length; /*!< Maximum length of the element*/ uint16_t length; /*!< Current length of the element*/ uint8_t *value; /*!< Element value array*/ For example, the first element of the table in this example is the service attribute: [HRS_IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&heart_rate_svc}}, The initialization values are: [HRS_IDX_SVC] : Named or designated initializer in the enum table. ESP_GATT_AUTO_RSP : Auto respond configuration, set to respond automatically by the stack. ESP_UUID_LEN_16 : UUID length set to 16 bits. (uint8_t *)&primary_service_uuid : UUID to identify the service as a primary one (0x2800). ESP_GATT_PERM_READ : Read Permission for the service. sizeof(uint16_t) : Maximum length of the service UUID (16 bits). sizeof(heart_rate_svc) : Current service length set to the size of the variable heart_rate_svc , which is 16 bits. (uint8_t *)&heart_rate_svc : Service attribute value set to the variable heart_rate_svc which contains the Heart Rate Service UUID (0x180D). The rest of the attributes is initialized in the same way. Some attributes also have the NOTIFY property which is set by &char_prop_notify . The complete table structure is initialized as follows: /// Full HRS Database Description - Used to add attributes into the database static const esp_gatts_attr_db_t heart_rate_gatt_db[HRS_IDX_NB] = { // Heart Rate Service Declaration [HRS_IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&heart_rate_svc}}, // Heart Rate Measurement Characteristic Declaration [HRS_IDX_HR_MEAS_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_notify}}, // Heart Rate Measurement Characteristic Value [HRS_IDX_HR_MEAS_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&heart_rate_meas_uuid, ESP_GATT_PERM_READ, HRPS_HT_MEAS_MAX_LEN,0, NULL}}, // Heart Rate Measurement Characteristic - Client Characteristic Configuration Descriptor [HRS_IDX_HR_MEAS_NTF_CFG] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE, sizeof(uint16_t),sizeof(heart_measurement_ccc), (uint8_t *)heart_measurement_ccc}}, // Body Sensor Location Characteristic Declaration [HRS_IDX_BOBY_SENSOR_LOC_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read}}, // Body Sensor Location Characteristic Value [HRS_IDX_BOBY_SENSOR_LOC_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&body_sensor_location_uuid, ESP_GATT_PERM_READ, sizeof(uint8_t), sizeof(body_sensor_loc_val), (uint8_t *)body_sensor_loc_val}}, // Heart Rate Control Point Characteristic Declaration [HRS_IDX_HR_CTNL_PT_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write}}, // Heart Rate Control Point Characteristic Value [HRS_IDX_HR_CTNL_PT_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&heart_rate_ctrl_point, ESP_GATT_PERM_WRITE|ESP_GATT_PERM_READ, sizeof(uint8_t), sizeof(heart_ctrl_point), (uint8_t *)heart_ctrl_point}}, };","title":"Creating Services and Characteristics with the Attribute Table"},{"location":"Subjects/NP1/P4/#starting-the-service","text":"When the attribute table is created, an ESP_GATTS_CREAT_ATTR_TAB_EVT event is triggered. This event has the following parameters: esp_gatt_status_t status; /*!< Operation status */ esp_bt_uuid_t svc_uuid; /*!< Service uuid type */ uint16_t num_handle; /*!< The number of the attribute handle to be added to the gatts database */ uint16_t *handles; /*!< The number to the handles */ This example uses this event to print information and to check that the size of the created table equals the number of elements in the enumeration HRS_IDX_NB. If the table is correctly created, the attribute handles are copied into the handle table heart_rate_handle_table and the service is started using the esp_ble_gatts_start_service() function: case ESP_GATTS_CREAT_ATTR_TAB_EVT:{ ESP_LOGI(GATTS_TABLE_TAG, \"The number handle =%x\\n\",param->add_attr_tab.num_handle); if (param->add_attr_tab.status != ESP_GATT_OK){ ESP_LOGE(GATTS_TABLE_TAG, \"Create attribute table failed, error code=0x%x\", param->add_attr_tab.status); } else if (param->add_attr_tab.num_handle != HRS_IDX_NB){ ESP_LOGE(GATTS_TABLE_TAG, \"Create attribute table abnormally, num_handle (%d) \\ doesn't equal to HRS_IDX_NB(%d)\", param->add_attr_tab.num_handle, HRS_IDX_NB); } else { memcpy(heart_rate_handle_table, param->add_attr_tab.handles, sizeof(heart_rate_handle_table)); esp_ble_gatts_start_service(heart_rate_handle_table[HRS_IDX_SVC]); } break; The handles stored in the handles pointer of the event parameters are numbers that identify each attribute. The handles can be used to know which characteristic is being read or written to, therefore they can be passed around and to upper layers of the application to handle different actions. Finally, the heart_rate_handle_table contains the Application Profile in the form of a structure with information about the attribute parameters as well as GATT interface, connection ID, permissions and application ID. The profile structure is shown as follows, note that not all members are used in this example: struct gatts_profile_inst { esp_gatts_cb_t gatts_cb; uint16_t gatts_if; uint16_t app_id; uint16_t conn_id; uint16_t service_handle; esp_gatt_srvc_id_t service_id; uint16_t char_handle; esp_bt_uuid_t char_uuid; esp_gatt_perm_t perm; esp_gatt_char_prop_t property; uint16_t descr_handle; esp_bt_uuid_t descr_uuid; };","title":"Starting the Service"},{"location":"Subjects/NP1/P4/#interaction-with-the-gatt-server","text":"There are many tools that allow you to manage the connection to the GATT server. On Linux, we will use hcitool and gatttool . In Windows, you can use a tool called Bluetooth LE Explorer , that implements, albeit graphically, the same functionality. For this part of the lab assignment, you have to make visible the bluetooth controller of your host machine (laptop/pc) to the virtual machine used for the course.","title":"Interaction with the GATT Server"},{"location":"Subjects/NP1/P4/#using-hcitool-and-gatttool-in-client-mode","text":"","title":"Using hcitool and gatttool in client mode"},{"location":"Subjects/NP1/P4/#scanning-available-devices-hcitool","text":"hcitool is a command line tool that allows you to manage the Bluetooth interface of the computer on which it is running. In our case, We will need to determine the Bluetooth MAC address of our server. To do this, first of all, we will perform a scan of the devices BLE available in the environment using the command: sudo hcitool lescan Note This command will not work if you did not make the bluetooth controller available to the virtual machine. If all went well, one line per available BLE device in the announcement phase will be displayed. Among them, we must find our device, and annotate its MAC address. Task Edit the file main/gatts_table_creat_demo.c and modify the name of your device, which will be announced in each emmited advertisment packet in the advertising phase. You can achieve this by modifying the corresponding field of the structure raw_adv_data . Next, compile and flash the example, and start a session of scanning of BLE devices using the command: sudo hcitool lescan You should see your device on one of the output lines. Write down or remember its MAC address.","title":"Scanning available devices: hcitool"},{"location":"Subjects/NP1/P4/#interacting-with-the-gatt-server-gatttool","text":"Task 4.1 Write a small pdf report documenting all the steps and Tasks in this section. Once the Bluetooth MAC address of the device is obtained, we must proceed in two phases. The first one is to pair it to the ESP device. The second, the interaction with the GATT table. In both cases, you will use the gatttool tool from the command line. To start a gatttool session, we'll invoke the tool in interactive mode, using the command: gatttool -b MAC -I This will open an interactive console, waiting for the corresponding commands. To perform the pairing, and considering that the Bluetooth MAC is already known, we will use the connect command. If everything went well, we should observe a change in the color of the prompt, and the Connection successful message. At this point, see how the debugging output of ESP32 shows the messages corresponding to the pairing process. From the gatttool terminal, you can run the command help to get help (in the form of a list of available commands): gatttool -b 24:6F:28:36:60:B2 -I [24:6F:28:36:60:B2][LE]> connect Attempting to connect to 24:6F:28:36:60:B2 Connection successful [24:6F:28:36:60:B2][LE]> help help Show this help exit Exit interactive mode quit Exit interactive mode connect [address [address type]] Connect to a remote device disconnect Disconnect from a remote device primary [UUID] Primary Service Discovery included [start hnd [end hnd]] Find Included Services characteristics [start hnd [end hnd [UUID]]] Characteristics Discovery char-desc [start hnd] [end hnd] Characteristics Descriptor Discovery char-read-hnd <handle> Characteristics Value/Descriptor Read by handle char-read-uuid <UUID> [start hnd] [end hnd] Characteristics Value/Descriptor Read by UUID char-write-req <handle> <new value> Characteristic Value Write (Write Request) char-write-cmd <handle> <new value> Characteristic Value Write (No response) sec-level [low | medium | high] Set security level. Default: low mtu <value> Exchange MTU for GATT/ATT We'll start by looking at the list of GATT server features. Task Using the corresponding command ( characteristics ), consult and write down the features available on your GATT server. One of these characteristics will be of crucial interest, since it will allow us access, through its UUID, the instant heart rate measurement value, as well as as well as the notification settings on that value. To determine which of the lines is the one that interests us, look at the returned UUID value for each of them, and determine, based on the macro GATTS_CHAR_UUID_TEST_A which one is it. To interact with this feature, we will need to know its handler, to use it as a parameter in the gatttool commands. This handler is shown, for each line, after the string char value handle . Task The handler that allows reading the Heart Rate Value has associated a handler of type character. Write its value down. To read the value of the characteristic we can use the read command, using the annotated handler as argument ( char-read-hnd handler ). Task Read the heart rate monitoring value characteristic. What do you obtain? You should observe a four-byte return value with value 0x00. These values correspond to those of the char_value variable in your code. Modify them, rebuild the project and flash it on the ESP32. Repeat the read. Did you read the new value? Task Now try to write to the characteristic. Use the command char-write-cmd handler value , where value is, for example, 11223344 . It's possible? Why? We will now write to its client configuration characteristic descriptor. Its hancler is the handler of the characteristic's value plus one. For instance, if the handle for the value is 0x0001 , its cliente configuration characteristic would have the handle 0x0002 . Task Try now to write to the client configuration characteristic. Use the command char-write-cmd handler value , where value is, for example, 0100 . It's possible? Why?","title":"Interacting with the GATT server: gatttool."},{"location":"Subjects/NP1/P4/#task-42","text":"As you may have noticed, it is possible to read from the monitoring value, and write to config value. We will use this last feature to configure notifications about the monitoring value. This way, each time the value changes, the clients that have activated the notifications will receive the new value. To achieve this we need to modify some parts of our code. Specifically, we will need: Create a new task that periodically modifies the heart rate value (in our case generating a new random value). This task will consist of an infinite loop that, generates a new value for the characteristic and correctly updates the gatt table. Then, if notifications have been activated, it sends the new value to the clients: static void publish_data_task(void *pvParameters) { while (1) { ESP_LOGI(\"APP\", \"Sending data...\"); // Paso 1: Actualizo valor... // Paso 2: Si notificaci\u00f3n activa... // Paso 3: Env\u00edo datos... // Paso 4: Duermo un segundo... vTaskDelay( 1000. / portTICK_PERIOD_MS); } } This routine should be created in response to the connection event by a client, using, for example, the invocation to: xTaskCreate(&publish_data_task, \"publish_data_task\", 4096, NULL, 5, NULL); The update of the value, carried out periodically and randomly, will modify byte 1 of the heart rate value, taking a random value between 0 and 255 (as an additional note, current heart rate monitors support values higher for heart rate, although the configuration of this functionality is outside the scope of practice), and then update the internal gatt table using the esp_ble_gatts_set_attr_value function. The verification of the activation or not of the notification is done by consulting the two bytes of the corresponding client configuration characteristic. If these values are 0x01 and 0x00 (positions 0 and 1, respectively), the notifications are active, and therefore, the notification shall be sent. You will need to use the function esp_ble_gatts_get_attr_value to read this descriptor. To send the notification, we will use the following function: esp_ble_gatts_send_indicate(heart_rate_profile_tab[0].gatts_if, heart_rate_profile_tab[0].conn_id, heart_rate_handle_table[IDX_CHAR_VAL_A], sizeof(char_value), char_value, false); The activation of notifications from gatttool will be done by writing the value 0x0100 in the client configuration characteristic, this is: char-write-cmd HANDLER 0100 If you also modify the UUIDs by those provided in the specification of Bluetooth for the Heart Rate Service , and everything has been configured correctly, your ESP32 should be able to interface with any heart rate monitor to, for example, Android. To do this, use the following UUIDs: static const uint16_t GATTS_SERVICE_UUID_TEST = 0x180D; //0x00FF; static const uint16_t GATTS_CHAR_UUID_TEST_A = 0x2A37; //0xFF01; static const uint16_t GATTS_CHAR_UUID_TEST_B = 0x2A38; //0xFF02; static const uint16_t GATTS_CHAR_UUID_TEST_C = 0x2A39; //0xFF03; Deliver the modified code with a small pdf report showing how you activate the notifications with gatttool, and how the node then sends a new value every second.","title":"Task 4.2"},{"location":"Subjects/NP1/P5/","text":"Lab 5. Bluetooth Mesh (BLE MESH) Goals Put into practice the concepts studied in theory in relation to BLE MESH, specifically the provisioning and client/server models. Deploy a provisioning infrastructure for an ONOFF GENERIC model SERVER with provisioning from mobile application for remote control of on/off LEDs. Deploy a provisioning infrastructure of a GENERIC SENSOR model provisioned from ESP32. Example for the ON-OFF MODEL The codes that we will study in this lab assignment are in examples/bluetooth/esp_ble_mesh/ble_mesh_node in the system case OnOff (first part of the assignment) and ble_mesh_sensor_model for the sensor model (second part). In addition, download and install on your smartphone the application nRF Mesh (available both for Android and IOS). You will use this application to provision the devices and interact with the mesh. The ON-OFF server This server implements only one element with two models: Configuration Server model : The role of this model is mainly to configure Provisioner device\u2019s AppKey and set up its relay function, TTL size, subscription, etc. Generic OnOff Server model : This model implements the most basic function of turning the lights on and off. The code in ble_mesh_demo_main.c contains the following main application codes, that we can summarize as: * Initialize Bluetooth Controller stack and Host stack (bluedroid) * Initialize BLE Mesh stack * Register the callback function of BLE Mesh provision and BLE Mesh model * Implement and initialize BLE Mesh element * Implement and initialize BLE Mesh Configuration Server model and Generic OnOff Server model * Function as BLE Mesh Configuration Server Model Get Opcode and BLE Mesh Configuration Server Model Set Opcode * Declare and define the RGB LED structure. For better understanding of the code, the following sections provide a detailed analysis the file ble_mesh_demo_main.c . 1. Initializing and Enabling BLE Mesh When ESP32 system initialization is completed, app_main is called. The code block below demonstrates the implementation of the functions in app_main . void app_main(void) { int err; ESP_LOGI(TAG, \"Initializing...\"); board_init(); err = bluetooth_init(); if (err) { ESP_LOGE(TAG, \"esp32_bluetooth_init failed (err %d)\", err); return; } /* Initializes the Bluetooth Mesh Subsystem */ err = ble_mesh_init(); if (err) { ESP_LOGE(TAG, \"Bluetooth mesh init failed (err %d)\", err); } } In particular, the code includes: - err = bluetooth_init() : initialization related to the Bluetooth protocol stack (including Controller and Host) - err = ble_mesh_init() : initialization related to BLE Mesh Further, the code for initialization of the BLE Mesh protocol stack is introduced, together with the description of the required actions to initialize BLE Mesh. static esp_err_t ble_mesh_init(void) { int err = 0; memcpy(dev_uuid + 2, esp_bt_dev_get_address(), BLE_MESH_ADDR_LEN); // See comment 1 esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb); esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb); err = esp_ble_mesh_init(&provision, &composition); if (err) { ESP_LOGE(TAG, \"Initializing mesh failed (err %d)\", err); return err; } esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT); ESP_LOGI(TAG, \"BLE Mesh Node initialized\"); board_led_operation(LED_G, LED_ON); return err; } Observet that the code includes the following funtionality: esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb) : registers the provisioning callback function in the BLE Mesh stack. This callback function gets executed during the BLE Mesh network configuration process. It allows the BLE Mesh stack to generate events and notify the application layer about important network configuration processes. This callback function mainly implements the following events: ESP_BLE_MESH_PROVISION_REG_EVT : Generated when the BLE Mesh initialization process is completed after calling the API function esp_ble_mesh_init . It returns the initialization status of the BLE Mesh application. ESP_BLE_MESH_NODE_PROV_LINK_OPEN_EVT : Generated when a Provisioner and an unprovisioned device establish a link. ESP_BLE_MESH_NODE_PROV_LINK_CLOSE_EVT : Generated to notify the application layer that a link has been broken after BLE Mesh bottom-layer protocol sends or receives the message The Link Broken . ESP_BLE_MESH_NODE_PROV_OUTPUT_NUMBER_EVT : Received by the application layer if during the configuration process output_actions is set as ESP_BLE_MESH_DISPLAY_NUMBER , and the target peer input_actions is set as ESP_BLE_MESH_ENTER_NUMBER . ESP_BLE_MESH_NODE_PROV_OUTPUT_STRING_EVT : Received by the application layer if during the configuration process output_actions is set as ESP_BLE_MESH_DISPLAY_STRING , and the target peer input_actions is set as ESP_BLE_MESH_ENTER_STRING . ESP_BLE_MESH_NODE_PROV_INPUT_EVT : Received by the application layer if during the configuration process input_actions is set as anything but ESP_BLE_MESH_NO_INPUT . ESP_BLE_MESH_NODE_PROV_COMPLETE_EVT : Received by the application layer when the provisioning is completed. ESP_BLE_MESH_NODE_PROV_RESET_EVT : Received by the application layer when the network reset is completed. esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb) : registers the model operation callback function. This callback function is used when the target peer operates the model state of the source peer after BLE Mesh has completed network configuration. This callback function mainly implements the following events: ESP_BLE_MESH_MODEL_OPERATION_EVT : Can be triggered by the two scenarios below: Server model receives Get Status or Set Status from Client model. Client model receives Status state from Server model. ESP_BLE_MESH_MODEL_SEND_COMP_EVT : Generated after the Server model sends Status state by calling the API function esp_ble_mesh_server_model_send_msg . ESP_BLE_MESH_MODEL_PUBLISH_COMP_EVT : Generated after the application has completed calling the API esp_ble_mesh_model_publish_msg to publish messages ESP_BLE_MESH_CLIENT_MODEL_SEND_TIMEOUT_EVT : Generated when the Client model calls the API function esp_ble_mesh_client_model_send_msg , but fails to receive ACK from the target peer due to timeout ESP_BLE_MESH_MODEL_PUBLISH_UPDATE_EVT : Generated after the application sets up the publish function to regularly send messages to the target peer. esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT) : enables the Advertising and Scan functions when the BLE Mesh initialization is completed. It makes the devices visible to Provisioners for network provisioning. board_led_operation(LED_G, LED_ON) : initializes the RGB LED. At this point, initialization and enabling of BLE Mesh as a node port is completed, which means a Provisioner can identify devices for network provisioning and data transmission. 2 Implementation of BLE Mesh Element Structure In this section we shows: - Things that have to be done before the initialization of the previous section - How to add an element and a model to ESP BLE Mesh stack - How to choose a different encryption approach - How to declare the features of Proxy, Relay, Low Power and Friend First of all, before calling the API esp_ble_mesh_init to initialize BLE Mesh, an element and a model need to be declared and defined. The code block below shows the declaration of an element structure. /*!< Abstraction that describes a BLE Mesh Element. This structure is associated with bt_mesh_elem in mesh_access.h */ typedef struct { /* Element Address, it is assigned during provisioning. */ uint16_t element_addr; /* Location Descriptor (GATT Bluetooth Namespace Descriptors) */ const uint16_t location; /* Model count */ const uint8_t sig_model_count; const uint8_t vnd_model_count; /* Models */ esp_ble_mesh_model_t *sig_models; esp_ble_mesh_model_t *vnd_models; } esp_ble_mesh_elem_t; The next code block shows the definition of an element structure, build from the ESP_BLE_MESH_ELEMENT macro. static esp_ble_mesh_elem_t elements[] = { ESP_BLE_MESH_ELEMENT(0, root_models, ESP_BLE_MESH_MODEL_NONE), }; Another code block provides the codes needed to implement the macro ESP_BLE_MESH_ELEMENT . #define ESP_BLE_MESH_ELEMENT(_loc, _mods, _vnd_mods) \\ { \\ .location = (_loc), \\ .sig_model_count = ARRAY_SIZE(_mods), \\ .sig_models = (_mods), \\ .vnd_model_count = ARRAY_SIZE(_vnd_mods), \\ .vnd_models = (_vnd_mods), \\ } The variables of the element structure are as follows: addr : stores the element primary address, used by Mesh Stack during the configuration process. It can be ignored for the higher level applications. loc : location descriptor defined by SIG. For this demo, set its value to 0 . model_count : number of SIG models supported in this element. vnd_model_count : number of the Vendor model supported in this element. models : pointer to the SIG Models that have already been defined. vnd_models : pointer to the Vendor Model that has already been defined. 3 Implementation of BLE Mesh Model Structure The preceding section has introduced the specific ways to implement and define an element by passing specific model pointers to it. This section explains how to implement and define a Model structure, which is shown in the code blocks below. /** Abstraction that describes a Mesh Model instance. * This structure is associated with bt_mesh_model in mesh_access.h */ struct esp_ble_mesh_model { /* Model ID */ union { const uint16_t model_id; struct { uint16_t company_id; uint16_t model_id; } vnd; }; /* The Element to which this Model belongs */ esp_ble_mesh_elem_t *element; /* Model Publication */ esp_ble_mesh_model_pub_t *const pub; /* AppKey List */ uint16_t keys[CONFIG_BLE_MESH_MODEL_KEY_COUNT]; /* Subscription List (group or virtual addresses) */ uint16_t groups[CONFIG_BLE_MESH_MODEL_GROUP_COUNT]; /* Model operation context */ esp_ble_mesh_model_op_t *op; /* Model-specific user data */ void *user_data; }; The block above shows a specific implementation of the model structure. Although this structure has many variables, only the following four ones are used for applications: id and vnd : union variables, defining the SIG Model and the Vendor Model respectively. op : structure with a set of variables for the Model Operation, declaring the opcode that corresponds to Get, Set, or Status State, as well as the minimum value lengths that are supported in this module. pub : structure that needs to be defined if the Model structure supports the Publish function. user_data : optional variable for storing the application layer data. The other structures and variables (keys, group, element) get their values through the BLE Mesh stack during the initialization or configuration stages. You are not required to initialize them. The next code block presents the definition of the model structure, and the root_models[] array. This array is used for indicating the number of the existing model structures. A model is implemented by using a macro. static esp_ble_mesh_model_t root_models[] = { ESP_BLE_MESH_MODEL_CFG_SRV(&config_server), ESP_BLE_MESH_SIG_MODEL(ESP_BLE_MESH_MODEL_ID_GEN_ONOFF_SRV, onoff_op, &onoff_pub, &led_state[0]), }; Different models require different macros. The existing types of models and their respective macros needed for implementation are given in the table below (as we are implementing a Generic OnOff Server model, we use the ESP_BLE_MESH_MODEL_ID_GEN_ONOFF_SRV macro). Model Name Macro Required for its Definition Configuration Server Model ESP_BLE_MESH_MODEL_CFG_SRV Configuration Client Model ESP_BLE_MESH_MODEL_CFG_CLI Generic OnOff Client Model ESP_BLE_MESH_MODEL_GEN_ONOFF_CLI Generic Level Client Model ESP_BLE_MESH_MODEL_GEN_LEVEL_CLI Generic Default Transition Time Client Model ESP_BLE_MESH_MODEL_GEN_DEF_TRANS_TIME_CLI Generic Power OnOff Client Model ESP_BLE_MESH_MODEL_GEN_POWER_ONOFF_CLI Generic Power Level Client Model ESP_BLE_MESH_MODEL_GEN_POWER_LEVEL_CLI Generic Battery Client Model ESP_BLE_MESH_MODEL_GEN_BATTERY_CLI Generic Location Client Model ESP_BLE_MESH_MODEL_GEN_LOCATION_CLI Generic Property Client Model ESP_BLE_MESH_MODEL_GEN_PROPERTY_CLI Light Lightness Client Model ESP_BLE_MESH_MODEL_LIGHT_LIGHTNESS_CLI Light CTL Client Model ESP_BLE_MESH_MODEL_LIGHT_CTL_CLI Light HSL Client Model ESP_BLE_MESH_MODEL_LIGHT_HSL_CLI Sensor Client Model ESP_BLE_MESH_MODEL_SENSOR_CLI Scene Client Model ESP_BLE_MESH_MODEL_SCENE_CLI Another important structure in a model is the esp_ble_mesh_model_op_t *op pointer. This structure points to the operation structure that defines the Model state. Generally, there are two types of models in BLE Mesh: Server Model : Consists of one or multiple states that can exist across different elements Defines the messages sent/received by the model, along with the element's behavior. Example\uff1aOn/Off switch --- Indicates the On/Off status. Client Model : Defines the messages used by the client to request, change or use the relevant state of the server. Example\uff1aOn/Off switch --- Indicates the On or Off message sent by the Client. The following code block shows the declaration of the Model operation structure. /*!< Model operation context. This structure is associated with bt_mesh_model_op in mesh_access.h */ typedef struct { const uint32_t opcode; /* Opcode encoded with the ESP_BLE_MESH_MODEL_OP_* macro */ const size_t min_len; /* Minimum required message length */ esp_ble_mesh_cb_t param_cb; /* The callback is only used for the BLE Mesh stack, not for the app layer. */ } esp_ble_mesh_model_op_t; There are three variables in the declaration of the operation structure: opcode : opcode corresponding to a state. As specified in BLE Mesh, the SIG Model opcode should be 1~2 bytes, and the Vendor Model opcode should be 3 bytes. min_len : min length of the messages received by the state. For example, OnOff Get state is 0 bytes, and OnOff Set State is 2 bytes. param_cb : used for the BLE Mesh protocol only. Applications need to set its value to 0 . The definition for our OnOff Server code is: static esp_ble_mesh_model_op_t onoff_op[] = { { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_GET, 0, 0}, { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET, 2, 0}, { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK, 2, 0}, /* Each model operation struct array must use this terminator * as the end tag of the operation uint. */ ESP_BLE_MESH_MODEL_OP_END, }; The OnOff Client The design of the client is much easier. In a generic way, it just defines an ON/OFF Client model and waits to be provisioned. Once the provisioning process is completed, every time one of the buttons on the board (RESET) is pressed, it sends a request for a change in the status of the lights to all the nodes in its mesh network. This behaviour is coded in the following functions defined in the board.c file: static void button_tap_cb(void* arg) { ESP_LOGI(TAG, \"tap cb (%s)\", (char *)arg); example_ble_mesh_send_gen_onoff_set(); } static void board_button_init(void) { button_handle_t btn_handle = iot_button_create(BUTTON_IO_NUM, BUTTON_ACTIVE_LEVEL); if (btn_handle) { iot_button_set_evt_cb(btn_handle, BUTTON_CB_RELEASE, button_tap_cb, \"RELEASE\"); } } void board_init(void) { board_led_init(); board_button_init(); } The invoked function, example_ble_mesh_send_gen_onoff_set , sends a SET operation to all network members: void example_ble_mesh_send_gen_onoff_set(void) { esp_ble_mesh_generic_client_set_state_t set = {0}; esp_ble_mesh_client_common_param_t common = {0}; esp_err_t err = ESP_OK; common.opcode = ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK; common.model = onoff_client.model; common.ctx.net_idx = store.net_idx; common.ctx.app_idx = store.app_idx; common.ctx.addr = 0xFFFF; /* to all nodes */ common.ctx.send_ttl = 3; common.ctx.send_rel = false; common.msg_timeout = 0; /* 0 indicates that timeout value from menuconfig will be used */ common.msg_role = ROLE_NODE; set.onoff_set.op_en = false; set.onoff_set.onoff = store.onoff; set.onoff_set.tid = store.tid++; err = esp_ble_mesh_generic_client_set_state(&common, &set); if (err) { ESP_LOGE(TAG, \"Send Generic OnOff Set Unack failed\"); return; } store.onoff = !store.onoff; mesh_example_info_store(); /* Store proper mesh example info */ } Observe that the destination address is for all nodes in the network ( common.ctx.addr = 0xFFFF; ). Provisioning and control from a mobile application You will use the two ESP nodes you have, one programmed as an OnOff Server and the other programmed as an OnOff Client. If you have three LEDs available, you can place the server node on a breadboard and connect the anodes of the LEDs to the pins where the server node expects the lights to be connected (you can find those in the board.h file, mainly the pins 25, 26 and 27). It is convenient that you also place in series a current limmitng resistor, a 220 ohm resistor should be fine. You can run the two nodes and monitor its output (use the idf.py command). Once both are up and running you will use the nRF Mesh app on your smartphone to complete the provisioning of both nodes, creating a ble mesh for thme. To complete the provisioning you have to proceed as follows: STEP 1 : the initial screen will show you the nodes that are already provisioned (initially none). STEP 2 : you will click on ADD NODE and provision (one by one) your two nodes: STEP 3 : you have to generate the network information for the new node ( identify it), pressing IDENTIFY : STEP 4 : once the network information has been generated, you can provision the node (pressing PROVISION ): STEP 5 : if everything went well, a success message like the following one will be shown: STEP 6 : after repeating this step with the two nodes in our group, you will see a screen like the following. Observe and write down the unicast addresses of each node. The node with one item is the OnOff Client; the node with three elements is the OnOff Server. Next, you will generate a group of nodes. This will allow you to subscribe the models to it, and publish messages that will be broadcasted to all models in the group. STEP 7 : Create a new group by pressing the + button. Give it the name and address you want, for example, Living Room , 0xC000 . If everything went well, you will see a single valid group with no nodes associated/subscribed to it. STEP 8 : Next, you will subscribe each Generic On Off Server and Generic On Off Client models to the group you just created. You have to do it node by node, first by clicking on the concrete model: And then associate an application key ( BIND KEY ) and subscribe ( SUBSCRIBE ) to the desired group: Now, if all went well, if you go to the group description tab, you will see an icon with a picture for the lights, and another icon for the client (a swithc). At this point, if you are monitoring the output of all ESP32s, you will see that the state of the LED changes at the request of the application (pressing the light icon). In addition, you will see that it also changes if you press the corresponding button of the switch ( RESET ) on the board. If you did connect the LEDs to the server board as mentioned above, you will see how they change their on/off state when you press the light icon in the smartphone or the button in the client board. Task 5.1 The client sends, after pressing the button, the message of type SET to all the nodes of the network. Modify it so that it is only sent to the nodes that belong to its group. Try to subscribe/unsubscribe a model from the group, and you will see how it no longer receives the status change request messages. Deliver the modified code. Example for the SENSOR MODEL In this part of the assignment, we implement a sensor model client that is also a provisioner, and a configurable sensor model server. We will work with the code in examples/bluetooth/esp_ble_mesh/ble_mesh_sensor_model . The Sensor Server model is a model that allows exposing series of sensorization data. The Sensor Client model is used to consume sensorization values ( Sensor states ) exposed by the server. These models are made up of the following parts: Status Sensor Descriptor . It describes the sensor data, and is immutable throughout its life. Status Sensor Setting . Controls the sensor parameters. For example, it could indicate its sensitivity, that could be remotely adjusted to prevent a motion sensor from tripping on small movements. Status Sensor Cadence . Controls the cadence of sensing. Status Sensor Data . It contains the sensed values. It is actually represented by one or more Property ID - Value pairs. Status Sensor Series Column . Only used if each of the values is considered as belonging to a data series. In the client example, the device is both a provisioner and a client. Once the server device is provisioned and configured, users can press the button on the board to send requests to the server that, successively, will return the next status of the sensor in order ( Descriptor , Setting , Cadence , ...). In the server example, the non-provisioned device implements a Sensor Server model. The server supports two state instances: the first ( Property ID 0x0056 ) would represent Indoor temperature; the second ( Property ID 0x005B ) would represent the Outdoor temperature. All data, in these examples, is pre-initialized. Running the example First, start the client/provider node and monitor its output. Then stat the server node, you will see that it is provisioned by your client, granting it a unicast address. Write it down. The general operation of the system is: Device A runs the client example, and device B runs the server example. A acts as a provider. After receiving a request from B, he provisions it and stores his address. You will see the MAC BLE (UUID) of B in the provisioning process from A. In A, each press of the button will make a request to node B. Successively, these requests will be, in order and for each press: Sensor Descriptor . Sensor Cadence . Sensor Settings . Sensor Data . Sensor Series . Task Study the client and server code, and see to which node is the client sending the requests, what operations are requested on each button press, and what data the returns the server in each case. Task 5.2 Modify the client and/or server code so that insted of requesting iteratively all the values from the last provided node, it request only the sensor data ( Sensor Data State ) of all the provisioned nodes. So if there are three provisioned nodes, each press would return the sensorization value of one of them, in the provisioning order. You will find the esp_ble_mesh_provisioner_get_node_table_entry function usefull to get a list/table of all connected nodes. As an additional functionality, modify the code so that only those authorized nodes will be automatically provisioned (those that belong to your room, for example). A final optional modification would be to periodically change randombly the sensed data on the server, with a predetermined cadence (remote modification of the cadence remains an advanced exercise). Deliver the resulting code.","title":"Lab 5. Bluetooth Mesh (BLE MESH)"},{"location":"Subjects/NP1/P5/#lab-5-bluetooth-mesh-ble-mesh","text":"","title":"Lab 5. Bluetooth Mesh (BLE MESH)"},{"location":"Subjects/NP1/P5/#goals","text":"Put into practice the concepts studied in theory in relation to BLE MESH, specifically the provisioning and client/server models. Deploy a provisioning infrastructure for an ONOFF GENERIC model SERVER with provisioning from mobile application for remote control of on/off LEDs. Deploy a provisioning infrastructure of a GENERIC SENSOR model provisioned from ESP32.","title":"Goals"},{"location":"Subjects/NP1/P5/#example-for-the-on-off-model","text":"The codes that we will study in this lab assignment are in examples/bluetooth/esp_ble_mesh/ble_mesh_node in the system case OnOff (first part of the assignment) and ble_mesh_sensor_model for the sensor model (second part). In addition, download and install on your smartphone the application nRF Mesh (available both for Android and IOS). You will use this application to provision the devices and interact with the mesh.","title":"Example for the ON-OFF MODEL"},{"location":"Subjects/NP1/P5/#the-on-off-server","text":"This server implements only one element with two models: Configuration Server model : The role of this model is mainly to configure Provisioner device\u2019s AppKey and set up its relay function, TTL size, subscription, etc. Generic OnOff Server model : This model implements the most basic function of turning the lights on and off. The code in ble_mesh_demo_main.c contains the following main application codes, that we can summarize as: * Initialize Bluetooth Controller stack and Host stack (bluedroid) * Initialize BLE Mesh stack * Register the callback function of BLE Mesh provision and BLE Mesh model * Implement and initialize BLE Mesh element * Implement and initialize BLE Mesh Configuration Server model and Generic OnOff Server model * Function as BLE Mesh Configuration Server Model Get Opcode and BLE Mesh Configuration Server Model Set Opcode * Declare and define the RGB LED structure. For better understanding of the code, the following sections provide a detailed analysis the file ble_mesh_demo_main.c .","title":"The ON-OFF server"},{"location":"Subjects/NP1/P5/#1-initializing-and-enabling-ble-mesh","text":"When ESP32 system initialization is completed, app_main is called. The code block below demonstrates the implementation of the functions in app_main . void app_main(void) { int err; ESP_LOGI(TAG, \"Initializing...\"); board_init(); err = bluetooth_init(); if (err) { ESP_LOGE(TAG, \"esp32_bluetooth_init failed (err %d)\", err); return; } /* Initializes the Bluetooth Mesh Subsystem */ err = ble_mesh_init(); if (err) { ESP_LOGE(TAG, \"Bluetooth mesh init failed (err %d)\", err); } } In particular, the code includes: - err = bluetooth_init() : initialization related to the Bluetooth protocol stack (including Controller and Host) - err = ble_mesh_init() : initialization related to BLE Mesh Further, the code for initialization of the BLE Mesh protocol stack is introduced, together with the description of the required actions to initialize BLE Mesh. static esp_err_t ble_mesh_init(void) { int err = 0; memcpy(dev_uuid + 2, esp_bt_dev_get_address(), BLE_MESH_ADDR_LEN); // See comment 1 esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb); esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb); err = esp_ble_mesh_init(&provision, &composition); if (err) { ESP_LOGE(TAG, \"Initializing mesh failed (err %d)\", err); return err; } esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT); ESP_LOGI(TAG, \"BLE Mesh Node initialized\"); board_led_operation(LED_G, LED_ON); return err; } Observet that the code includes the following funtionality: esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb) : registers the provisioning callback function in the BLE Mesh stack. This callback function gets executed during the BLE Mesh network configuration process. It allows the BLE Mesh stack to generate events and notify the application layer about important network configuration processes. This callback function mainly implements the following events: ESP_BLE_MESH_PROVISION_REG_EVT : Generated when the BLE Mesh initialization process is completed after calling the API function esp_ble_mesh_init . It returns the initialization status of the BLE Mesh application. ESP_BLE_MESH_NODE_PROV_LINK_OPEN_EVT : Generated when a Provisioner and an unprovisioned device establish a link. ESP_BLE_MESH_NODE_PROV_LINK_CLOSE_EVT : Generated to notify the application layer that a link has been broken after BLE Mesh bottom-layer protocol sends or receives the message The Link Broken . ESP_BLE_MESH_NODE_PROV_OUTPUT_NUMBER_EVT : Received by the application layer if during the configuration process output_actions is set as ESP_BLE_MESH_DISPLAY_NUMBER , and the target peer input_actions is set as ESP_BLE_MESH_ENTER_NUMBER . ESP_BLE_MESH_NODE_PROV_OUTPUT_STRING_EVT : Received by the application layer if during the configuration process output_actions is set as ESP_BLE_MESH_DISPLAY_STRING , and the target peer input_actions is set as ESP_BLE_MESH_ENTER_STRING . ESP_BLE_MESH_NODE_PROV_INPUT_EVT : Received by the application layer if during the configuration process input_actions is set as anything but ESP_BLE_MESH_NO_INPUT . ESP_BLE_MESH_NODE_PROV_COMPLETE_EVT : Received by the application layer when the provisioning is completed. ESP_BLE_MESH_NODE_PROV_RESET_EVT : Received by the application layer when the network reset is completed. esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb) : registers the model operation callback function. This callback function is used when the target peer operates the model state of the source peer after BLE Mesh has completed network configuration. This callback function mainly implements the following events: ESP_BLE_MESH_MODEL_OPERATION_EVT : Can be triggered by the two scenarios below: Server model receives Get Status or Set Status from Client model. Client model receives Status state from Server model. ESP_BLE_MESH_MODEL_SEND_COMP_EVT : Generated after the Server model sends Status state by calling the API function esp_ble_mesh_server_model_send_msg . ESP_BLE_MESH_MODEL_PUBLISH_COMP_EVT : Generated after the application has completed calling the API esp_ble_mesh_model_publish_msg to publish messages ESP_BLE_MESH_CLIENT_MODEL_SEND_TIMEOUT_EVT : Generated when the Client model calls the API function esp_ble_mesh_client_model_send_msg , but fails to receive ACK from the target peer due to timeout ESP_BLE_MESH_MODEL_PUBLISH_UPDATE_EVT : Generated after the application sets up the publish function to regularly send messages to the target peer. esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT) : enables the Advertising and Scan functions when the BLE Mesh initialization is completed. It makes the devices visible to Provisioners for network provisioning. board_led_operation(LED_G, LED_ON) : initializes the RGB LED. At this point, initialization and enabling of BLE Mesh as a node port is completed, which means a Provisioner can identify devices for network provisioning and data transmission.","title":"1. Initializing and Enabling BLE Mesh"},{"location":"Subjects/NP1/P5/#2-implementation-of-ble-mesh-element-structure","text":"In this section we shows: - Things that have to be done before the initialization of the previous section - How to add an element and a model to ESP BLE Mesh stack - How to choose a different encryption approach - How to declare the features of Proxy, Relay, Low Power and Friend First of all, before calling the API esp_ble_mesh_init to initialize BLE Mesh, an element and a model need to be declared and defined. The code block below shows the declaration of an element structure. /*!< Abstraction that describes a BLE Mesh Element. This structure is associated with bt_mesh_elem in mesh_access.h */ typedef struct { /* Element Address, it is assigned during provisioning. */ uint16_t element_addr; /* Location Descriptor (GATT Bluetooth Namespace Descriptors) */ const uint16_t location; /* Model count */ const uint8_t sig_model_count; const uint8_t vnd_model_count; /* Models */ esp_ble_mesh_model_t *sig_models; esp_ble_mesh_model_t *vnd_models; } esp_ble_mesh_elem_t; The next code block shows the definition of an element structure, build from the ESP_BLE_MESH_ELEMENT macro. static esp_ble_mesh_elem_t elements[] = { ESP_BLE_MESH_ELEMENT(0, root_models, ESP_BLE_MESH_MODEL_NONE), }; Another code block provides the codes needed to implement the macro ESP_BLE_MESH_ELEMENT . #define ESP_BLE_MESH_ELEMENT(_loc, _mods, _vnd_mods) \\ { \\ .location = (_loc), \\ .sig_model_count = ARRAY_SIZE(_mods), \\ .sig_models = (_mods), \\ .vnd_model_count = ARRAY_SIZE(_vnd_mods), \\ .vnd_models = (_vnd_mods), \\ } The variables of the element structure are as follows: addr : stores the element primary address, used by Mesh Stack during the configuration process. It can be ignored for the higher level applications. loc : location descriptor defined by SIG. For this demo, set its value to 0 . model_count : number of SIG models supported in this element. vnd_model_count : number of the Vendor model supported in this element. models : pointer to the SIG Models that have already been defined. vnd_models : pointer to the Vendor Model that has already been defined.","title":"2 Implementation of BLE Mesh Element Structure"},{"location":"Subjects/NP1/P5/#3-implementation-of-ble-mesh-model-structure","text":"The preceding section has introduced the specific ways to implement and define an element by passing specific model pointers to it. This section explains how to implement and define a Model structure, which is shown in the code blocks below. /** Abstraction that describes a Mesh Model instance. * This structure is associated with bt_mesh_model in mesh_access.h */ struct esp_ble_mesh_model { /* Model ID */ union { const uint16_t model_id; struct { uint16_t company_id; uint16_t model_id; } vnd; }; /* The Element to which this Model belongs */ esp_ble_mesh_elem_t *element; /* Model Publication */ esp_ble_mesh_model_pub_t *const pub; /* AppKey List */ uint16_t keys[CONFIG_BLE_MESH_MODEL_KEY_COUNT]; /* Subscription List (group or virtual addresses) */ uint16_t groups[CONFIG_BLE_MESH_MODEL_GROUP_COUNT]; /* Model operation context */ esp_ble_mesh_model_op_t *op; /* Model-specific user data */ void *user_data; }; The block above shows a specific implementation of the model structure. Although this structure has many variables, only the following four ones are used for applications: id and vnd : union variables, defining the SIG Model and the Vendor Model respectively. op : structure with a set of variables for the Model Operation, declaring the opcode that corresponds to Get, Set, or Status State, as well as the minimum value lengths that are supported in this module. pub : structure that needs to be defined if the Model structure supports the Publish function. user_data : optional variable for storing the application layer data. The other structures and variables (keys, group, element) get their values through the BLE Mesh stack during the initialization or configuration stages. You are not required to initialize them. The next code block presents the definition of the model structure, and the root_models[] array. This array is used for indicating the number of the existing model structures. A model is implemented by using a macro. static esp_ble_mesh_model_t root_models[] = { ESP_BLE_MESH_MODEL_CFG_SRV(&config_server), ESP_BLE_MESH_SIG_MODEL(ESP_BLE_MESH_MODEL_ID_GEN_ONOFF_SRV, onoff_op, &onoff_pub, &led_state[0]), }; Different models require different macros. The existing types of models and their respective macros needed for implementation are given in the table below (as we are implementing a Generic OnOff Server model, we use the ESP_BLE_MESH_MODEL_ID_GEN_ONOFF_SRV macro). Model Name Macro Required for its Definition Configuration Server Model ESP_BLE_MESH_MODEL_CFG_SRV Configuration Client Model ESP_BLE_MESH_MODEL_CFG_CLI Generic OnOff Client Model ESP_BLE_MESH_MODEL_GEN_ONOFF_CLI Generic Level Client Model ESP_BLE_MESH_MODEL_GEN_LEVEL_CLI Generic Default Transition Time Client Model ESP_BLE_MESH_MODEL_GEN_DEF_TRANS_TIME_CLI Generic Power OnOff Client Model ESP_BLE_MESH_MODEL_GEN_POWER_ONOFF_CLI Generic Power Level Client Model ESP_BLE_MESH_MODEL_GEN_POWER_LEVEL_CLI Generic Battery Client Model ESP_BLE_MESH_MODEL_GEN_BATTERY_CLI Generic Location Client Model ESP_BLE_MESH_MODEL_GEN_LOCATION_CLI Generic Property Client Model ESP_BLE_MESH_MODEL_GEN_PROPERTY_CLI Light Lightness Client Model ESP_BLE_MESH_MODEL_LIGHT_LIGHTNESS_CLI Light CTL Client Model ESP_BLE_MESH_MODEL_LIGHT_CTL_CLI Light HSL Client Model ESP_BLE_MESH_MODEL_LIGHT_HSL_CLI Sensor Client Model ESP_BLE_MESH_MODEL_SENSOR_CLI Scene Client Model ESP_BLE_MESH_MODEL_SCENE_CLI Another important structure in a model is the esp_ble_mesh_model_op_t *op pointer. This structure points to the operation structure that defines the Model state. Generally, there are two types of models in BLE Mesh: Server Model : Consists of one or multiple states that can exist across different elements Defines the messages sent/received by the model, along with the element's behavior. Example\uff1aOn/Off switch --- Indicates the On/Off status. Client Model : Defines the messages used by the client to request, change or use the relevant state of the server. Example\uff1aOn/Off switch --- Indicates the On or Off message sent by the Client. The following code block shows the declaration of the Model operation structure. /*!< Model operation context. This structure is associated with bt_mesh_model_op in mesh_access.h */ typedef struct { const uint32_t opcode; /* Opcode encoded with the ESP_BLE_MESH_MODEL_OP_* macro */ const size_t min_len; /* Minimum required message length */ esp_ble_mesh_cb_t param_cb; /* The callback is only used for the BLE Mesh stack, not for the app layer. */ } esp_ble_mesh_model_op_t; There are three variables in the declaration of the operation structure: opcode : opcode corresponding to a state. As specified in BLE Mesh, the SIG Model opcode should be 1~2 bytes, and the Vendor Model opcode should be 3 bytes. min_len : min length of the messages received by the state. For example, OnOff Get state is 0 bytes, and OnOff Set State is 2 bytes. param_cb : used for the BLE Mesh protocol only. Applications need to set its value to 0 . The definition for our OnOff Server code is: static esp_ble_mesh_model_op_t onoff_op[] = { { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_GET, 0, 0}, { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET, 2, 0}, { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK, 2, 0}, /* Each model operation struct array must use this terminator * as the end tag of the operation uint. */ ESP_BLE_MESH_MODEL_OP_END, };","title":"3 Implementation of BLE Mesh Model Structure"},{"location":"Subjects/NP1/P5/#the-onoff-client","text":"The design of the client is much easier. In a generic way, it just defines an ON/OFF Client model and waits to be provisioned. Once the provisioning process is completed, every time one of the buttons on the board (RESET) is pressed, it sends a request for a change in the status of the lights to all the nodes in its mesh network. This behaviour is coded in the following functions defined in the board.c file: static void button_tap_cb(void* arg) { ESP_LOGI(TAG, \"tap cb (%s)\", (char *)arg); example_ble_mesh_send_gen_onoff_set(); } static void board_button_init(void) { button_handle_t btn_handle = iot_button_create(BUTTON_IO_NUM, BUTTON_ACTIVE_LEVEL); if (btn_handle) { iot_button_set_evt_cb(btn_handle, BUTTON_CB_RELEASE, button_tap_cb, \"RELEASE\"); } } void board_init(void) { board_led_init(); board_button_init(); } The invoked function, example_ble_mesh_send_gen_onoff_set , sends a SET operation to all network members: void example_ble_mesh_send_gen_onoff_set(void) { esp_ble_mesh_generic_client_set_state_t set = {0}; esp_ble_mesh_client_common_param_t common = {0}; esp_err_t err = ESP_OK; common.opcode = ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK; common.model = onoff_client.model; common.ctx.net_idx = store.net_idx; common.ctx.app_idx = store.app_idx; common.ctx.addr = 0xFFFF; /* to all nodes */ common.ctx.send_ttl = 3; common.ctx.send_rel = false; common.msg_timeout = 0; /* 0 indicates that timeout value from menuconfig will be used */ common.msg_role = ROLE_NODE; set.onoff_set.op_en = false; set.onoff_set.onoff = store.onoff; set.onoff_set.tid = store.tid++; err = esp_ble_mesh_generic_client_set_state(&common, &set); if (err) { ESP_LOGE(TAG, \"Send Generic OnOff Set Unack failed\"); return; } store.onoff = !store.onoff; mesh_example_info_store(); /* Store proper mesh example info */ } Observe that the destination address is for all nodes in the network ( common.ctx.addr = 0xFFFF; ).","title":"The OnOff Client"},{"location":"Subjects/NP1/P5/#provisioning-and-control-from-a-mobile-application","text":"You will use the two ESP nodes you have, one programmed as an OnOff Server and the other programmed as an OnOff Client. If you have three LEDs available, you can place the server node on a breadboard and connect the anodes of the LEDs to the pins where the server node expects the lights to be connected (you can find those in the board.h file, mainly the pins 25, 26 and 27). It is convenient that you also place in series a current limmitng resistor, a 220 ohm resistor should be fine. You can run the two nodes and monitor its output (use the idf.py command). Once both are up and running you will use the nRF Mesh app on your smartphone to complete the provisioning of both nodes, creating a ble mesh for thme. To complete the provisioning you have to proceed as follows: STEP 1 : the initial screen will show you the nodes that are already provisioned (initially none). STEP 2 : you will click on ADD NODE and provision (one by one) your two nodes: STEP 3 : you have to generate the network information for the new node ( identify it), pressing IDENTIFY : STEP 4 : once the network information has been generated, you can provision the node (pressing PROVISION ): STEP 5 : if everything went well, a success message like the following one will be shown: STEP 6 : after repeating this step with the two nodes in our group, you will see a screen like the following. Observe and write down the unicast addresses of each node. The node with one item is the OnOff Client; the node with three elements is the OnOff Server. Next, you will generate a group of nodes. This will allow you to subscribe the models to it, and publish messages that will be broadcasted to all models in the group. STEP 7 : Create a new group by pressing the + button. Give it the name and address you want, for example, Living Room , 0xC000 . If everything went well, you will see a single valid group with no nodes associated/subscribed to it. STEP 8 : Next, you will subscribe each Generic On Off Server and Generic On Off Client models to the group you just created. You have to do it node by node, first by clicking on the concrete model: And then associate an application key ( BIND KEY ) and subscribe ( SUBSCRIBE ) to the desired group: Now, if all went well, if you go to the group description tab, you will see an icon with a picture for the lights, and another icon for the client (a swithc). At this point, if you are monitoring the output of all ESP32s, you will see that the state of the LED changes at the request of the application (pressing the light icon). In addition, you will see that it also changes if you press the corresponding button of the switch ( RESET ) on the board. If you did connect the LEDs to the server board as mentioned above, you will see how they change their on/off state when you press the light icon in the smartphone or the button in the client board. Task 5.1 The client sends, after pressing the button, the message of type SET to all the nodes of the network. Modify it so that it is only sent to the nodes that belong to its group. Try to subscribe/unsubscribe a model from the group, and you will see how it no longer receives the status change request messages. Deliver the modified code.","title":"Provisioning and control from a mobile application"},{"location":"Subjects/NP1/P5/#example-for-the-sensor-model","text":"In this part of the assignment, we implement a sensor model client that is also a provisioner, and a configurable sensor model server. We will work with the code in examples/bluetooth/esp_ble_mesh/ble_mesh_sensor_model . The Sensor Server model is a model that allows exposing series of sensorization data. The Sensor Client model is used to consume sensorization values ( Sensor states ) exposed by the server. These models are made up of the following parts: Status Sensor Descriptor . It describes the sensor data, and is immutable throughout its life. Status Sensor Setting . Controls the sensor parameters. For example, it could indicate its sensitivity, that could be remotely adjusted to prevent a motion sensor from tripping on small movements. Status Sensor Cadence . Controls the cadence of sensing. Status Sensor Data . It contains the sensed values. It is actually represented by one or more Property ID - Value pairs. Status Sensor Series Column . Only used if each of the values is considered as belonging to a data series. In the client example, the device is both a provisioner and a client. Once the server device is provisioned and configured, users can press the button on the board to send requests to the server that, successively, will return the next status of the sensor in order ( Descriptor , Setting , Cadence , ...). In the server example, the non-provisioned device implements a Sensor Server model. The server supports two state instances: the first ( Property ID 0x0056 ) would represent Indoor temperature; the second ( Property ID 0x005B ) would represent the Outdoor temperature. All data, in these examples, is pre-initialized.","title":"Example for the SENSOR MODEL"},{"location":"Subjects/NP1/P5/#running-the-example","text":"First, start the client/provider node and monitor its output. Then stat the server node, you will see that it is provisioned by your client, granting it a unicast address. Write it down. The general operation of the system is: Device A runs the client example, and device B runs the server example. A acts as a provider. After receiving a request from B, he provisions it and stores his address. You will see the MAC BLE (UUID) of B in the provisioning process from A. In A, each press of the button will make a request to node B. Successively, these requests will be, in order and for each press: Sensor Descriptor . Sensor Cadence . Sensor Settings . Sensor Data . Sensor Series . Task Study the client and server code, and see to which node is the client sending the requests, what operations are requested on each button press, and what data the returns the server in each case. Task 5.2 Modify the client and/or server code so that insted of requesting iteratively all the values from the last provided node, it request only the sensor data ( Sensor Data State ) of all the provisioned nodes. So if there are three provisioned nodes, each press would return the sensorization value of one of them, in the provisioning order. You will find the esp_ble_mesh_provisioner_get_node_table_entry function usefull to get a list/table of all connected nodes. As an additional functionality, modify the code so that only those authorized nodes will be automatically provisioned (those that belong to your room, for example). A final optional modification would be to periodically change randombly the sensed data on the server, with a predetermined cadence (remote modification of the cadence remains an advanced exercise). Deliver the resulting code.","title":"Running the example"},{"location":"Subjects/NP1/P6/","text":"Lab 6. 6LowPAN and RPL Introduction and goals Edge routers are routers that can be found on the edge of a network, routing the traffic of that network to a second external network. Its function, in short, is to connect one network to another. In this lab, we will see how to build a simulation using an edge router in Contiki. More specifically, we will see how a Contiki edge router can be used to route traffic between an RPL network (a Contiki sensor network with routing protocol RPL over IPv6) and an external IPv4 network, following the diagram below: The goal of the lab is to provide an overview of how to deploy both an RPL network with Contiki in the Cooja simulator, as well as making it interact with a second real external network using the tool tunslip . Installation of software requirements The basic installation of Contiki (in its version 2.7) is in the /home/ubuntu/contiki directory of your virtual machine. Before you begin, you will need to install some support software: sudo apt install -y openjdk-8-jdk openjdk-8-jre Next, be sure to select Java version 8 for a correct functioning of the Cooja compilation process, run the following command and make sure that the option /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java is selected: ubuntu@ubuntu2004:~/contiki/tools/cooja$ sudo update-alternatives --config java Finally, you will need to install the compiler that will allow you to generate the images for the simulated nodes: sudo apt install gcc-msp430 gdb-msp430 Contiki Code In the development of the lab assignment, we will use the following files, all located in the examples/ipv6/rpl-border-router subdirectory of the Contiki installation path: border_router.c : code that we will use for the edge router. udp-client.c or udp_server.c (in the examples/ipv6/rpl-udp directory): that will we will use for the nodes in our RPL network (its functionality is not relevant for the moment). slip-bridge.c : contains the callback functions to process a SLIP connection request. httpd-simple.c : it contains a simple web server that will allow us check the routing tables of the edge router. Nodes that implement the udp-client.c or border_router.c code will form a DAG, with the edge router configured as root. The edge router will receive the network prefix via an SLIP connection ( Serial Line Interface Protocol ) and will communicate it to the rest of the nodes of the RPL network so that they can build their corresponding global IPv6 addresses. The following code snippets, taken from the edge router, show the point where it waits for the network prefix. Once received, the edge router is configured as the root of the DAG and sends the prefix to all other nodes of the network: /* Request prefix until it has been received */ while(!prefix_set) { etimer_set(&et, CLOCK_SECOND); request_prefix(); PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et)); } dag = rpl_set_root(RPL_DEFAULT_INSTANCE,(uip_ip6addr_t *)dag_id); if(dag != NULL) { rpl_set_prefix(dag, &prefix, 64); PRINTF(\"created a new RPL dag\\n\"); } By default, the edge router hosts a simple web page that will allows us to check the status of its routing table. This page will be displayed by introducing in a web browser of the virtual machine the IPv6 address of the edge router. The use or not of this page is controlled with the macro WEBSERVER in the http-simple.c file: PROCESS(border_router_process, \"Border router process\"); #if WEBSERVER==0 /* No webserver */ AUTOSTART_PROCESSES(&border_router_process); #elif WEBSERVER>1 /* Use an external webserver application */ #include \"webserver-nogui.h\" AUTOSTART_PROCESSES(&border_router_process,&webserver_nogui_process); Code compilation The code for the edge router can be found in the path examples/ipv6/rpl-border-router . In a terminal, use the following command to perform the compilation: cd examples/ipv6/rpl-border-router make TARGET=z1 Once executed, a file called border-router.z1 will be created, which will be used to program the mote (simulated device) for the edge router in the cooja simulator. To demonstrate the functionality of the edge router, we will create a network of nodes with the edge router as root. For the rest of the nodes, we will use UDP client code, implemented in the file udp-client.c . Prepare images for these motes as follows: cd examples/ipv6/rpl-udp make TARGET=z1 As before, you will obtain a file named udp-client.z1 , that will that shall be used to program the rest of the motes of the DAG. Simulation with Cooja After compiling the images, it is time to configure the complete simulation in Cooja. Start the simulator using the following command: cd tools/cooja ant run Once cooja starts follow these steps to create a new simulation: Select the File->New Simulation option. Then the UDGM option and enter the name of the simulation. Press Create . In the Motes menu, select Add New Motes->Create new motes and select Z1 as the type of mote. Find the location of the image for the border router ( examples/ipv6/rpl-border-router ) and select the file rpl-border-router.z1 . Click on Create and add one mote of this type. Repeat steps 2 and 3, but this time with the UDP client image that you created earlier. Add four or five motes of this type (selecting four instead one in step 3) and manually distribute them throughout the simulation, so that not all of them can be directly reached from the edge router. Select the View menu options as shown in the figure. This will allow you to easily create your topology (you can temporarily add the IP address as well, although it might overload the figure with too much information): Next, create a bridge between the simulated RPL network in Cooja and the local machine by This can be done by selecting Tools and Serial Socket (SERVER) on the edge router mote (identify it with its numeric value). If every thing went well you will get a message like the one in the figure below (note that the message indicates Listening on port 60001 ): Then start the simulation ( Start button). The tunslip tool As we have said, an edge router acts as a link to connect a network to another network. In this example, the edge router is used to route data between the RPL network and an external network. So far, we have only created the RPL network, so we need to simulate a scenario where this RPL network connects to an external network. To do this, we use the tunslip utility provided with Contiki. It will create a bridge between the RPL network and the local machine. The code tunslip6.c is located in the tools directory of the contiki installation path, and it can be compiled with the following command: make tunslip6 Then we can establish a connection between the RPL network and the local machine by running the following command: sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 If the execution was correct, you will see an output in the terminal similar to this one: ubuntu@ubuntu2004:~/contiki/tools$ sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 slip connected to ``127.0.0.1:60001'' opened tun device ``/dev/tun0'' ifconfig tun0 inet `hostname` mtu 1500 up ifconfig tun0 add aaaa::1/64 ifconfig tun0 add fe80::0:0:0:1/64 ifconfig tun0 tun0: flags=4305<UP,POINTOPOINT,RUNNING,NOARP,MULTICAST> mtu 1500 inet 127.0.1.1 netmask 255.255.255.255 destination 127.0.1.1 inet6 aaaa::1 prefixlen 64 scopeid 0x0<global> inet6 fe80::1 prefixlen 64 scopeid 0x20<link> inet6 fe80::ace4:dadf:8e12:be05 prefixlen 64 scopeid 0x20<link> unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 *** Address:aaaa::1 => aaaa:0000:0000:0000 Got configuration message of type P Setting prefix aaaa:: Server IPv6 addresses: aaaa::c30c:0:0:1 fe80::c30c:0:0:1 The program has created a bridge interface tun0 with IPv4 127.0.1.1, and has sent, via serial, a configuration message to the edge router indicating the desired IPv6 prefix for the RPL network nodes ( aaaa ). The last two lines are part of the output of the edge router, and indicate their IPv6 addresses after the reception of the prefix. Note that in the Cooja window a message with the text Client connected: /127.0.0.1 has appeared. Simulation analysis It is possible to verify the address of the edge router through a command ping from your virtual machine: ubuntu@ubuntu2004:~/contiki/tools$ ping aaaa::c30c:0:0:1 PING aaaa::c30c:0:0:1(aaaa::c30c:0:0:1) 56 data bytes 64 bytes from aaaa::c30c:0:0:1: icmp_seq=1 ttl=64 time=21.5 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=2 ttl=64 time=7.44 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=3 ttl=64 time=8.57 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=4 ttl=64 time=62.7 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=5 ttl=64 time=15.2 ms --- aaaa::c30c:0:0:1 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 4015ms rtt min/avg/max/mdev = 7.442/23.066/62.661/20.427 ms So as with any other node in the RPL network, for instance with node 4: ubuntu@ubuntu2004:~/contiki/tools$ ping aaaa::c30c:0:0:4 PING aaaa::c30c:0:0:4(aaaa::c30c:0:0:4) 56 data bytes 64 bytes from aaaa::c30c:0:0:4: icmp_seq=1 ttl=62 time=116 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=2 ttl=62 time=106 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=3 ttl=62 time=108 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=4 ttl=62 time=111 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=5 ttl=62 time=79.0 ms ^C --- aaaa::c30c:0:0:4 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 4016ms rtt min/avg/max/mdev = 79.002/104.028/115.794/12.937 ms The address of each node can be obtained by filtering the log screen based on the destination node (mote) ID. In addition you can open a web browser on the virtual machine and browse the IP address of the edge router to observe its routing table: Task 6.1 Follow the steps detailed above to create an RPL network with a reduced number of nodes (between 5 and 10), connecting it to your local network. Make sure that not all nodes fall in range of the edge router, and begin your simulation. Study the RPL traffic generated while the DAG is being constructed, and check connectivity with all of the nodes via ping6 . Move one mote that is in the reach of the edge router out of its reach. With ping6 active on that mote, observe how the mote converges to the DODAG again (selecting a new upstrem node). You can also move other motes or create new ones, and study, through the web interface of the edge router, the time to establish new routes. Finally, you can anaylaze the RPL trafic with wireshark by exporting a PCAP file. You have to enable them opening the radio messages tool from the Tools menu and selecting Analyzer->6LoWPAN Analyzer with PCAP. Then you can export the PCAP file with the radio mesagges tool and import it in whireshark, where you can filter the mesagges by protocol or address as usual. A convenient step here is to eliminate duplicated packages from the PCAP file before opening it in whireshark. That can be done with the editcap command: editcap -d original_capture_file.cap output_capture_file.cap You can then easily trace the routes followed by the messages sent from each node and generate a figure that represent the topology of the network. The student should prepare a small pdf report documenting all these analysis and observations, showing all the experiments conducted on the network.","title":"Lab 6. 6LowPAN and RPL"},{"location":"Subjects/NP1/P6/#lab-6-6lowpan-and-rpl","text":"","title":"Lab 6. 6LowPAN and RPL"},{"location":"Subjects/NP1/P6/#introduction-and-goals","text":"Edge routers are routers that can be found on the edge of a network, routing the traffic of that network to a second external network. Its function, in short, is to connect one network to another. In this lab, we will see how to build a simulation using an edge router in Contiki. More specifically, we will see how a Contiki edge router can be used to route traffic between an RPL network (a Contiki sensor network with routing protocol RPL over IPv6) and an external IPv4 network, following the diagram below: The goal of the lab is to provide an overview of how to deploy both an RPL network with Contiki in the Cooja simulator, as well as making it interact with a second real external network using the tool tunslip .","title":"Introduction and goals"},{"location":"Subjects/NP1/P6/#installation-of-software-requirements","text":"The basic installation of Contiki (in its version 2.7) is in the /home/ubuntu/contiki directory of your virtual machine. Before you begin, you will need to install some support software: sudo apt install -y openjdk-8-jdk openjdk-8-jre Next, be sure to select Java version 8 for a correct functioning of the Cooja compilation process, run the following command and make sure that the option /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java is selected: ubuntu@ubuntu2004:~/contiki/tools/cooja$ sudo update-alternatives --config java Finally, you will need to install the compiler that will allow you to generate the images for the simulated nodes: sudo apt install gcc-msp430 gdb-msp430","title":"Installation of software requirements"},{"location":"Subjects/NP1/P6/#contiki-code","text":"In the development of the lab assignment, we will use the following files, all located in the examples/ipv6/rpl-border-router subdirectory of the Contiki installation path: border_router.c : code that we will use for the edge router. udp-client.c or udp_server.c (in the examples/ipv6/rpl-udp directory): that will we will use for the nodes in our RPL network (its functionality is not relevant for the moment). slip-bridge.c : contains the callback functions to process a SLIP connection request. httpd-simple.c : it contains a simple web server that will allow us check the routing tables of the edge router. Nodes that implement the udp-client.c or border_router.c code will form a DAG, with the edge router configured as root. The edge router will receive the network prefix via an SLIP connection ( Serial Line Interface Protocol ) and will communicate it to the rest of the nodes of the RPL network so that they can build their corresponding global IPv6 addresses. The following code snippets, taken from the edge router, show the point where it waits for the network prefix. Once received, the edge router is configured as the root of the DAG and sends the prefix to all other nodes of the network: /* Request prefix until it has been received */ while(!prefix_set) { etimer_set(&et, CLOCK_SECOND); request_prefix(); PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et)); } dag = rpl_set_root(RPL_DEFAULT_INSTANCE,(uip_ip6addr_t *)dag_id); if(dag != NULL) { rpl_set_prefix(dag, &prefix, 64); PRINTF(\"created a new RPL dag\\n\"); } By default, the edge router hosts a simple web page that will allows us to check the status of its routing table. This page will be displayed by introducing in a web browser of the virtual machine the IPv6 address of the edge router. The use or not of this page is controlled with the macro WEBSERVER in the http-simple.c file: PROCESS(border_router_process, \"Border router process\"); #if WEBSERVER==0 /* No webserver */ AUTOSTART_PROCESSES(&border_router_process); #elif WEBSERVER>1 /* Use an external webserver application */ #include \"webserver-nogui.h\" AUTOSTART_PROCESSES(&border_router_process,&webserver_nogui_process);","title":"Contiki Code"},{"location":"Subjects/NP1/P6/#code-compilation","text":"The code for the edge router can be found in the path examples/ipv6/rpl-border-router . In a terminal, use the following command to perform the compilation: cd examples/ipv6/rpl-border-router make TARGET=z1 Once executed, a file called border-router.z1 will be created, which will be used to program the mote (simulated device) for the edge router in the cooja simulator. To demonstrate the functionality of the edge router, we will create a network of nodes with the edge router as root. For the rest of the nodes, we will use UDP client code, implemented in the file udp-client.c . Prepare images for these motes as follows: cd examples/ipv6/rpl-udp make TARGET=z1 As before, you will obtain a file named udp-client.z1 , that will that shall be used to program the rest of the motes of the DAG.","title":"Code compilation"},{"location":"Subjects/NP1/P6/#simulation-with-cooja","text":"After compiling the images, it is time to configure the complete simulation in Cooja. Start the simulator using the following command: cd tools/cooja ant run Once cooja starts follow these steps to create a new simulation: Select the File->New Simulation option. Then the UDGM option and enter the name of the simulation. Press Create . In the Motes menu, select Add New Motes->Create new motes and select Z1 as the type of mote. Find the location of the image for the border router ( examples/ipv6/rpl-border-router ) and select the file rpl-border-router.z1 . Click on Create and add one mote of this type. Repeat steps 2 and 3, but this time with the UDP client image that you created earlier. Add four or five motes of this type (selecting four instead one in step 3) and manually distribute them throughout the simulation, so that not all of them can be directly reached from the edge router. Select the View menu options as shown in the figure. This will allow you to easily create your topology (you can temporarily add the IP address as well, although it might overload the figure with too much information): Next, create a bridge between the simulated RPL network in Cooja and the local machine by This can be done by selecting Tools and Serial Socket (SERVER) on the edge router mote (identify it with its numeric value). If every thing went well you will get a message like the one in the figure below (note that the message indicates Listening on port 60001 ): Then start the simulation ( Start button).","title":"Simulation with Cooja"},{"location":"Subjects/NP1/P6/#the-tunslip-tool","text":"As we have said, an edge router acts as a link to connect a network to another network. In this example, the edge router is used to route data between the RPL network and an external network. So far, we have only created the RPL network, so we need to simulate a scenario where this RPL network connects to an external network. To do this, we use the tunslip utility provided with Contiki. It will create a bridge between the RPL network and the local machine. The code tunslip6.c is located in the tools directory of the contiki installation path, and it can be compiled with the following command: make tunslip6 Then we can establish a connection between the RPL network and the local machine by running the following command: sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 If the execution was correct, you will see an output in the terminal similar to this one: ubuntu@ubuntu2004:~/contiki/tools$ sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 slip connected to ``127.0.0.1:60001'' opened tun device ``/dev/tun0'' ifconfig tun0 inet `hostname` mtu 1500 up ifconfig tun0 add aaaa::1/64 ifconfig tun0 add fe80::0:0:0:1/64 ifconfig tun0 tun0: flags=4305<UP,POINTOPOINT,RUNNING,NOARP,MULTICAST> mtu 1500 inet 127.0.1.1 netmask 255.255.255.255 destination 127.0.1.1 inet6 aaaa::1 prefixlen 64 scopeid 0x0<global> inet6 fe80::1 prefixlen 64 scopeid 0x20<link> inet6 fe80::ace4:dadf:8e12:be05 prefixlen 64 scopeid 0x20<link> unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 *** Address:aaaa::1 => aaaa:0000:0000:0000 Got configuration message of type P Setting prefix aaaa:: Server IPv6 addresses: aaaa::c30c:0:0:1 fe80::c30c:0:0:1 The program has created a bridge interface tun0 with IPv4 127.0.1.1, and has sent, via serial, a configuration message to the edge router indicating the desired IPv6 prefix for the RPL network nodes ( aaaa ). The last two lines are part of the output of the edge router, and indicate their IPv6 addresses after the reception of the prefix. Note that in the Cooja window a message with the text Client connected: /127.0.0.1 has appeared.","title":"The tunslip tool"},{"location":"Subjects/NP1/P6/#simulation-analysis","text":"It is possible to verify the address of the edge router through a command ping from your virtual machine: ubuntu@ubuntu2004:~/contiki/tools$ ping aaaa::c30c:0:0:1 PING aaaa::c30c:0:0:1(aaaa::c30c:0:0:1) 56 data bytes 64 bytes from aaaa::c30c:0:0:1: icmp_seq=1 ttl=64 time=21.5 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=2 ttl=64 time=7.44 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=3 ttl=64 time=8.57 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=4 ttl=64 time=62.7 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=5 ttl=64 time=15.2 ms --- aaaa::c30c:0:0:1 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 4015ms rtt min/avg/max/mdev = 7.442/23.066/62.661/20.427 ms So as with any other node in the RPL network, for instance with node 4: ubuntu@ubuntu2004:~/contiki/tools$ ping aaaa::c30c:0:0:4 PING aaaa::c30c:0:0:4(aaaa::c30c:0:0:4) 56 data bytes 64 bytes from aaaa::c30c:0:0:4: icmp_seq=1 ttl=62 time=116 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=2 ttl=62 time=106 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=3 ttl=62 time=108 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=4 ttl=62 time=111 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=5 ttl=62 time=79.0 ms ^C --- aaaa::c30c:0:0:4 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 4016ms rtt min/avg/max/mdev = 79.002/104.028/115.794/12.937 ms The address of each node can be obtained by filtering the log screen based on the destination node (mote) ID. In addition you can open a web browser on the virtual machine and browse the IP address of the edge router to observe its routing table: Task 6.1 Follow the steps detailed above to create an RPL network with a reduced number of nodes (between 5 and 10), connecting it to your local network. Make sure that not all nodes fall in range of the edge router, and begin your simulation. Study the RPL traffic generated while the DAG is being constructed, and check connectivity with all of the nodes via ping6 . Move one mote that is in the reach of the edge router out of its reach. With ping6 active on that mote, observe how the mote converges to the DODAG again (selecting a new upstrem node). You can also move other motes or create new ones, and study, through the web interface of the edge router, the time to establish new routes. Finally, you can anaylaze the RPL trafic with wireshark by exporting a PCAP file. You have to enable them opening the radio messages tool from the Tools menu and selecting Analyzer->6LoWPAN Analyzer with PCAP. Then you can export the PCAP file with the radio mesagges tool and import it in whireshark, where you can filter the mesagges by protocol or address as usual. A convenient step here is to eliminate duplicated packages from the PCAP file before opening it in whireshark. That can be done with the editcap command: editcap -d original_capture_file.cap output_capture_file.cap You can then easily trace the routes followed by the messages sent from each node and generate a figure that represent the topology of the network. The student should prepare a small pdf report documenting all these analysis and observations, showing all the experiments conducted on the network.","title":"Simulation analysis"},{"location":"Subjects/NP2/","text":"Networks and Protocols 2 General information This subject will cover different topics about application-level communication APIs, standard and interfaces, with special emphasis on Internet of Things inter-communication. Specifically, we will cover both Linux and ESP-IDF programming on the ESP32, to fulfill the following specific goals: Get a global overview of the necessities and particularities of IoT from the application communication perspective. Advocate for open standards for IoT communication. Introduce the concept of Smart Object, and study how it can be ported to different APIs and languages. Introduce different techniques for information representation. Study a number of IoT frameworks and stream processing platforms. Subject program and evaluation methodology Program and evaluation Professor Francisco Igual (figual@ucm.es) Work paper work assignment Here you can find description about this individual assignment Final programming project (teams of 2 people), shared with NP1 Once ready you will find here the details on the final project for this course. Work groups (for regular lab assignments) Here you can find the current work groups Quizzes For all quizzes will you are requested to use your e-mail address as name. All of them can be accessed directly from this link . Schedule Day/Month Topic Lab instructions Deliverable 18/01 Basic Concepts (I) 20/01 Basic Concepts (II) Assignment 1 25/01 Smart Objects , Lab 1. TCP/UDP sockets (Linux) Lab 1. instructions 27/01 Lab 1. TCP/UDP sockets (Linux) Lab 1. instructions 01/02 Week off (Chinese new year) 03/02 Week off (Chinese new year) 08/02 Transport layer , Lab 1. instructions 10/02 Lab 1. TCP/UDP sockets (Linux) Lab 1. instructions 15/02 Websockets , Lab 2. TCP/UDP sockets (ESP32) Lab 2. instructions All tasks from Lab1. 17/02 REST servers. Information representation , Lab2. TCP/UDP sockets (ESP32) Lab 2. instructions Quiz 22/02 Lab 3. Websockets Lab 3. instructions 24/02 MQTT Quiz 01/03 Lab 4. MQTT Lab 4. instructions 03/03 Lab 4. MQTT Lab 4. instructions 08/03 CoAP and LWM2M Quiz 10/03 Lab 5. CoAP Lab 5. instructions 15/03 Lab 5. CoAP Lab 5. instructions 17/03 Lab 6. Node-RED Lab 6. instructions 22/03 IoT Frameworks Quiz 24/03 Work on Final Project 29/03 Work on Final Project 31/04 Work on Final Project 05/04 Work on Final Project","title":"NP2"},{"location":"Subjects/NP2/#networks-and-protocols-2","text":"","title":"Networks and Protocols 2"},{"location":"Subjects/NP2/#general-information","text":"This subject will cover different topics about application-level communication APIs, standard and interfaces, with special emphasis on Internet of Things inter-communication. Specifically, we will cover both Linux and ESP-IDF programming on the ESP32, to fulfill the following specific goals: Get a global overview of the necessities and particularities of IoT from the application communication perspective. Advocate for open standards for IoT communication. Introduce the concept of Smart Object, and study how it can be ported to different APIs and languages. Introduce different techniques for information representation. Study a number of IoT frameworks and stream processing platforms.","title":"General information"},{"location":"Subjects/NP2/#subject-program-and-evaluation-methodology","text":"Program and evaluation","title":"Subject program and evaluation methodology"},{"location":"Subjects/NP2/#professor","text":"Francisco Igual (figual@ucm.es)","title":"Professor"},{"location":"Subjects/NP2/#work-paper-work-assignment","text":"Here you can find description about this individual assignment","title":"Work paper work assignment"},{"location":"Subjects/NP2/#final-programming-project-teams-of-2-people-shared-with-np1","text":"Once ready you will find here the details on the final project for this course.","title":"Final programming project (teams of 2 people), shared with NP1"},{"location":"Subjects/NP2/#work-groups-for-regular-lab-assignments","text":"Here you can find the current work groups","title":"Work groups (for regular lab assignments)"},{"location":"Subjects/NP2/#quizzes","text":"For all quizzes will you are requested to use your e-mail address as name. All of them can be accessed directly from this link .","title":"Quizzes"},{"location":"Subjects/NP2/#schedule","text":"Day/Month Topic Lab instructions Deliverable 18/01 Basic Concepts (I) 20/01 Basic Concepts (II) Assignment 1 25/01 Smart Objects , Lab 1. TCP/UDP sockets (Linux) Lab 1. instructions 27/01 Lab 1. TCP/UDP sockets (Linux) Lab 1. instructions 01/02 Week off (Chinese new year) 03/02 Week off (Chinese new year) 08/02 Transport layer , Lab 1. instructions 10/02 Lab 1. TCP/UDP sockets (Linux) Lab 1. instructions 15/02 Websockets , Lab 2. TCP/UDP sockets (ESP32) Lab 2. instructions All tasks from Lab1. 17/02 REST servers. Information representation , Lab2. TCP/UDP sockets (ESP32) Lab 2. instructions Quiz 22/02 Lab 3. Websockets Lab 3. instructions 24/02 MQTT Quiz 01/03 Lab 4. MQTT Lab 4. instructions 03/03 Lab 4. MQTT Lab 4. instructions 08/03 CoAP and LWM2M Quiz 10/03 Lab 5. CoAP Lab 5. instructions 15/03 Lab 5. CoAP Lab 5. instructions 17/03 Lab 6. Node-RED Lab 6. instructions 22/03 IoT Frameworks Quiz 24/03 Work on Final Project 29/03 Work on Final Project 31/04 Work on Final Project 05/04 Work on Final Project","title":"Schedule"},{"location":"Subjects/NP2/FinalProject/","text":"Networks and Protocols (NP1 + NP2) Final Programming Project As a last exercise for the two subjects (NP1 and NP2) you will work in teams of 2 people on a project that shows what you have learned from these topics. You will develop (program) a system to monitor the amount of people in a room, by detecting their smartphones, uploading the data to an external server for analysis and visualization. In the following sections we describe what should be covered for the two subjects. Requirements for NP1 Your system should manage a sensor network, formed by your ESP32 nodes. We assume that you could have at least one node per room and that each room has a WiFi access point reachable. In this context: Your nodes should be able to connect to the AP using WiFi, with WPA2-PSK security. Your nodes should provide a provissioning option, so that you can configure the wifi SSID to connect to. You can use a softAP or a BLE provisioning method, that is up to you. Your nodes should use BLE to compute the number of other BLE devices in its range (an estimation of the number of people in its range), using the RSSI to compute the distance to the node (the student should research for methods to compute the distance). Alternatively the student can opt for using a different technology of his choice to estimate the number of people in the room. The node should be configured through the menuconfig system, to establish its parameters: Sampling period. Server where the samples should be sent to (see requirements for NP2). Range of valid distances. etc. Optional Parts for NP1 Optionally you can extend the project incorporating some extra features like the following (these are only ideas, you can also propose some others): Consider an scenario with larger rooms, in which one node is not enough and the wifi AP is not reachable on all points. In this scenario you can use the ESP's wifi-mesh technology to build a mesh of nodes in the room. Study the Over The Air (OTA) features of ESP and prepare your nodes to receive OTA updates from an external server. Together with NP2 you can consider to configure the nodes to trigger the OTA update through MQTT (or any other application protocol you are using). Add a GATT server that allows the node parameters to be configured with a BLE client. Requirements for NP2 The developed system will periodically publish the calculated data for the population of BLE devices in the room, sending it to an external server for further storage and analysis. Specifically, the minimum requirements related with NP2 include: You will select an application-level protocol among those studied in NP2 (or, alternatively, other similar protocols of your interest) and use it for data publishing. Servers/brokers to which data will be sent will be configured via menuconfig , together with the sending period and any other configurable parameter considered useful. You will select and use one of the two data representation methods studied in the course (JSON or CBOR). Data will be gathered by Node-RED and submitted to two different destinations: A dashboard of your election (e.g. Node-RED, Grafana, ...). A database (e.g. MongoDB), where it will be stored together with a timestamp. Optional Parts for NP2 Optionally you can extend the project incorporating some extra features like the following (these are only ideas, you can also propose some others): Use encryption at all levels of the communication (e.g. MQTT). Develop an alarm system that triggers under certain conditions (e.g. when the amount of BLE devices is out of a pre-established range), and sends a notification to the user using external services (e.g. SMS, e-mail, Telegram, ...). Implement bi-directional communication, with the possibility of externally modifying the behavior of the ESP32 (e.g. modifying sampling or sending period).","title":"Networks and Protocols (NP1 + NP2) Final Programming Project"},{"location":"Subjects/NP2/FinalProject/#networks-and-protocols-np1-np2-final-programming-project","text":"As a last exercise for the two subjects (NP1 and NP2) you will work in teams of 2 people on a project that shows what you have learned from these topics. You will develop (program) a system to monitor the amount of people in a room, by detecting their smartphones, uploading the data to an external server for analysis and visualization. In the following sections we describe what should be covered for the two subjects.","title":"Networks and Protocols (NP1 + NP2) Final Programming Project"},{"location":"Subjects/NP2/FinalProject/#requirements-for-np1","text":"Your system should manage a sensor network, formed by your ESP32 nodes. We assume that you could have at least one node per room and that each room has a WiFi access point reachable. In this context: Your nodes should be able to connect to the AP using WiFi, with WPA2-PSK security. Your nodes should provide a provissioning option, so that you can configure the wifi SSID to connect to. You can use a softAP or a BLE provisioning method, that is up to you. Your nodes should use BLE to compute the number of other BLE devices in its range (an estimation of the number of people in its range), using the RSSI to compute the distance to the node (the student should research for methods to compute the distance). Alternatively the student can opt for using a different technology of his choice to estimate the number of people in the room. The node should be configured through the menuconfig system, to establish its parameters: Sampling period. Server where the samples should be sent to (see requirements for NP2). Range of valid distances. etc.","title":"Requirements for NP1"},{"location":"Subjects/NP2/FinalProject/#optional-parts-for-np1","text":"Optionally you can extend the project incorporating some extra features like the following (these are only ideas, you can also propose some others): Consider an scenario with larger rooms, in which one node is not enough and the wifi AP is not reachable on all points. In this scenario you can use the ESP's wifi-mesh technology to build a mesh of nodes in the room. Study the Over The Air (OTA) features of ESP and prepare your nodes to receive OTA updates from an external server. Together with NP2 you can consider to configure the nodes to trigger the OTA update through MQTT (or any other application protocol you are using). Add a GATT server that allows the node parameters to be configured with a BLE client.","title":"Optional Parts for NP1"},{"location":"Subjects/NP2/FinalProject/#requirements-for-np2","text":"The developed system will periodically publish the calculated data for the population of BLE devices in the room, sending it to an external server for further storage and analysis. Specifically, the minimum requirements related with NP2 include: You will select an application-level protocol among those studied in NP2 (or, alternatively, other similar protocols of your interest) and use it for data publishing. Servers/brokers to which data will be sent will be configured via menuconfig , together with the sending period and any other configurable parameter considered useful. You will select and use one of the two data representation methods studied in the course (JSON or CBOR). Data will be gathered by Node-RED and submitted to two different destinations: A dashboard of your election (e.g. Node-RED, Grafana, ...). A database (e.g. MongoDB), where it will be stored together with a timestamp.","title":"Requirements for NP2"},{"location":"Subjects/NP2/FinalProject/#optional-parts-for-np2","text":"Optionally you can extend the project incorporating some extra features like the following (these are only ideas, you can also propose some others): Use encryption at all levels of the communication (e.g. MQTT). Develop an alarm system that triggers under certain conditions (e.g. when the amount of BLE devices is out of a pre-established range), and sends a notification to the user using external services (e.g. SMS, e-mail, Telegram, ...). Implement bi-directional communication, with the possibility of externally modifying the behavior of the ESP32 (e.g. modifying sampling or sending period).","title":"Optional Parts for NP2"},{"location":"Subjects/NP2/groups/","text":"Groups for lecture assignments We will be using the stable groups from NP1 to work during lectures (and after class). Group 1 Rol Full name Speaker BIN ZHANG Speaker (2) Youran Tian Recorder FENGFENG GU Auditor GONGLU ZOU Contributor HONGBIAO CAO Contributor WENYAN LIAO Group 2 Rol Full name Speaker Duan Zhen Recorder Hu Haho Auditor Liu Jinhua Contributor Weilin Zhang Contributor Huang Yujuan Contributor Jun Shou Group 3 Rol Full name Speaker GuanJIE Xiao Speaker (2) DongYang Xu Recorder ShaYuan Shuang Auditor Junyan Guo Contributor Zhijun Hao Contributor Xueqing Zhao Contributor Jiali Gao Group 4 Rol Full name Speaker JIEPING YOU Recorder QINGHONG YU Auditor SUIZHI LIU Contributor TIANFENG LI Contributor WEI REN Contributor XIAZU HU Group 5 Rol Full name Speaker ZHOU Ping Speaker (2) LIAO Yinghua Recorder PAN Jiayun Auditor ZHANG Yi Contributor Shuishi Zhou Contributor Yang Chu Group 6 Rol Full name Speaker Xiaolan Li Recorder Xionglan Luo Auditor Qiuji Chen Contributor Jianchuang Zhang Contributor Yan Zhao Contributor Yongtao He Contributor Zhao Hu","title":"Groups for lecture assignments"},{"location":"Subjects/NP2/groups/#groups-for-lecture-assignments","text":"We will be using the stable groups from NP1 to work during lectures (and after class).","title":"Groups for lecture assignments"},{"location":"Subjects/NP2/groups/#group-1","text":"Rol Full name Speaker BIN ZHANG Speaker (2) Youran Tian Recorder FENGFENG GU Auditor GONGLU ZOU Contributor HONGBIAO CAO Contributor WENYAN LIAO","title":"Group 1"},{"location":"Subjects/NP2/groups/#group-2","text":"Rol Full name Speaker Duan Zhen Recorder Hu Haho Auditor Liu Jinhua Contributor Weilin Zhang Contributor Huang Yujuan Contributor Jun Shou","title":"Group 2"},{"location":"Subjects/NP2/groups/#group-3","text":"Rol Full name Speaker GuanJIE Xiao Speaker (2) DongYang Xu Recorder ShaYuan Shuang Auditor Junyan Guo Contributor Zhijun Hao Contributor Xueqing Zhao Contributor Jiali Gao","title":"Group 3"},{"location":"Subjects/NP2/groups/#group-4","text":"Rol Full name Speaker JIEPING YOU Recorder QINGHONG YU Auditor SUIZHI LIU Contributor TIANFENG LI Contributor WEI REN Contributor XIAZU HU","title":"Group 4"},{"location":"Subjects/NP2/groups/#group-5","text":"Rol Full name Speaker ZHOU Ping Speaker (2) LIAO Yinghua Recorder PAN Jiayun Auditor ZHANG Yi Contributor Shuishi Zhou Contributor Yang Chu","title":"Group 5"},{"location":"Subjects/NP2/groups/#group-6","text":"Rol Full name Speaker Xiaolan Li Recorder Xionglan Luo Auditor Qiuji Chen Contributor Jianchuang Zhang Contributor Yan Zhao Contributor Yongtao He Contributor Zhao Hu","title":"Group 6"},{"location":"Subjects/NP2/paperProject/","text":"Group paper work Together with your lab group, you need to prepare a paper work, as explained in the slides of the first class Presentation . It is a documentation work in which you are requested to explore a set of documents yourself on one of the application-level protocols, technologies and platforms used for or focused on IoT systems. The technologies proposed are listed bellow. You are requested to focus the study on its use in your local area or China, however you can expand it to Asia or the whole world if you feel like doing it (not required). In both cases you should study not only the technical aspects of the technology, you should also include known use cases (in the case of choosing one of the technologies proposed below), expected growth of the technology, direct competitors and potential future market share. Practical implementations, code snippets, or even protoype codes are also welcome. List of technologies you can consider The technologies for the paper work shall not overlap between groups, you should request one of the topics sending a mail to the professor (figual@ucm.es) before March 1st , who will confirm if you can choose the topic or if it has been already chosen by other group. The topics are: Advanced MQTT Advanced CoAP LWM2M and Smart Objects Websockets Digital twins Advanced visualization services and dashboards The Eclipse IoT project Advanced JSON and CBOR Amazon Web Services for IoT Microsoft Azure for IoT Google services for IoT Alibaba IoT OTA (Over the Air) updates Edge Computing A comparative study of IoT platforms Practical use cases of any of the studied technologies Deadline Originally 8th April. Delivering the project Once finished, please send me an email (to figual@ucm.es )","title":"Group paper work"},{"location":"Subjects/NP2/paperProject/#group-paper-work","text":"Together with your lab group, you need to prepare a paper work, as explained in the slides of the first class Presentation . It is a documentation work in which you are requested to explore a set of documents yourself on one of the application-level protocols, technologies and platforms used for or focused on IoT systems. The technologies proposed are listed bellow. You are requested to focus the study on its use in your local area or China, however you can expand it to Asia or the whole world if you feel like doing it (not required). In both cases you should study not only the technical aspects of the technology, you should also include known use cases (in the case of choosing one of the technologies proposed below), expected growth of the technology, direct competitors and potential future market share. Practical implementations, code snippets, or even protoype codes are also welcome.","title":"Group paper work"},{"location":"Subjects/NP2/paperProject/#list-of-technologies-you-can-consider","text":"The technologies for the paper work shall not overlap between groups, you should request one of the topics sending a mail to the professor (figual@ucm.es) before March 1st , who will confirm if you can choose the topic or if it has been already chosen by other group. The topics are: Advanced MQTT Advanced CoAP LWM2M and Smart Objects Websockets Digital twins Advanced visualization services and dashboards The Eclipse IoT project Advanced JSON and CBOR Amazon Web Services for IoT Microsoft Azure for IoT Google services for IoT Alibaba IoT OTA (Over the Air) updates Edge Computing A comparative study of IoT platforms Practical use cases of any of the studied technologies","title":"List of technologies you can consider"},{"location":"Subjects/NP2/paperProject/#deadline","text":"Originally 8th April.","title":"Deadline"},{"location":"Subjects/NP2/paperProject/#delivering-the-project","text":"Once finished, please send me an email (to figual@ucm.es )","title":"Delivering the project"},{"location":"Subjects/NP2/Assignments/1/","text":"Assignment 1 Deadline: 25/01/22 Type: In groups Delivery: Via mail to figual@ucm.es indicating [Assignment 1] Group number in the subject. Part 1 In this assignment, you will work by groups. Discuss with the members of the group and propose a realistic IoT development consisting of, at least, a number of sensors and actuators distributed in an indoor or outdoor environment (or both). Briefly describe it using a slide, bullet points in a document or any media you consider of interest. After finishing it, a member of the group will need to present it in front of the rest of the class. Part 2 Develop with more detail the deployment, with special interest in the following questions: Are there restrictions in number of messages per time unit? Are there restrictions in latency, bandwidth and other network metrics? What is the maximum transmission range between nodes? Are nodes mobile? Are package losses accepted? Is retransmission necessary? Is energy consumption an actual concern? Do nodes need to be maintained/managed remotely? Is bidirectionality in transmission necessary? Is edge computing necessary or recommended? Is security a concern? Any other concern of interest. Write down answers to these questions in a slide, document or any media you consider of interest. After finishing it, a member of the group will need to present it in front of the rest of the class. Part 3 Perform a market study and select: The best type of node (board) that can fulfill the restrictions. The most appropriate network technology (physical/link layer). The most appropriate application and transport-layer protocols to use at each point of the deployment. Write down answers to each topic in a slide, document or any media you consider of interest. After finishing it, a member of the group will need to present it in front of the rest of the class. A final report gathering all three parts will be submitted as a final delivery before deadline, and will determine the final grade. Please submit one report per group .","title":"Assignment 1"},{"location":"Subjects/NP2/Assignments/1/#assignment-1","text":"","title":"Assignment 1"},{"location":"Subjects/NP2/Assignments/1/#deadline","text":"25/01/22","title":"Deadline:"},{"location":"Subjects/NP2/Assignments/1/#type","text":"In groups","title":"Type:"},{"location":"Subjects/NP2/Assignments/1/#delivery","text":"Via mail to figual@ucm.es indicating [Assignment 1] Group number in the subject.","title":"Delivery:"},{"location":"Subjects/NP2/Assignments/1/#part-1","text":"In this assignment, you will work by groups. Discuss with the members of the group and propose a realistic IoT development consisting of, at least, a number of sensors and actuators distributed in an indoor or outdoor environment (or both). Briefly describe it using a slide, bullet points in a document or any media you consider of interest. After finishing it, a member of the group will need to present it in front of the rest of the class.","title":"Part 1"},{"location":"Subjects/NP2/Assignments/1/#part-2","text":"Develop with more detail the deployment, with special interest in the following questions: Are there restrictions in number of messages per time unit? Are there restrictions in latency, bandwidth and other network metrics? What is the maximum transmission range between nodes? Are nodes mobile? Are package losses accepted? Is retransmission necessary? Is energy consumption an actual concern? Do nodes need to be maintained/managed remotely? Is bidirectionality in transmission necessary? Is edge computing necessary or recommended? Is security a concern? Any other concern of interest. Write down answers to these questions in a slide, document or any media you consider of interest. After finishing it, a member of the group will need to present it in front of the rest of the class.","title":"Part 2"},{"location":"Subjects/NP2/Assignments/1/#part-3","text":"Perform a market study and select: The best type of node (board) that can fulfill the restrictions. The most appropriate network technology (physical/link layer). The most appropriate application and transport-layer protocols to use at each point of the deployment. Write down answers to each topic in a slide, document or any media you consider of interest. After finishing it, a member of the group will need to present it in front of the rest of the class. A final report gathering all three parts will be submitted as a final delivery before deadline, and will determine the final grade. Please submit one report per group .","title":"Part 3"},{"location":"Subjects/NP2/P1/","text":"Laboratory 1. Python socket programming Goals To get familiar with the Python sockets API. To develop basic client/server setups based on TCP and UDP using Python. To be able to analyze traffic generated by a TCP and UDP connection via Wireshark. To design an application-layer protocol to simulate a client/server application using TCP and UDP. To observe the difference in generated traffic between UDP and TCP for an equivalent application. (Optionally) To implement multi-threaded servers in Python. Introduction The history of sockets begins with the origin of ARPANET, in 1971, and their standardization by means of an API within the BSD operating system, released in 1983, under the name Berkeley Sockets . With the popularization of Internet in the 90s, and together with the World Wide Web , network programming suffered a relevant evolution. Web servers and browsers were not (and are not) the only applications based on sockets. Actually, client/server systems are, as of today, ubiquitous, and include all high-level protocols that give support to IoT. Today, even though high-level protocls have evolved till unprecedented sophistication levels, the underlying low-level interface remains unchanged. The most common application type based on sockets is built on top of the client/server paradigm, where one of the parts acts as a server , passively waiting for external connection/requests from a set of one or more clients . In the following, we will study how to develop this type of paradigm from Python, using Berkeley sockets . There also exist the so-called Unix domain sockets , that allow a direct communication across processes at the same host ; they are, however, of of the scope of IoT and we will not study them. The Python sockets API The Python socket module provides a complete interface to work with the Berkeley sockets API . In this laboratory, we will exclusively work with this API to develop client/server applications using the TCP and UDP protocols. The main functions and methods of the sockets API are: socket() . bind() . listen() . accept() . connect() . connect_ex() . send() . recv() . close() . Python provides a consistent and complete API mapped directly to the aforementioned system calls, typically written in C. As a part of its standard library, Python also provides classes to ease working with low-level functions. We will not cover it in detail, but the socketserver module provides an easy way to create network servers. There also exist many modules available to implement high-level protocols (e.g. HTTP or SMTP), see this link . TCP sockets In Python, TCP sockets are created using socket.socket() , specifying the socket type as socket.SOCK_STREAM . The Transmision Control Protocol (TCP) features two main characteristics: It is reliable : loss detection methods are implemented that detect datagram losses and force lost package resubmission. Guarantees in-order package delivery : data are delivered to higher-levels (applications) in the same order as they were sent. Contrary, UDP sockets are created by means of socket.SOCK_DGRAM , and they are neither reliable nor guarantee in-order data delivery. Hence, it is a responsibility of the application developer to implement those mechanisms manually if desired. The following picture shows the typical API invocation sequence for TCP: In the figure, the left column illustrates the serve, and the right column shows the client of the TCP connection. Observe the necessary invocations to configure a socket listening for incoming connections: socket() bind() listen() accept() At the server, a socket listens for potential incoming connections from clients. When a client rquests a connection, the server accepts the request, completing the connection. The client invokes connect() to establish a connection with a server, and initiates the three-way handshaking protocol to establish the connection. Upon establishment, data are exchanged among client and server via send() and recv() . Finally, the socket is destroyed (the connection is closed) via a close() invocation at each end. TCP client/server echo example Let us study a simple example to create a client-server pair. In this case, the server just responds to the client with the same string as that received from the client. echo server #!/usr/bin/env python3 #### server_echo.py import socket HOST = '127.0.0.1' # Loopback interface (localhost) PORT = 65432 # Listen port (ports higher than 1023 are non-privileged) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Connected ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Note By now, do not worry if you do not understand all lines in the code. This is just an starting point to develop a simple server. However, it is a good idea to copy the code in a text file (e.g. server_echo.py ) so we can test it afterwards. Let as study line by line the main parts of the code: socket.socket() creates a socket object. Note that, as it is created via a with construction, it is not necessary to explicitly invoke to s.close() , even though you need to realize that the object is destroyed after the construction: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass The arguments provided to socket() specify the address family ( AF_INET ) and socket type ( SOCK_STREAM ). AF_INET is the address family of the Internet for IPv4. SOCK_STREAM is the type of socket that allows for the creation of TCP connections. bind() is used to associate the socket to a network interface and port number: HOST = '127.0.0.1' # Loopback interface (localhost) PORT = 65432 # Listen port # ... s.bind((HOST, PORT)) The values proviede to bind() depend on the address family selected for the socket. In the example, as AF_INET is used, the routine expects a tuple with just two values (host, port) . To determine the host , it is possible to use a host name, an IP address or an empty string. If we use an IP address, it needs to be specified by means of a string containing a well-formed address. The address 127.0.0.1 is the standard IPv4 address for the loopback interface, so that only local processes (running at the same host) will be able to communicate with the server. If we provide an empty string, the server will accept incoming connections by via all IPv4 interfaces in the system. The port number ( port ) is specified with an integer value between 1 and 65535, and specifies the port (in this case, TCP) that the server will use to accept incoming client connection. Many systems require superuser privilege to listen via privileged ports (with values between 1 and 1023). Following with the example, listen() allows for a server to accept, in the future, incoming connections via accept() . In other words, it transforms the socket into a listening socket: s.listen() conn, addr = s.accept() Invoking accept() blocks the process and waits for an incoming connection. Upon a client connection, it returns a socket object that represents the connection, and a tupple ( addr ) that contains the address of the client. This tuple contains the values (host, port) that store the IPv4 adress and client port that requests for the connection. Note that, in the example, conn is the socket object that we will use to communicate with the client: conn, addr = s.accept() with conn: print('Connected ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) After obtaining the object returned by accept() , we design the server as an infinite loop that repeatedly invokes to blocking conn.recv() . This way, we read data sent by the client and we resend them without modification using conn.sendall() . If conn.recv() returns an empty object of type bytes ( b'' ), it means that the client closed the conection, in which case the loop finishes, destroying the socket after the with construction. echo client Let us observe the general structure of the client (you can use, for example client_echo.py as a name for the file): #!/usr/bin/env python3 ### client_echo.py import socket HOST = '127.0.0.1' # Server IP PORT = 65432 # Listen server port with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hello, world') data = s.recv(1024) print('Received ', repr(data)) Compared with the server, the client structure is simpler; it just creates a new socket object, connects with the server and invokes s.sendall() to send the message. Finally, it waits for the response using s.recv() and prints it on screen. Echo client and server execution Next, we will execute the client and server programs to observe the status of the connection troughout their life cycle. Execute in a terminal the server: $ python3 ./server-echo.py You will see that the terminal blocks (actually, the server process remains in a blocked state) in the invocation: conn, addr = s.accept() Actually, the server is waiting for incoming connections from a client. Open a sencond terminal and execute the client: $ python3 client-echo.py Received 'Hello, world' On the server screen, you should see something similar to: $ python3 ./server-echo.py Connected ('127.0.0.1, 61234') In this output, the server reports the tuple returned by s.accept() , that includes the IP address and the TCP port. That port number (in the example, 61234) is seleted randomly by the operating system and can vary in your execution. Tools to analyze the socket status We can use the netstat tool to observe the current status of the sockets in any OS (macOS, Linux and even Windows). For example, this would be the output of netstat in Linux after executing the server: netstat -an | grep 65432 Active connections Proto Recv Sent Local address Remote address Status tcp 0 0 127.0.0.1:65432 0.0.0.0:* LISTEN Note that we have filtered the output of the netcat command to match the used port. Also observe the value of all columns, and try to understand if it makes sense to you. Note Another way to observe the status of the connections is via the command lsof -i -n . Execute it and observe its output. Capturing network traffic via Wireshark Wireshark is an open-source tool widely used to analyze network communication protocols at any layer of the TCP/IP stack (and also other protocols). Wireshark implements a wide range of filters to define search criteria in the traffic captures. However, in our case, it will not be necessary to use advanced filters. To execute the took in the virtual machine (or in any basic Linux setup), just type in your terminal: $ sudo wireshark Upon booting, we can start a new traffic capture via the menu Capture , option Start . The interface selection screen allows for the definition of the interface we need to intercept. In our case, as we are communicating two processes on the same machine, we will choose the Loopback (lo) interface and we will start the capture. Task 1.1 Start wireshark and prepare a capture on the loopback interface. Execute the TCP echo server and the corresponding client, and analyze the generated traffic. Specifically, observe the connection establishment procedure, use of ACK packages and, in general any other aspect that is of your interest. Write a short report with screenshots of your observations. UDP sockets The creation and management of UDP sockets in Python is even simpler. Observe the following code, that creates a UDP server using the Python sockets API: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) First, we import the socket module, as for TCP. Obviously, in this case the socket type is of type socket.DOCK_DGRAM , to indicate that we need to use UDP in the communication. The program waits for the reception of a packet using the blocking recv method, with only one parameter: the maximum number of bytes we would like to receive. When a packet arrives to the socket, the recv method will return a byte array , that will be stored in the desired variable. The submission of data is also simple: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hello, world!\" udp_socket.sendto(data,(\"localhost\", 5005)) Note how, in this case, we associate ( bind ) the socket to a port specifyed as 0. This special value indicates to the OS that it needs to choos for the transmission a random source port between those available in the system. Next, we create the data to sumbit, and send them using the method sendto() . This method takes two arguments: data to send, and destination address. Data sent through the socket must be part of a bytes array de un array de bytes (hence, the string to submit needs to be preceeded by the character b ). Task 1.2 Check that the codes for sending and receiving via UDP work as expected. Write a short report with your observations Note From version 3 on, strings in Python are coded using UNICODE. Contrary from ASCII, where each character has a direct byte representation, UNICODE uses integers to represent each character, that need to be encoded to obtain a byte representation. One of these schemas is UTF-8. For example,, the following code shows how to encode a UNICODE string onto a bytes representation: c= \"Hello\" data = c.encode(\"UTF-8\") print(data, type(data)) That generates: b\"Hello\" <class 'bytes'> that can be sent directly through the network. Up to this point, the UDP programs have been completely unidirectional in the submission/reception of data, but obviously, a UDP socket is a bi-directional communication channel. Task 1.3 Implement a similar functionality than that of the echo that we studied for TCP, but using UDP. Provide a traffic capture via Wireshark and observe the differences between the data transmission in TCP and UDP. Provide a discussion about the benefits (or lack of them) of UDP compared with TCP for IoT. Sending binary data via sockets Up to this point, we have studied how to send text strings via TCP or UDP sockets, but it is common to find a necessity to send data directly in binary format (e.g. numeric values in floating point or integers). Using the struct Python module, we can specify which type or types of data are stored in a sequence of bytes, and how to decode them. It is also possible to specify in which place of the sequence are those data stored, allowing for packing multiple data of different types in a simple manner, and its decoding at the other side of the communication channel. Note Check all details of the struct module on its official documentation page. The struct module provides two interesting methods: pack and unpack . The following sentence: struct.pack(\">iii\", 1, 2, 3) uses the pack method to perform data packing. Specifically, observe how the method receives two parameters: First, the format parameter \">iii\" . It defines how each value in the sequence need to be encoded. The first character indicates the endianness , in this case big endian (we should use \">\" for big endiand, \"<\" for little endian, and \"=\" for network endianness). Second, the values to pack. Note that the format, in addition, includes the number and type of data to pack (in this case three integer values). For other data types, check the module's documentation. Unpacking data on the other side of the cahnnel is intuitive: a, b, c = struct.unpack( \">iii\" ) Next, we show an example of a client/server TCP setup that leverages the struct to send two integer numbers and a floating point number between a client and a server: # Client import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Sending data print('Sending \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Closing socket') sock.close() # Server import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Waiting for incoming connections') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Received \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Unpacked:', unpacked_data) finally: connection.close() Task 1.4 Execute the client/server system and analyze the generated traffic. Look for the binary packed data. Experiment with other types of data and endianness and observe the differences. Deliverable task Deliverable task 1 Design a client/server system and implement it using Python. The system will simulate a client sending a number of pieces of data sensed to a server. The protocol to use (format of each packet sent to the server at the application layer) needs to be designed and proposed by the student and described prior to starting the coding effort. The final mark will consider positively the use of multiple data types, both in ths sent data and responses from the server. The student will develop a TCP and a UDP version of the solution. The client will submit data in a periodic fashion, and data will be generated randomly. The deliverable will include the developed codes, and an analysis of the generated traffic, with comments about the overhead (in bytes) introduced by each protocol of the transport layer. Multi-threaded client/server example The previous examples are perfectly valid and functional, but lack in their design of a basic functionality: the server stops attending new incoming requests while a request from a client is processed. The following examples show simple implementations with multi-threaded support for a client/server system written in Python. # Concurrent TCP server import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"New connection added: \", clientAddress) def run(self): print (\"Connection from: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"From the client\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Client \", clientAddress , \" disconnected...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Server started...\") print(\"Waiting for client requests...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # TCP client. The string *end* indicates disonnection request. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hello, I am a client!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"From the server:\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Task 1.5 Study the codes for the concurrent server and observe how it manages the creaton of threads to handle an incoming request. Connect simultaneously multiple clients and observe the status of the sockets using the corresponding tools. Write a short report with your observations . Optional deliverable Optional deliverable task 1 Modify your first deliverable to consider a multi-threaded implmentation of the TCP server, following the guidelines of the example codes. Optional deliverable Optional deliverable task 1 Modify the sending protocol so that your UDP applications guarantees as much as possible the reception of UDP packages sent from the client, and an in-order reception. Analyze again the necessary network traffic in this case compared with a TCP scheme.","title":"Laboratory 1. Python socket programming"},{"location":"Subjects/NP2/P1/#laboratory-1-python-socket-programming","text":"","title":"Laboratory 1. Python socket programming"},{"location":"Subjects/NP2/P1/#goals","text":"To get familiar with the Python sockets API. To develop basic client/server setups based on TCP and UDP using Python. To be able to analyze traffic generated by a TCP and UDP connection via Wireshark. To design an application-layer protocol to simulate a client/server application using TCP and UDP. To observe the difference in generated traffic between UDP and TCP for an equivalent application. (Optionally) To implement multi-threaded servers in Python.","title":"Goals"},{"location":"Subjects/NP2/P1/#introduction","text":"The history of sockets begins with the origin of ARPANET, in 1971, and their standardization by means of an API within the BSD operating system, released in 1983, under the name Berkeley Sockets . With the popularization of Internet in the 90s, and together with the World Wide Web , network programming suffered a relevant evolution. Web servers and browsers were not (and are not) the only applications based on sockets. Actually, client/server systems are, as of today, ubiquitous, and include all high-level protocols that give support to IoT. Today, even though high-level protocls have evolved till unprecedented sophistication levels, the underlying low-level interface remains unchanged. The most common application type based on sockets is built on top of the client/server paradigm, where one of the parts acts as a server , passively waiting for external connection/requests from a set of one or more clients . In the following, we will study how to develop this type of paradigm from Python, using Berkeley sockets . There also exist the so-called Unix domain sockets , that allow a direct communication across processes at the same host ; they are, however, of of the scope of IoT and we will not study them.","title":"Introduction"},{"location":"Subjects/NP2/P1/#the-python-sockets-api","text":"The Python socket module provides a complete interface to work with the Berkeley sockets API . In this laboratory, we will exclusively work with this API to develop client/server applications using the TCP and UDP protocols. The main functions and methods of the sockets API are: socket() . bind() . listen() . accept() . connect() . connect_ex() . send() . recv() . close() . Python provides a consistent and complete API mapped directly to the aforementioned system calls, typically written in C. As a part of its standard library, Python also provides classes to ease working with low-level functions. We will not cover it in detail, but the socketserver module provides an easy way to create network servers. There also exist many modules available to implement high-level protocols (e.g. HTTP or SMTP), see this link .","title":"The Python sockets API"},{"location":"Subjects/NP2/P1/#tcp-sockets","text":"In Python, TCP sockets are created using socket.socket() , specifying the socket type as socket.SOCK_STREAM . The Transmision Control Protocol (TCP) features two main characteristics: It is reliable : loss detection methods are implemented that detect datagram losses and force lost package resubmission. Guarantees in-order package delivery : data are delivered to higher-levels (applications) in the same order as they were sent. Contrary, UDP sockets are created by means of socket.SOCK_DGRAM , and they are neither reliable nor guarantee in-order data delivery. Hence, it is a responsibility of the application developer to implement those mechanisms manually if desired. The following picture shows the typical API invocation sequence for TCP: In the figure, the left column illustrates the serve, and the right column shows the client of the TCP connection. Observe the necessary invocations to configure a socket listening for incoming connections: socket() bind() listen() accept() At the server, a socket listens for potential incoming connections from clients. When a client rquests a connection, the server accepts the request, completing the connection. The client invokes connect() to establish a connection with a server, and initiates the three-way handshaking protocol to establish the connection. Upon establishment, data are exchanged among client and server via send() and recv() . Finally, the socket is destroyed (the connection is closed) via a close() invocation at each end.","title":"TCP sockets"},{"location":"Subjects/NP2/P1/#tcp-clientserver-echo-example","text":"Let us study a simple example to create a client-server pair. In this case, the server just responds to the client with the same string as that received from the client.","title":"TCP client/server echo example"},{"location":"Subjects/NP2/P1/#echo-server","text":"#!/usr/bin/env python3 #### server_echo.py import socket HOST = '127.0.0.1' # Loopback interface (localhost) PORT = 65432 # Listen port (ports higher than 1023 are non-privileged) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Connected ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Note By now, do not worry if you do not understand all lines in the code. This is just an starting point to develop a simple server. However, it is a good idea to copy the code in a text file (e.g. server_echo.py ) so we can test it afterwards. Let as study line by line the main parts of the code: socket.socket() creates a socket object. Note that, as it is created via a with construction, it is not necessary to explicitly invoke to s.close() , even though you need to realize that the object is destroyed after the construction: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass The arguments provided to socket() specify the address family ( AF_INET ) and socket type ( SOCK_STREAM ). AF_INET is the address family of the Internet for IPv4. SOCK_STREAM is the type of socket that allows for the creation of TCP connections. bind() is used to associate the socket to a network interface and port number: HOST = '127.0.0.1' # Loopback interface (localhost) PORT = 65432 # Listen port # ... s.bind((HOST, PORT)) The values proviede to bind() depend on the address family selected for the socket. In the example, as AF_INET is used, the routine expects a tuple with just two values (host, port) . To determine the host , it is possible to use a host name, an IP address or an empty string. If we use an IP address, it needs to be specified by means of a string containing a well-formed address. The address 127.0.0.1 is the standard IPv4 address for the loopback interface, so that only local processes (running at the same host) will be able to communicate with the server. If we provide an empty string, the server will accept incoming connections by via all IPv4 interfaces in the system. The port number ( port ) is specified with an integer value between 1 and 65535, and specifies the port (in this case, TCP) that the server will use to accept incoming client connection. Many systems require superuser privilege to listen via privileged ports (with values between 1 and 1023). Following with the example, listen() allows for a server to accept, in the future, incoming connections via accept() . In other words, it transforms the socket into a listening socket: s.listen() conn, addr = s.accept() Invoking accept() blocks the process and waits for an incoming connection. Upon a client connection, it returns a socket object that represents the connection, and a tupple ( addr ) that contains the address of the client. This tuple contains the values (host, port) that store the IPv4 adress and client port that requests for the connection. Note that, in the example, conn is the socket object that we will use to communicate with the client: conn, addr = s.accept() with conn: print('Connected ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) After obtaining the object returned by accept() , we design the server as an infinite loop that repeatedly invokes to blocking conn.recv() . This way, we read data sent by the client and we resend them without modification using conn.sendall() . If conn.recv() returns an empty object of type bytes ( b'' ), it means that the client closed the conection, in which case the loop finishes, destroying the socket after the with construction.","title":"echo server"},{"location":"Subjects/NP2/P1/#echo-client","text":"Let us observe the general structure of the client (you can use, for example client_echo.py as a name for the file): #!/usr/bin/env python3 ### client_echo.py import socket HOST = '127.0.0.1' # Server IP PORT = 65432 # Listen server port with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hello, world') data = s.recv(1024) print('Received ', repr(data)) Compared with the server, the client structure is simpler; it just creates a new socket object, connects with the server and invokes s.sendall() to send the message. Finally, it waits for the response using s.recv() and prints it on screen.","title":"echo client"},{"location":"Subjects/NP2/P1/#echo-client-and-server-execution","text":"Next, we will execute the client and server programs to observe the status of the connection troughout their life cycle. Execute in a terminal the server: $ python3 ./server-echo.py You will see that the terminal blocks (actually, the server process remains in a blocked state) in the invocation: conn, addr = s.accept() Actually, the server is waiting for incoming connections from a client. Open a sencond terminal and execute the client: $ python3 client-echo.py Received 'Hello, world' On the server screen, you should see something similar to: $ python3 ./server-echo.py Connected ('127.0.0.1, 61234') In this output, the server reports the tuple returned by s.accept() , that includes the IP address and the TCP port. That port number (in the example, 61234) is seleted randomly by the operating system and can vary in your execution.","title":"Echo client and server execution"},{"location":"Subjects/NP2/P1/#tools-to-analyze-the-socket-status","text":"We can use the netstat tool to observe the current status of the sockets in any OS (macOS, Linux and even Windows). For example, this would be the output of netstat in Linux after executing the server: netstat -an | grep 65432 Active connections Proto Recv Sent Local address Remote address Status tcp 0 0 127.0.0.1:65432 0.0.0.0:* LISTEN Note that we have filtered the output of the netcat command to match the used port. Also observe the value of all columns, and try to understand if it makes sense to you. Note Another way to observe the status of the connections is via the command lsof -i -n . Execute it and observe its output.","title":"Tools to analyze the socket status"},{"location":"Subjects/NP2/P1/#capturing-network-traffic-via-wireshark","text":"Wireshark is an open-source tool widely used to analyze network communication protocols at any layer of the TCP/IP stack (and also other protocols). Wireshark implements a wide range of filters to define search criteria in the traffic captures. However, in our case, it will not be necessary to use advanced filters. To execute the took in the virtual machine (or in any basic Linux setup), just type in your terminal: $ sudo wireshark Upon booting, we can start a new traffic capture via the menu Capture , option Start . The interface selection screen allows for the definition of the interface we need to intercept. In our case, as we are communicating two processes on the same machine, we will choose the Loopback (lo) interface and we will start the capture. Task 1.1 Start wireshark and prepare a capture on the loopback interface. Execute the TCP echo server and the corresponding client, and analyze the generated traffic. Specifically, observe the connection establishment procedure, use of ACK packages and, in general any other aspect that is of your interest. Write a short report with screenshots of your observations.","title":"Capturing network traffic via Wireshark"},{"location":"Subjects/NP2/P1/#udp-sockets","text":"The creation and management of UDP sockets in Python is even simpler. Observe the following code, that creates a UDP server using the Python sockets API: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) First, we import the socket module, as for TCP. Obviously, in this case the socket type is of type socket.DOCK_DGRAM , to indicate that we need to use UDP in the communication. The program waits for the reception of a packet using the blocking recv method, with only one parameter: the maximum number of bytes we would like to receive. When a packet arrives to the socket, the recv method will return a byte array , that will be stored in the desired variable. The submission of data is also simple: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hello, world!\" udp_socket.sendto(data,(\"localhost\", 5005)) Note how, in this case, we associate ( bind ) the socket to a port specifyed as 0. This special value indicates to the OS that it needs to choos for the transmission a random source port between those available in the system. Next, we create the data to sumbit, and send them using the method sendto() . This method takes two arguments: data to send, and destination address. Data sent through the socket must be part of a bytes array de un array de bytes (hence, the string to submit needs to be preceeded by the character b ). Task 1.2 Check that the codes for sending and receiving via UDP work as expected. Write a short report with your observations Note From version 3 on, strings in Python are coded using UNICODE. Contrary from ASCII, where each character has a direct byte representation, UNICODE uses integers to represent each character, that need to be encoded to obtain a byte representation. One of these schemas is UTF-8. For example,, the following code shows how to encode a UNICODE string onto a bytes representation: c= \"Hello\" data = c.encode(\"UTF-8\") print(data, type(data)) That generates: b\"Hello\" <class 'bytes'> that can be sent directly through the network. Up to this point, the UDP programs have been completely unidirectional in the submission/reception of data, but obviously, a UDP socket is a bi-directional communication channel. Task 1.3 Implement a similar functionality than that of the echo that we studied for TCP, but using UDP. Provide a traffic capture via Wireshark and observe the differences between the data transmission in TCP and UDP. Provide a discussion about the benefits (or lack of them) of UDP compared with TCP for IoT.","title":"UDP sockets"},{"location":"Subjects/NP2/P1/#sending-binary-data-via-sockets","text":"Up to this point, we have studied how to send text strings via TCP or UDP sockets, but it is common to find a necessity to send data directly in binary format (e.g. numeric values in floating point or integers). Using the struct Python module, we can specify which type or types of data are stored in a sequence of bytes, and how to decode them. It is also possible to specify in which place of the sequence are those data stored, allowing for packing multiple data of different types in a simple manner, and its decoding at the other side of the communication channel. Note Check all details of the struct module on its official documentation page. The struct module provides two interesting methods: pack and unpack . The following sentence: struct.pack(\">iii\", 1, 2, 3) uses the pack method to perform data packing. Specifically, observe how the method receives two parameters: First, the format parameter \">iii\" . It defines how each value in the sequence need to be encoded. The first character indicates the endianness , in this case big endian (we should use \">\" for big endiand, \"<\" for little endian, and \"=\" for network endianness). Second, the values to pack. Note that the format, in addition, includes the number and type of data to pack (in this case three integer values). For other data types, check the module's documentation. Unpacking data on the other side of the cahnnel is intuitive: a, b, c = struct.unpack( \">iii\" ) Next, we show an example of a client/server TCP setup that leverages the struct to send two integer numbers and a floating point number between a client and a server: # Client import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Sending data print('Sending \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Closing socket') sock.close() # Server import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Waiting for incoming connections') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Received \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Unpacked:', unpacked_data) finally: connection.close() Task 1.4 Execute the client/server system and analyze the generated traffic. Look for the binary packed data. Experiment with other types of data and endianness and observe the differences.","title":"Sending binary data via sockets"},{"location":"Subjects/NP2/P1/#deliverable-task","text":"Deliverable task 1 Design a client/server system and implement it using Python. The system will simulate a client sending a number of pieces of data sensed to a server. The protocol to use (format of each packet sent to the server at the application layer) needs to be designed and proposed by the student and described prior to starting the coding effort. The final mark will consider positively the use of multiple data types, both in ths sent data and responses from the server. The student will develop a TCP and a UDP version of the solution. The client will submit data in a periodic fashion, and data will be generated randomly. The deliverable will include the developed codes, and an analysis of the generated traffic, with comments about the overhead (in bytes) introduced by each protocol of the transport layer.","title":"Deliverable task"},{"location":"Subjects/NP2/P1/#multi-threaded-clientserver-example","text":"The previous examples are perfectly valid and functional, but lack in their design of a basic functionality: the server stops attending new incoming requests while a request from a client is processed. The following examples show simple implementations with multi-threaded support for a client/server system written in Python. # Concurrent TCP server import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"New connection added: \", clientAddress) def run(self): print (\"Connection from: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"From the client\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Client \", clientAddress , \" disconnected...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Server started...\") print(\"Waiting for client requests...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # TCP client. The string *end* indicates disonnection request. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hello, I am a client!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"From the server:\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Task 1.5 Study the codes for the concurrent server and observe how it manages the creaton of threads to handle an incoming request. Connect simultaneously multiple clients and observe the status of the sockets using the corresponding tools. Write a short report with your observations .","title":"Multi-threaded client/server example"},{"location":"Subjects/NP2/P1/#optional-deliverable","text":"Optional deliverable task 1 Modify your first deliverable to consider a multi-threaded implmentation of the TCP server, following the guidelines of the example codes.","title":"Optional deliverable"},{"location":"Subjects/NP2/P1/#optional-deliverable_1","text":"Optional deliverable task 1 Modify the sending protocol so that your UDP applications guarantees as much as possible the reception of UDP packages sent from the client, and an in-order reception. Analyze again the necessary network traffic in this case compared with a TCP scheme.","title":"Optional deliverable"},{"location":"Subjects/NP2/P10/","text":"Pr\u00e1ctica 10. Frameworks IoT y Cloud Objetivos La pr\u00e1ctica presenta los pasos esenciales que permiten hacer interactuar un dispositivo (ESP32) con una infraestructura IoT en la nube. Aunque en este caso utilizaremos Microsoft Azure, los pasos tanto en configuraci\u00f3n remota como a nivel de nodo son muy similares a los que deber\u00edas seguir para otras infraestructuras (Amazon AWS, Google IoT Core, Aliyun IoT, Tencent Iot o cualquier otro). La documentaci\u00f3n de IDF proporciona ejemplos detallados para cada uno. El objetivo de la pr\u00e1ctica es desplegar un sistema de monitorizaci\u00f3n remota en Microsoft Power BI, que permita visualizar datos de telemetr\u00eda emitidos v\u00eda MQTT por el dispositivo a trav\u00e9s de un gateway en la nube (llamado en el caso de Azure IoT Hub ). Introducci\u00f3n El SDK ESP Azure IoT es una infraestructura basada en el SDK de Azure par IoT con soporte para C ( azure-iot-sdk-c ) portado sobre ESP-IDF para dar soporte al ESP32. Adem\u00e1s, proporciona un conjunto de ejemplos que permiten observar y simplificar el proceso de configuraci\u00f3n y conexi\u00f3n al framework Azure IoT Hub. Preparaci\u00f3n del firmware en el ESP32 En la presente pr\u00e1ctica utilizar\u00e1s una placa ESP32 que actuar\u00e1 como cliente ESP32, con un firmware personalizado que implementa la l\u00f3gica de conexi\u00f3n e interacci\u00f3n con Azure. En primer lugar: Configura una instalaci\u00f3n de ESP IDF tal y como has hecho en pr\u00e1cticas anteriores. Si ya la has configurado y es funcional, no es necesario ninguna reinstalaci\u00f3n ni reconfiguraci\u00f3n. En un directorio independiente, clona el repositorio de ESP Azure (f\u00edjate en la opci\u00f3n --recursive , que es imprescindible): git clone --recursive https://github.com/espressif/esp-azure.git Configuraci\u00f3n de Microsoft Azure Los siguientes pasos requieren el uso de una cuenta creada con Microsoft Azure. Los estudiantes UCM pueden adherirse al programa acad\u00e9mico, que otorga suficiente cr\u00e9dito para realizar este tipo de pr\u00e1cticas. Aseg\u00farate de acceder al portal de MS Azure y utilizar tu usuario y credenciales UCM para ello. Creaci\u00f3n de un Centro de IoT ( IoT Hub ) En la p\u00e1gina principal de Azure, selecciona la opci\u00f3n \"Crear un Recurso\" (en el men\u00fa de la parte superior izquierda de la pantalla) y a continuaici\u00f3n selecciona IoT Hub en cuadro \"Buscar en Marketplace\". Selecciona Iot Hub en los resultados de la b\u00fasqueda, y a continuaci\u00f3n \"Crear\". En la pesta\u00f1a Aspectos B\u00e1sicos , completa los campos de la siguiente forma: Suscripci\u00f3n : selecciona la suscripci\u00f3n que desees usar (por defecto, deber\u00eda aparecer Azure para estudiantes ). Grupo de recursos : crea un nuevo grupo de recursos seleccionando la opci\u00f3n Crear nuevo , y ot\u00f3rgale el nombre que desees, por ejemplo MIOTGROUP . Regi\u00f3n : selecciona la regi\u00f3n m\u00e1s cercana a ti (por ejemplo, Oeste de Europa ). Nombre : por \u00faltimo, da un nombre al hub , por ejemplo MIOTHUB . Deja los par\u00e1metros por defecto en la pesta\u00f1a Redes , y elige como Nivel de precios F1 en la pesta\u00f1a Administraci\u00f3n . Asigna las etiquetas que desees y finalmente confirma la creaci\u00f3n del Centro de IoT . Si todo ha ido bien, ver\u00e1s un resumen del recurso creado y podr\u00e1s acceder a \u00e9l pinchando en \"Ir al recurso\" . Ver\u00e1s una pantalla similar a la siguiente: En la secci\u00f3n de Configuraci\u00f3n , elige Directivas de acceso compartido y crea una nueva directiva llamada, por ejemplo MIOTPOLICY , con permisos de lectura y escritura en Registro, y conexi\u00f3n de servicios y dispositivos. Las pol\u00edticas de lectura y escritura en registro otorgan derechos de acceso al registro de indentidades de Azure. Estos permisos ser\u00e1n utilizados por servicios de back-end para gestionar las identidades de dispositivos, por ejemplo. La pol\u00edtica de conexi\u00f3n de servicio otorga permisos para acceder a endpoints de servicio. Los servicios de back-end podr\u00e1n enviar y recibir mensajes de dispositivos. La pol\u00edtica de conexi\u00f3n de dispositivo otorga permisos para enviar y recibir mensajes usando el IoT Hub . Una vez creada, selecci\u00f3nala y copia la Cadena de conexi\u00f3n principal (clave principal) que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el Hub . Registro de un nuevo dispositivo A continuaci\u00f3n, crearemos una nueva identidad de dispositivo en el Registro de Identidades del hub IoT que acabas de crear. Para ello: En el men\u00fa de navegaci\u00f3n, abre la opci\u00f3n \"Dispositivos de IoT\" y selecciona Nuevo para crear un nuevo dispositivo. Dale el nombre que quieras (por ejemplo MIOTDEVICE), pero recu\u00e9rdalo, y selecciona Guardar . Una vez creado, selecci\u00f3nalo y copia la Cadena de conexi\u00f3n principal que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el dispositivo . Instalaci\u00f3n de el cliente Azure Para instalar el cliente Azure en Linux, usa la orden: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash Tienes m\u00e1s opciones de instalaci\u00f3n en la p\u00e1gina . Una vez instalado, desde tu terminal, ejecuta el comando az para comprobar que la instalaci\u00f3n fue correcta. Deber\u00edas ver una salida similar a esta: az Welcome to Azure CLI! --------------------- Use `az -h` to see available commands or go to https://aka.ms/cli. ... Instala la extensi\u00f3n del cliente para Azure IoT: az extension add --name azure-cli-iot-ext Ingresa en el sistema ejecutando (se te pedir\u00e1 autenticaci\u00f3n en navegador, introduce tus credenciales): az login Para usar el cliente como m\u00e9todo de creaci\u00f3n de un dispositivo, puedes utilizar la siguiente orden: az iot hub device-identity create -n [IoTHub Name] -d [Device ID] Tarea Crea un nuevo dispositivo, distinto al que creaste anteriormente, en tu hub. Despu\u00e9s, obt\u00e9n su cadena de conexi\u00f3n usando la orden az iot hub device-identity show-connection-string -n [IoTHub Name] -d [Device ID] . Comprueba que, efectivamente, la creaci\u00f3n del dispositivo es visible en la plataforma web. Monitorizaci\u00f3n de valores de telemetr\u00eda del dispositivo y eventos Para observar los datos intercambiados entre el dispositivo y el hub IoT desde l\u00ednea de ocmandos, puedes usar la orden: az iot hub monitor-events -n [IoTHub Name] --login 'cadena de conexion' (Ten en cuenta que las comillas simples deben estar presentes). Despliegue de un cliente MQTT en el ESP32 Dir\u00edgete al ejemplo situado en el directorio examples/iothub_client_sample_mqtt . En \u00e9l, vamos a trabajar con cualquiera de los dos dispositivos que has creado en tu Hub . En cualquier caso, muestra su cadena de conexi\u00f3n principal . Deber\u00e1s ver un valor de devoluci\u00f3n de tipo: { \"connectionString\": \"HostName=<azure-iot-hub-name>.azure-devices.net;DeviceId=<azure-iot-device-id>;SharedAccessKey=<base64-encoded-shared-access-key>\" } Deber\u00e1s apuntar (copiar) \u00fanicamente la parte que comienza por HostName=... , hasta el final de la cadena. No incluyas las comillas dobles. Ejecuta make menuconfig . En el men\u00fa Example Configuration , configura las credenciales de acceso a tu red WiFi, as\u00ed como la cadena de conexi\u00f3n que copiaste en la opci\u00f3n IOT Hub Device Connection String . A continuaci\u00f3n, ejecuta la orden de compilaci\u00f3n, flasheado y monitorizaci\u00f3n: make flash monitor En una ventana separada, puedes monitorizar los eventos IoT en tu hub usando su cadena de conexi\u00f3n: az iot hub monitor-events -n [IoTHub Name] --login 'Cadena de conexi\u00f3n primaria' Una vez arrancado y conectado a Internet el dispositivo comenzar\u00e1 a publicar mensajes MQTT. El monitor que has lanzado los mostrar\u00e1 como: { \"event\": { \"origin\": \"<azure-iot-device-id>\", \"payload\": \"{\\\"deviceId\\\":\\\"MIOTDEVICE\\\",\\\"windSpeed\\\":13.00,\\\"temperature\\\":22.00,\\\"humidity\\\":67.00}\" } } Observa que incluye tres valores: velocidad del viento, temperatura y humedad. Tarea Analiza el c\u00f3digo y observa, en la tarea principal, el uso que hace de la API de Azure SDK C, as\u00ed como el punto en el que genera el mensaje MQTT (y sus valores). Tambi\u00e9n es posible enviar mensajes al dispositivo directamente desde l\u00ednea de comandos (observa que estos mensajes se env\u00edan v\u00eda red, no v\u00eda puerto serie, a trav\u00e9s del Hub ). Por tanto, puedes hacerlo desde cualquier punto, no obligatoriamente desde tu PC: az iot device c2d-message send -d [Device Id] -n [IoTHub Name] --data [Data_to_Send] Nota Si todo ha ido bien, en este punto deber\u00edas estar observando cada uno de los mensajes enviados por tu ESP32 al hub desde el monitor. Visualizaci\u00f3n de datos en Microsoft PowerBI En esta parte, el objetivo es visualizar los datos enviados por tu sensor (temperatura, humedad y velocidad del viento, en la herramienta de visualizaci\u00f3n PowerBI de Microsoft. Aunque PowerBI suele utilizarse en entornos de inteligencia de negocio, resulta tambi\u00e9n \u00fatil para reportar datos de cualquier elemento de Azure, incluido el IoT Hub . Nota Necesitar\u00e1s una cuenta de acceso gratuita a PowerBI, que puedes crear con tus credenciales de usuario UCM directamente en la p\u00e1gina del producto . Adici\u00f3n de un grupo de consumidores Los grupos de consumidores proporcionan vistas independientes en la secuencia de eventos que permiten a las aplicaciones y a los servicios de Azure consumir datos de forma independiente desde el mismo punto de conexi\u00f3n del centro de eventos. Vamos a agregar un grupo de consumidores al punto de conexi\u00f3n integrado de tu instancia de IoT Hub que se usar\u00e1 posteriormente para extraer datos del punto de conexi\u00f3n. Para agregar un grupo de consumidores a su centro de IoT, sigue estos pasos: En el portal de Azure, abre tu IoT Hub . En el panel izquierdo, selecciona Puntos de Conexi\u00f3n Integrados , luego Eventos en el panel superior derecho, y escribe un nombre en Grupos de consumidores (por ejemplo, MIOTGROUP ). A continuaci\u00f3n, selecciona Guardar . Creaci\u00f3n, configuraci\u00f3n y ejecuci\u00f3n de un trabajo de Stream Analytics Comencemos creando un trabajo de Stream Analytics . Despu\u00e9s de crear el trabajo, definiremos las entradas, las salidas y la consulta que se usar\u00e1 para recuperar los datos. Creaci\u00f3n de un trabajo de Stream Analytics En el portal de Azure, selecciona Crear un recurso -> Internet de las Cosas -> Stream Analytics Job . Escribe la siguiente informaci\u00f3n para el trabajo: Nombre del trabajo : Nombre que se asigna al trabajo; debe ser \u00fanico (por ejemplo, MIOTJOB ). Grupo de recursos : Usa el mismo grupo de recursos que definiste para el centro de IoT (por ejemplo, MIOTGROUP ). Ubicaci\u00f3n : Usa la misma que para el grupo de recursos. Selecciona Crear . Adici\u00f3n de una entrada al trabajo de Stream Analytics Abre el trabajo de Stream Analytics . En Topolog\u00eda de trabajo , selecciona Entradas . En el panel Entradas , selecciona Agregar entrada de flujo , y a continuaci\u00f3n, selecciona IoT Hub en la lista desplegable. En el panel de la nueva entrada, escribe la siguiente informaci\u00f3n: Alias de entrada : Un alias \u00fanico para la entrada (por ejemplo, MIOTINPUT ). Seleccionar centro de IoT de entre las suscripciones : Selecciona esta opci\u00f3n. Suscripci\u00f3n : Usa la suscripci\u00f3n que has utilizado en el resto de la pr\u00e1ctica. IoT Hub : Selecciona la instancia de tu Hub IoT tal y como has hecho en el resto de la pr\u00e1ctica. Punto de Conexi\u00f3n : Selecciona Mensajer\u00eda . Nombre de la directiva de acceso compartido : Selecciona el nombre de la directiva de acceso compartido que quieras que utilice el trabajo de Stream Analytics para tu centro de IoT. Para esta pr\u00e1ctica, puedes seleccionar service . La directiva service se crea de forma predeterminada en los centros de IoT nuevos y concede permiso de env\u00edo y recepci\u00f3n para los puntos de conexi\u00f3n de la nube que expone el centro de IoT. Clave de directiva de acceso compartido : Se rellena autom\u00e1ticamente en funci\u00f3n del nombre de directiva de acceso compartido. Grupo de consumidores : Selecciona el gruop de consumidores que se cre\u00f3 anteriormente. El resto de campos pueden dejarse en sus valores predeterminados. Finalmente, selecciona Guardar . Adici\u00f3n de una salida al trabajo de Stream Analytics En Topolog\u00eda de trabajo, selecciona Salidas . En el panel Salidas , selecciona Agregar y Power BI . En el panel Power BI: Nueva salida panel , selecciona Autorizar y sigue las indicaciones para iniciar sesi\u00f3n en tu cuenta de Power BI. Una vez que hayas iniciado sesi\u00f3n en Power BI, escribe la siguiente informaci\u00f3n: Alias de salida : alias \u00fanico para la salida, por ejemplo MIOTOUTPUT . \u00c1rea de trabajo de grupo : selecciona el \u00e1rea de trabajo de grupo de destino. Nombre del conjunto de datos : escribe un nombre para el conjunto de datos, por ejemplo MIOTDATASET . Nombre de la tabla : Escribe un nombre de tabla, por ejemplo MIOTTABLE . Modo de autenticaci\u00f3n : Deja la opci\u00f3n predeterminada. Configuraci\u00f3n de la consulta del trabajo de Stream Analytics En Topolog\u00eda de trabajo , selecciona Consulta . Reemplaza [YourInputAlias] por el alias de entrada del trabajo. Reemplaza [YourOutputAlias] por el alias de salida del trabajo. Selecciona Guardar consulta . Ejecuci\u00f3n del trabajo de Stream Analytics En el trabajo de Stream Analytics , selecciona Informaci\u00f3n general y, a continuaci\u00f3n, elige Iniciar->Ahora->Iniciar . Una vez que el trabajo se inicia correctamente, su estado cambia de Detenido a En ejecuci\u00f3n . Creaci\u00f3n y publicaci\u00f3n de un informe de Power BI para visualizar los datos En los pasos siguientes se muestra c\u00f3mo crear y publicar un informe mediante el servicio Power BI: Aseg\u00farate de que la aplicaci\u00f3n (tu ESP32) est\u00e1 ejecut\u00e1ndose. Inicia sesi\u00f3n en Power BI. Selecciona tu \u00e1rea de trabajo ( workspace ). Selecciona Conjunto de datos usando el conjunto de datos que creaste en pasos anteriores (corresponde al que creaste en el momento de crear la salida para el trabajo de Stream Analytics . Para dicho conjunto de datos, selecciona Agregar Informe (el primer icono a la derecha del nombre del conjunto de datos. Crea un gr\u00e1fico de l\u00edneas para mostrar la temperatura en tiempo real en un per\u00edodo determinado. Para ello: En el panel Visualizaciones de la p\u00e1gina de creaci\u00f3n de informes, selecciona el icono de gr\u00e1fico de l\u00edneas para agregar un gr\u00e1fico de l\u00edneas. En el panel Campos , expande la tabla que especific\u00f3 en el momento de crear la salida para el trabajo de Stream Analytics . Arrastra EventEnqueuedUtcTime (Hora UTC de evento en cola) al Eje en el panel Visualizaciones. Arrastra temperature (temperatura) a Valores . Se ha creado un gr\u00e1fico de l\u00edneas. El eje X muestra la fecha y hora en la zona horaria UTC. El eje Y muestra la temperatura del sensor: Tarea A\u00f1ade ahora informaci\u00f3n sobre humedad y velocidad del viento y refresca (actualiza) la visualizaci\u00f3n. Tarea entregable En esta pr\u00e1ctica, simplemente se pide que entregues alguna evidencia (por ejemplo, una captura de pantalla con tu ESP32 femitiendo eventos y una captura simult\u00e1nea de PowerBI mostr\u00e1ndolos) del correcto funcionamiento de los pasos listados. Opcionalmente, se puede a\u00f1adir, como informaci\u00f3n emitida desde el ESP32, valores reales de temperatura obtenidos desde un sensor en el ESP32.","title":"Pr\u00e1ctica 10. Frameworks IoT y Cloud"},{"location":"Subjects/NP2/P10/#practica-10-frameworks-iot-y-cloud","text":"","title":"Pr\u00e1ctica 10. Frameworks IoT y Cloud"},{"location":"Subjects/NP2/P10/#objetivos","text":"La pr\u00e1ctica presenta los pasos esenciales que permiten hacer interactuar un dispositivo (ESP32) con una infraestructura IoT en la nube. Aunque en este caso utilizaremos Microsoft Azure, los pasos tanto en configuraci\u00f3n remota como a nivel de nodo son muy similares a los que deber\u00edas seguir para otras infraestructuras (Amazon AWS, Google IoT Core, Aliyun IoT, Tencent Iot o cualquier otro). La documentaci\u00f3n de IDF proporciona ejemplos detallados para cada uno. El objetivo de la pr\u00e1ctica es desplegar un sistema de monitorizaci\u00f3n remota en Microsoft Power BI, que permita visualizar datos de telemetr\u00eda emitidos v\u00eda MQTT por el dispositivo a trav\u00e9s de un gateway en la nube (llamado en el caso de Azure IoT Hub ).","title":"Objetivos"},{"location":"Subjects/NP2/P10/#introduccion","text":"El SDK ESP Azure IoT es una infraestructura basada en el SDK de Azure par IoT con soporte para C ( azure-iot-sdk-c ) portado sobre ESP-IDF para dar soporte al ESP32. Adem\u00e1s, proporciona un conjunto de ejemplos que permiten observar y simplificar el proceso de configuraci\u00f3n y conexi\u00f3n al framework Azure IoT Hub.","title":"Introducci\u00f3n"},{"location":"Subjects/NP2/P10/#preparacion-del-firmware-en-el-esp32","text":"En la presente pr\u00e1ctica utilizar\u00e1s una placa ESP32 que actuar\u00e1 como cliente ESP32, con un firmware personalizado que implementa la l\u00f3gica de conexi\u00f3n e interacci\u00f3n con Azure. En primer lugar: Configura una instalaci\u00f3n de ESP IDF tal y como has hecho en pr\u00e1cticas anteriores. Si ya la has configurado y es funcional, no es necesario ninguna reinstalaci\u00f3n ni reconfiguraci\u00f3n. En un directorio independiente, clona el repositorio de ESP Azure (f\u00edjate en la opci\u00f3n --recursive , que es imprescindible): git clone --recursive https://github.com/espressif/esp-azure.git","title":"Preparaci\u00f3n del firmware en el ESP32"},{"location":"Subjects/NP2/P10/#configuracion-de-microsoft-azure","text":"Los siguientes pasos requieren el uso de una cuenta creada con Microsoft Azure. Los estudiantes UCM pueden adherirse al programa acad\u00e9mico, que otorga suficiente cr\u00e9dito para realizar este tipo de pr\u00e1cticas. Aseg\u00farate de acceder al portal de MS Azure y utilizar tu usuario y credenciales UCM para ello.","title":"Configuraci\u00f3n de Microsoft Azure"},{"location":"Subjects/NP2/P10/#creacion-de-un-centro-de-iot-iot-hub","text":"En la p\u00e1gina principal de Azure, selecciona la opci\u00f3n \"Crear un Recurso\" (en el men\u00fa de la parte superior izquierda de la pantalla) y a continuaici\u00f3n selecciona IoT Hub en cuadro \"Buscar en Marketplace\". Selecciona Iot Hub en los resultados de la b\u00fasqueda, y a continuaci\u00f3n \"Crear\". En la pesta\u00f1a Aspectos B\u00e1sicos , completa los campos de la siguiente forma: Suscripci\u00f3n : selecciona la suscripci\u00f3n que desees usar (por defecto, deber\u00eda aparecer Azure para estudiantes ). Grupo de recursos : crea un nuevo grupo de recursos seleccionando la opci\u00f3n Crear nuevo , y ot\u00f3rgale el nombre que desees, por ejemplo MIOTGROUP . Regi\u00f3n : selecciona la regi\u00f3n m\u00e1s cercana a ti (por ejemplo, Oeste de Europa ). Nombre : por \u00faltimo, da un nombre al hub , por ejemplo MIOTHUB . Deja los par\u00e1metros por defecto en la pesta\u00f1a Redes , y elige como Nivel de precios F1 en la pesta\u00f1a Administraci\u00f3n . Asigna las etiquetas que desees y finalmente confirma la creaci\u00f3n del Centro de IoT . Si todo ha ido bien, ver\u00e1s un resumen del recurso creado y podr\u00e1s acceder a \u00e9l pinchando en \"Ir al recurso\" . Ver\u00e1s una pantalla similar a la siguiente: En la secci\u00f3n de Configuraci\u00f3n , elige Directivas de acceso compartido y crea una nueva directiva llamada, por ejemplo MIOTPOLICY , con permisos de lectura y escritura en Registro, y conexi\u00f3n de servicios y dispositivos. Las pol\u00edticas de lectura y escritura en registro otorgan derechos de acceso al registro de indentidades de Azure. Estos permisos ser\u00e1n utilizados por servicios de back-end para gestionar las identidades de dispositivos, por ejemplo. La pol\u00edtica de conexi\u00f3n de servicio otorga permisos para acceder a endpoints de servicio. Los servicios de back-end podr\u00e1n enviar y recibir mensajes de dispositivos. La pol\u00edtica de conexi\u00f3n de dispositivo otorga permisos para enviar y recibir mensajes usando el IoT Hub . Una vez creada, selecci\u00f3nala y copia la Cadena de conexi\u00f3n principal (clave principal) que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el Hub .","title":"Creaci\u00f3n de un Centro de IoT (IoT Hub)"},{"location":"Subjects/NP2/P10/#registro-de-un-nuevo-dispositivo","text":"A continuaci\u00f3n, crearemos una nueva identidad de dispositivo en el Registro de Identidades del hub IoT que acabas de crear. Para ello: En el men\u00fa de navegaci\u00f3n, abre la opci\u00f3n \"Dispositivos de IoT\" y selecciona Nuevo para crear un nuevo dispositivo. Dale el nombre que quieras (por ejemplo MIOTDEVICE), pero recu\u00e9rdalo, y selecciona Guardar . Una vez creado, selecci\u00f3nalo y copia la Cadena de conexi\u00f3n principal que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el dispositivo .","title":"Registro de un nuevo dispositivo"},{"location":"Subjects/NP2/P10/#instalacion-de-el-cliente-azure","text":"Para instalar el cliente Azure en Linux, usa la orden: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash Tienes m\u00e1s opciones de instalaci\u00f3n en la p\u00e1gina . Una vez instalado, desde tu terminal, ejecuta el comando az para comprobar que la instalaci\u00f3n fue correcta. Deber\u00edas ver una salida similar a esta: az Welcome to Azure CLI! --------------------- Use `az -h` to see available commands or go to https://aka.ms/cli. ... Instala la extensi\u00f3n del cliente para Azure IoT: az extension add --name azure-cli-iot-ext Ingresa en el sistema ejecutando (se te pedir\u00e1 autenticaci\u00f3n en navegador, introduce tus credenciales): az login Para usar el cliente como m\u00e9todo de creaci\u00f3n de un dispositivo, puedes utilizar la siguiente orden: az iot hub device-identity create -n [IoTHub Name] -d [Device ID] Tarea Crea un nuevo dispositivo, distinto al que creaste anteriormente, en tu hub. Despu\u00e9s, obt\u00e9n su cadena de conexi\u00f3n usando la orden az iot hub device-identity show-connection-string -n [IoTHub Name] -d [Device ID] . Comprueba que, efectivamente, la creaci\u00f3n del dispositivo es visible en la plataforma web.","title":"Instalaci\u00f3n de el cliente Azure"},{"location":"Subjects/NP2/P10/#monitorizacion-de-valores-de-telemetria-del-dispositivo-y-eventos","text":"Para observar los datos intercambiados entre el dispositivo y el hub IoT desde l\u00ednea de ocmandos, puedes usar la orden: az iot hub monitor-events -n [IoTHub Name] --login 'cadena de conexion' (Ten en cuenta que las comillas simples deben estar presentes).","title":"Monitorizaci\u00f3n de valores de telemetr\u00eda del dispositivo y eventos"},{"location":"Subjects/NP2/P10/#despliegue-de-un-cliente-mqtt-en-el-esp32","text":"Dir\u00edgete al ejemplo situado en el directorio examples/iothub_client_sample_mqtt . En \u00e9l, vamos a trabajar con cualquiera de los dos dispositivos que has creado en tu Hub . En cualquier caso, muestra su cadena de conexi\u00f3n principal . Deber\u00e1s ver un valor de devoluci\u00f3n de tipo: { \"connectionString\": \"HostName=<azure-iot-hub-name>.azure-devices.net;DeviceId=<azure-iot-device-id>;SharedAccessKey=<base64-encoded-shared-access-key>\" } Deber\u00e1s apuntar (copiar) \u00fanicamente la parte que comienza por HostName=... , hasta el final de la cadena. No incluyas las comillas dobles. Ejecuta make menuconfig . En el men\u00fa Example Configuration , configura las credenciales de acceso a tu red WiFi, as\u00ed como la cadena de conexi\u00f3n que copiaste en la opci\u00f3n IOT Hub Device Connection String . A continuaci\u00f3n, ejecuta la orden de compilaci\u00f3n, flasheado y monitorizaci\u00f3n: make flash monitor En una ventana separada, puedes monitorizar los eventos IoT en tu hub usando su cadena de conexi\u00f3n: az iot hub monitor-events -n [IoTHub Name] --login 'Cadena de conexi\u00f3n primaria' Una vez arrancado y conectado a Internet el dispositivo comenzar\u00e1 a publicar mensajes MQTT. El monitor que has lanzado los mostrar\u00e1 como: { \"event\": { \"origin\": \"<azure-iot-device-id>\", \"payload\": \"{\\\"deviceId\\\":\\\"MIOTDEVICE\\\",\\\"windSpeed\\\":13.00,\\\"temperature\\\":22.00,\\\"humidity\\\":67.00}\" } } Observa que incluye tres valores: velocidad del viento, temperatura y humedad. Tarea Analiza el c\u00f3digo y observa, en la tarea principal, el uso que hace de la API de Azure SDK C, as\u00ed como el punto en el que genera el mensaje MQTT (y sus valores). Tambi\u00e9n es posible enviar mensajes al dispositivo directamente desde l\u00ednea de comandos (observa que estos mensajes se env\u00edan v\u00eda red, no v\u00eda puerto serie, a trav\u00e9s del Hub ). Por tanto, puedes hacerlo desde cualquier punto, no obligatoriamente desde tu PC: az iot device c2d-message send -d [Device Id] -n [IoTHub Name] --data [Data_to_Send] Nota Si todo ha ido bien, en este punto deber\u00edas estar observando cada uno de los mensajes enviados por tu ESP32 al hub desde el monitor.","title":"Despliegue de un cliente MQTT en el ESP32"},{"location":"Subjects/NP2/P10/#visualizacion-de-datos-en-microsoft-powerbi","text":"En esta parte, el objetivo es visualizar los datos enviados por tu sensor (temperatura, humedad y velocidad del viento, en la herramienta de visualizaci\u00f3n PowerBI de Microsoft. Aunque PowerBI suele utilizarse en entornos de inteligencia de negocio, resulta tambi\u00e9n \u00fatil para reportar datos de cualquier elemento de Azure, incluido el IoT Hub . Nota Necesitar\u00e1s una cuenta de acceso gratuita a PowerBI, que puedes crear con tus credenciales de usuario UCM directamente en la p\u00e1gina del producto .","title":"Visualizaci\u00f3n de datos en Microsoft PowerBI"},{"location":"Subjects/NP2/P10/#adicion-de-un-grupo-de-consumidores","text":"Los grupos de consumidores proporcionan vistas independientes en la secuencia de eventos que permiten a las aplicaciones y a los servicios de Azure consumir datos de forma independiente desde el mismo punto de conexi\u00f3n del centro de eventos. Vamos a agregar un grupo de consumidores al punto de conexi\u00f3n integrado de tu instancia de IoT Hub que se usar\u00e1 posteriormente para extraer datos del punto de conexi\u00f3n. Para agregar un grupo de consumidores a su centro de IoT, sigue estos pasos: En el portal de Azure, abre tu IoT Hub . En el panel izquierdo, selecciona Puntos de Conexi\u00f3n Integrados , luego Eventos en el panel superior derecho, y escribe un nombre en Grupos de consumidores (por ejemplo, MIOTGROUP ). A continuaci\u00f3n, selecciona Guardar .","title":"Adici\u00f3n de un grupo de consumidores"},{"location":"Subjects/NP2/P10/#creacion-configuracion-y-ejecucion-de-un-trabajo-de-stream-analytics","text":"Comencemos creando un trabajo de Stream Analytics . Despu\u00e9s de crear el trabajo, definiremos las entradas, las salidas y la consulta que se usar\u00e1 para recuperar los datos.","title":"Creaci\u00f3n, configuraci\u00f3n y ejecuci\u00f3n de un trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#creacion-de-un-trabajo-de-stream-analytics","text":"En el portal de Azure, selecciona Crear un recurso -> Internet de las Cosas -> Stream Analytics Job . Escribe la siguiente informaci\u00f3n para el trabajo: Nombre del trabajo : Nombre que se asigna al trabajo; debe ser \u00fanico (por ejemplo, MIOTJOB ). Grupo de recursos : Usa el mismo grupo de recursos que definiste para el centro de IoT (por ejemplo, MIOTGROUP ). Ubicaci\u00f3n : Usa la misma que para el grupo de recursos. Selecciona Crear .","title":"Creaci\u00f3n de un trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#adicion-de-una-entrada-al-trabajo-de-stream-analytics","text":"Abre el trabajo de Stream Analytics . En Topolog\u00eda de trabajo , selecciona Entradas . En el panel Entradas , selecciona Agregar entrada de flujo , y a continuaci\u00f3n, selecciona IoT Hub en la lista desplegable. En el panel de la nueva entrada, escribe la siguiente informaci\u00f3n: Alias de entrada : Un alias \u00fanico para la entrada (por ejemplo, MIOTINPUT ). Seleccionar centro de IoT de entre las suscripciones : Selecciona esta opci\u00f3n. Suscripci\u00f3n : Usa la suscripci\u00f3n que has utilizado en el resto de la pr\u00e1ctica. IoT Hub : Selecciona la instancia de tu Hub IoT tal y como has hecho en el resto de la pr\u00e1ctica. Punto de Conexi\u00f3n : Selecciona Mensajer\u00eda . Nombre de la directiva de acceso compartido : Selecciona el nombre de la directiva de acceso compartido que quieras que utilice el trabajo de Stream Analytics para tu centro de IoT. Para esta pr\u00e1ctica, puedes seleccionar service . La directiva service se crea de forma predeterminada en los centros de IoT nuevos y concede permiso de env\u00edo y recepci\u00f3n para los puntos de conexi\u00f3n de la nube que expone el centro de IoT. Clave de directiva de acceso compartido : Se rellena autom\u00e1ticamente en funci\u00f3n del nombre de directiva de acceso compartido. Grupo de consumidores : Selecciona el gruop de consumidores que se cre\u00f3 anteriormente. El resto de campos pueden dejarse en sus valores predeterminados. Finalmente, selecciona Guardar .","title":"Adici\u00f3n de una entrada al trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#adicion-de-una-salida-al-trabajo-de-stream-analytics","text":"En Topolog\u00eda de trabajo, selecciona Salidas . En el panel Salidas , selecciona Agregar y Power BI . En el panel Power BI: Nueva salida panel , selecciona Autorizar y sigue las indicaciones para iniciar sesi\u00f3n en tu cuenta de Power BI. Una vez que hayas iniciado sesi\u00f3n en Power BI, escribe la siguiente informaci\u00f3n: Alias de salida : alias \u00fanico para la salida, por ejemplo MIOTOUTPUT . \u00c1rea de trabajo de grupo : selecciona el \u00e1rea de trabajo de grupo de destino. Nombre del conjunto de datos : escribe un nombre para el conjunto de datos, por ejemplo MIOTDATASET . Nombre de la tabla : Escribe un nombre de tabla, por ejemplo MIOTTABLE . Modo de autenticaci\u00f3n : Deja la opci\u00f3n predeterminada.","title":"Adici\u00f3n de una salida al trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#configuracion-de-la-consulta-del-trabajo-de-stream-analytics","text":"En Topolog\u00eda de trabajo , selecciona Consulta . Reemplaza [YourInputAlias] por el alias de entrada del trabajo. Reemplaza [YourOutputAlias] por el alias de salida del trabajo. Selecciona Guardar consulta .","title":"Configuraci\u00f3n de la consulta del trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#ejecucion-del-trabajo-de-stream-analytics","text":"En el trabajo de Stream Analytics , selecciona Informaci\u00f3n general y, a continuaci\u00f3n, elige Iniciar->Ahora->Iniciar . Una vez que el trabajo se inicia correctamente, su estado cambia de Detenido a En ejecuci\u00f3n .","title":"Ejecuci\u00f3n del trabajo de Stream Analytics"},{"location":"Subjects/NP2/P10/#creacion-y-publicacion-de-un-informe-de-power-bi-para-visualizar-los-datos","text":"En los pasos siguientes se muestra c\u00f3mo crear y publicar un informe mediante el servicio Power BI: Aseg\u00farate de que la aplicaci\u00f3n (tu ESP32) est\u00e1 ejecut\u00e1ndose. Inicia sesi\u00f3n en Power BI. Selecciona tu \u00e1rea de trabajo ( workspace ). Selecciona Conjunto de datos usando el conjunto de datos que creaste en pasos anteriores (corresponde al que creaste en el momento de crear la salida para el trabajo de Stream Analytics . Para dicho conjunto de datos, selecciona Agregar Informe (el primer icono a la derecha del nombre del conjunto de datos. Crea un gr\u00e1fico de l\u00edneas para mostrar la temperatura en tiempo real en un per\u00edodo determinado. Para ello: En el panel Visualizaciones de la p\u00e1gina de creaci\u00f3n de informes, selecciona el icono de gr\u00e1fico de l\u00edneas para agregar un gr\u00e1fico de l\u00edneas. En el panel Campos , expande la tabla que especific\u00f3 en el momento de crear la salida para el trabajo de Stream Analytics . Arrastra EventEnqueuedUtcTime (Hora UTC de evento en cola) al Eje en el panel Visualizaciones. Arrastra temperature (temperatura) a Valores . Se ha creado un gr\u00e1fico de l\u00edneas. El eje X muestra la fecha y hora en la zona horaria UTC. El eje Y muestra la temperatura del sensor: Tarea A\u00f1ade ahora informaci\u00f3n sobre humedad y velocidad del viento y refresca (actualiza) la visualizaci\u00f3n. Tarea entregable En esta pr\u00e1ctica, simplemente se pide que entregues alguna evidencia (por ejemplo, una captura de pantalla con tu ESP32 femitiendo eventos y una captura simult\u00e1nea de PowerBI mostr\u00e1ndolos) del correcto funcionamiento de los pasos listados. Opcionalmente, se puede a\u00f1adir, como informaci\u00f3n emitida desde el ESP32, valores reales de temperatura obtenidos desde un sensor en el ESP32.","title":"Creaci\u00f3n y publicaci\u00f3n de un informe de Power BI para visualizar los datos"},{"location":"Subjects/NP2/P2/","text":"Laboratory 2. TCP and UDP Sockets in ESP-IDF Goals To familiarize with the sockets API in C. To develop basic schemas for client/server systems based con TCP and UDP using C. To be ablo to analyze generated traffic in a TCP and UDP connection via Wireshark. To design a an application-layer protocol to simulate an application based on the client/server paradigm using TCP and UDP to interact between a host and the ESP32 board. Introduction In the previous laboratory, we studied how to develop simple client/server systems using Python, both for TCP and for UDP. In this lab, we will study and develop network components (TCP and UDP clients and servers) that can execute on the ESP32 leveraging the facilities offered by ESP-IDF. Also, we will demonstrate that it is possible to interact clients and servers executing on the virtual machine (programmed via Python) and on the board (using the C sockets API). The C sockets API Funtions for byte ordering As TCP/IP is a universal standard, and it allows for communicating across virtually any platform and architecture, it is necessary to get a byte ordering method so that big-endian and little-endian machines can communicate in a transparent and correct way. To accomplish this requirement, routines are usually provided to reorder and adapt byte ordering. In platforms in which data are already correctly ordered, these functions do not present any special functionality, but anyway, its usage is necessary so that the communication among pairs is correct. Typical functions for data reordering are: htons , htonl , ntohs y ntohl . Their name explains their semantics: host to network (short) host to network (long) , network to host (short) and network to host (long) , converting datatypes short and long from the format used in network transmissions ( network ) to a host representation. Hence, when we send binary data over the network, it will need to be transformed using hton* and upon receiving it, using ntoh* . Data structures Before studyin the sockets API, it is necessary to show the goal of a set of data structures used in all of them. The most important is sockaddr_in , defined as follows: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; The structure in_addr used in sockaddr_in is defined as: struct in_addr { u_long s_addr; }; This one consists on a field of type unsigned long int that contains the IP address associated with the socket. The structure sockaddr_in contains two important fields: sin_family : indicating that the socket belongs to a specific family of protocols (we will use the constant AF_INET for IPv4). sin_port : the port associated to the socket. Basic API socket() Prototype: int socket(int family, int type, int protocol); Description: Creates a communication endpoint and returs a file descriptor to handle it. Parameters: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : Typically 0 (not used in Internet sorckets). Return value: On success, returns a socket descriptor. Returns -1 if error. Details: man socket . bind() Prototype: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Description: Binds a socket to an address specified by addr . Usually, it is necessary to assign a local addres via this function before a TCP socket can receive connections. Parameters: sockfd : socket descriptor (returned by socket ). addr : address to bind (see structure in previous section). addrlen : length (in bytes) of the previous structure. Return value: On success, returns 0. Returns -1 if error. Details: man bind . listen() Prototype: int listen(int sockfd, int backlog); Description: Marks the socket as passive , that is, a socket that will be used to accept incoming connections using accept . Parameters: sockfd : socket descriptor (returned by socket ). backlog : maximum length for the pending connections queue for the socket. Return value: On success, returns 0. Returns -1 if error. Details: man listen . accept() Prototype: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Description: In connection-oriented sockets , extracts the first request for connection from the pending connection queue for the socket , creates a new connected socket and returns its descriptor. Parameters: sockfd : socket descriptor (returned by socket ). addr : pointer to a structure of type sockaddr , whose fields will be filled with the date of the remote socket address. addrlen : size fo the addr structure. Return value: On success, returns 0. Returns -1 if error. Details: man accept . connect() Prototype: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Description: Connects the socket to the address specified by addr . If the socket is UDP, addr will be the only addres to which data will be sent by default, and the only one from which datagrams will be received. For TCP, this call intiates the connection procedure to the specified address. Parameters: sockfd : socket descriptor (returned by socket ). addr : pointer to a sockaddr structure, whose fields indicate the address of the destination connection. addrlen : size of the addr structure. Return value: On success, returns 0. Returns -1 if error. Details: man connect . send() Prototype: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Description: In a connected socket (that is, with a known recepient) transmits messages to a remote socket. Parameters: sockfd : sending socket descriptor. buf : sending buffer where message is stored. len : number of bytes to send. Return value: On success, returns the amount of bytes sent. -1 if error. Details: man send . recv() / recvfrom() Prototype: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Description: Receive messages from a socket , both in connection-oriented and connectionless sockets. recvfrom receives output parameters that store information about the origin of the message. Parameters: sockfd : socket descriptor. buf : reception buffer where the received message will be stored. len : number of bytes to receive. src_addr : address of the remote end of th socket (communication origin). addrlen : src_addr structure size. Valor de retorno: If success, number of received bytes. -1 if error. Details: ( man recv and man recv_from ). close() Prototype: int close(int fd); Description: Closes a socket. Parameters: fd : socket descriptor. Details: man close . Examples In the following, we propose a number of complete examples that illustrate the use of the sockets API in C for the development of client/server systems. For each one, check that, effectively, the use and sequence of application of each call follows the directives in the figure: Task 1.1 Compile ( gcc example.c -o example.x ) and execute ( ./example.x ) each pair of codes and check its correct functionality. Study carefully the use of each routine and how the previous directives are followed. Example: a TCP client #include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error in socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error in connect\\n\"); return 1; } const char* data_to_send = \"Hello, NP2!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Received: '%s'\\n\", buffer); } close(sock); return 0; } Example: a TCP server #include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error in socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error in bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error in listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error in accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Received: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Task 1.2 Reproduce the logic of the previous client/server echo system using UDP. Message construction In order to send messages that encapsulate different types of data in one invocation, you can define a message as follows: typedef struct { int x; int y; } message; Giving value to each field and sending the structure offering the address of the structure: message.x = x; message.y = y; send( socketfd, &message, sizeof( message ), 0 ); Task 1.3 Modify the UDP client to encapsulate and send a structure with different fields (for example, two integers), that will be received by a Python server following the directives of Lab 1. In this case, do not use fields of floating point type (we will see how to do it in the future). The goal of the Task is to demonstrate that a client programmed in C and a server programmed in Python can communicate transparently. Hence, it is not expected from you to develop a complex system. Client/server systems on the ESP32 The reason behind the previous exercises lies on the fact that the TCP/IP stack implemented in ESP-IDF ( Lightweight TCP/IP (lwIP) ) implements almost at 100% that API. Hence, the basic firmware structure for a client/server and its API remains unmodified. In this last section, we will work with two basic examples of implementation of client/server systems TCP and UDP on the ESP32, with the goal of studying its functionality, check its interoperability and perform modifications to adapt them to a hypothetical IoT application. UDP client/server on the ESP32 In this part, you will work with two examples provided within the examples collection from ESP-IDF. Hence, copy in your workspace (out of the main ESP-IDF tree) both examples: Server UDP : examples/protocols/sockets/udp_server/ Cient UDP : examples/protocols/sockets/udp_client/ General structure Observe the codes ( udp_server.c for the server, and udp_client.c for the client). Check that both the basic structure of both components and the invocations to the sockets API match with those seen for the echo system programmed in C. Regarding the main task (function app_main ) observe that it performs a series of invoations to configuration APIs of some subsystems from FreeRTOS, mainly: // Initializes the NVS (Non-volatile storage) by default. ESP_ERROR_CHECK(nvs_flash_init()); // Initializes the ESP-NETIF infrastructure. ESP_ERROR_CHECK(esp_netif_init()); // Creates the main default event loop. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* This funtion configures WiFi or Ethernet, as selected via menunconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , function outside ESP-IDF, that establishes a WiFi or Ethernet connection. The function is blocking, and returns when a connection has been established. The features of the WiFi connection (SSID and password) must be provided via menuconfig . The goal of ESP-NETIF is to provide an abstraction layer on top of the TCP/IP stack, so that it can be migrated without modifications on user codes. You can check the documentation in the oficial webpage . Last, a task is created that executes the server logic (same for the client). Observe that, in the code, the error messages are annotated using the macro ESP_LOGE and the informative ones with ESP_LOGI ; try to follow this mechanism in your codes. Deployment. Option 1 In this case, you will deploy a client on an ESP32 and a server in the other. Obviously, both ESP32s must be part of the same wireless network, so they will be connected to the same access point (at home or at class, you can use a mobile phone for that). Configure the following point in the infrastructure: Configure the SSID and password of the access point via menuconfig before compiling and flashing the code both in the client and in the server. In the server, configure via menuconfig the listen port. Boot first the server node and take note of the proposed IP by the access point; use it in the client to configure the destintation IP of the communication. Do not forget to also configure the destination port using that configured for the server. At this point, you can boot the client and you should be communicating two ESP32 nodes via UDP. Deployment. Option 2 If you only have one node, or just want to test other way of communication between a PC node and an ESP32, you can use any of the system tools: Note Take into account that your PC (that is, the virtual machine) and the ESP32 must be part of the same network. To accomplish it, stop your virtual machine and add a new network interface of type bridge connected to the WiFi interface of your PC. Proceeding this way, you will have an interface with IP within the network, granted directly by your access point. To receive a UDP packge via a port /that is, emulate a UDP server): nc -ul -p 3333 To send a UDP package to a remote IP/port (that is, emulate a client): nc -u IP_REMOTE 3333 In the scripts folder of the examples folder, you can find small client/server UDP Pythhon exmaples that you can also use. TCP client/server on the ESP32 The deployment of the client and server in their TCP version is equivalent to UDP. To receive a TCP package via a port (that is, to emulate a TCP server): nc -l IP -p 3333 To send a TCP package to a remote IP/port (that is, emulate a client): nc IP 3333 Again, you can find TCP Python scripts to use on the scripts folder. Task Experiment with the examples provide in ESP-IDF (client/server TCP and UDP) and execute them on the ESP32. Deliverable task At this point, you will have a set of codes that implement client/server systems both in a host (using Python and/or C) and on the ESP32 (using C and ESP-IDF), and you should have checked their correct functioning. Specifically, you should have developed: A client/server system developed for Lab1, written in Python and implementing a basic application-level protocol proposed by you. Basic C code for the implementation of a client/server echo system, with codes given in this Lab. Basic C/ESP-IDF codes to implement client/servers echo on the ESP32. As a deliverable task, you need to adapt your deliverable of Lab 1 so that both client and server can work on the host (using Python or C) and on the ESP32. You will deliver the developed codes and a short report with screen capture and explanations that demonstrate the correctness of the system.","title":"Laboratory 2. TCP and UDP Sockets in ESP-IDF"},{"location":"Subjects/NP2/P2/#laboratory-2-tcp-and-udp-sockets-in-esp-idf","text":"","title":"Laboratory 2. TCP and UDP Sockets in ESP-IDF"},{"location":"Subjects/NP2/P2/#goals","text":"To familiarize with the sockets API in C. To develop basic schemas for client/server systems based con TCP and UDP using C. To be ablo to analyze generated traffic in a TCP and UDP connection via Wireshark. To design a an application-layer protocol to simulate an application based on the client/server paradigm using TCP and UDP to interact between a host and the ESP32 board.","title":"Goals"},{"location":"Subjects/NP2/P2/#introduction","text":"In the previous laboratory, we studied how to develop simple client/server systems using Python, both for TCP and for UDP. In this lab, we will study and develop network components (TCP and UDP clients and servers) that can execute on the ESP32 leveraging the facilities offered by ESP-IDF. Also, we will demonstrate that it is possible to interact clients and servers executing on the virtual machine (programmed via Python) and on the board (using the C sockets API).","title":"Introduction"},{"location":"Subjects/NP2/P2/#the-c-sockets-api","text":"","title":"The C sockets API"},{"location":"Subjects/NP2/P2/#funtions-for-byte-ordering","text":"As TCP/IP is a universal standard, and it allows for communicating across virtually any platform and architecture, it is necessary to get a byte ordering method so that big-endian and little-endian machines can communicate in a transparent and correct way. To accomplish this requirement, routines are usually provided to reorder and adapt byte ordering. In platforms in which data are already correctly ordered, these functions do not present any special functionality, but anyway, its usage is necessary so that the communication among pairs is correct. Typical functions for data reordering are: htons , htonl , ntohs y ntohl . Their name explains their semantics: host to network (short) host to network (long) , network to host (short) and network to host (long) , converting datatypes short and long from the format used in network transmissions ( network ) to a host representation. Hence, when we send binary data over the network, it will need to be transformed using hton* and upon receiving it, using ntoh* .","title":"Funtions for byte ordering"},{"location":"Subjects/NP2/P2/#data-structures","text":"Before studyin the sockets API, it is necessary to show the goal of a set of data structures used in all of them. The most important is sockaddr_in , defined as follows: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; The structure in_addr used in sockaddr_in is defined as: struct in_addr { u_long s_addr; }; This one consists on a field of type unsigned long int that contains the IP address associated with the socket. The structure sockaddr_in contains two important fields: sin_family : indicating that the socket belongs to a specific family of protocols (we will use the constant AF_INET for IPv4). sin_port : the port associated to the socket.","title":"Data structures"},{"location":"Subjects/NP2/P2/#basic-api","text":"","title":"Basic API"},{"location":"Subjects/NP2/P2/#socket","text":"Prototype: int socket(int family, int type, int protocol); Description: Creates a communication endpoint and returs a file descriptor to handle it. Parameters: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : Typically 0 (not used in Internet sorckets). Return value: On success, returns a socket descriptor. Returns -1 if error. Details: man socket .","title":"socket()"},{"location":"Subjects/NP2/P2/#bind","text":"Prototype: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Description: Binds a socket to an address specified by addr . Usually, it is necessary to assign a local addres via this function before a TCP socket can receive connections. Parameters: sockfd : socket descriptor (returned by socket ). addr : address to bind (see structure in previous section). addrlen : length (in bytes) of the previous structure. Return value: On success, returns 0. Returns -1 if error. Details: man bind .","title":"bind()"},{"location":"Subjects/NP2/P2/#listen","text":"Prototype: int listen(int sockfd, int backlog); Description: Marks the socket as passive , that is, a socket that will be used to accept incoming connections using accept . Parameters: sockfd : socket descriptor (returned by socket ). backlog : maximum length for the pending connections queue for the socket. Return value: On success, returns 0. Returns -1 if error. Details: man listen .","title":"listen()"},{"location":"Subjects/NP2/P2/#accept","text":"Prototype: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Description: In connection-oriented sockets , extracts the first request for connection from the pending connection queue for the socket , creates a new connected socket and returns its descriptor. Parameters: sockfd : socket descriptor (returned by socket ). addr : pointer to a structure of type sockaddr , whose fields will be filled with the date of the remote socket address. addrlen : size fo the addr structure. Return value: On success, returns 0. Returns -1 if error. Details: man accept .","title":"accept()"},{"location":"Subjects/NP2/P2/#connect","text":"Prototype: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Description: Connects the socket to the address specified by addr . If the socket is UDP, addr will be the only addres to which data will be sent by default, and the only one from which datagrams will be received. For TCP, this call intiates the connection procedure to the specified address. Parameters: sockfd : socket descriptor (returned by socket ). addr : pointer to a sockaddr structure, whose fields indicate the address of the destination connection. addrlen : size of the addr structure. Return value: On success, returns 0. Returns -1 if error. Details: man connect .","title":"connect()"},{"location":"Subjects/NP2/P2/#send","text":"Prototype: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Description: In a connected socket (that is, with a known recepient) transmits messages to a remote socket. Parameters: sockfd : sending socket descriptor. buf : sending buffer where message is stored. len : number of bytes to send. Return value: On success, returns the amount of bytes sent. -1 if error. Details: man send .","title":"send()"},{"location":"Subjects/NP2/P2/#recvrecvfrom","text":"Prototype: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Description: Receive messages from a socket , both in connection-oriented and connectionless sockets. recvfrom receives output parameters that store information about the origin of the message. Parameters: sockfd : socket descriptor. buf : reception buffer where the received message will be stored. len : number of bytes to receive. src_addr : address of the remote end of th socket (communication origin). addrlen : src_addr structure size. Valor de retorno: If success, number of received bytes. -1 if error. Details: ( man recv and man recv_from ).","title":"recv()/recvfrom()"},{"location":"Subjects/NP2/P2/#close","text":"Prototype: int close(int fd); Description: Closes a socket. Parameters: fd : socket descriptor. Details: man close .","title":"close()"},{"location":"Subjects/NP2/P2/#examples","text":"In the following, we propose a number of complete examples that illustrate the use of the sockets API in C for the development of client/server systems. For each one, check that, effectively, the use and sequence of application of each call follows the directives in the figure: Task 1.1 Compile ( gcc example.c -o example.x ) and execute ( ./example.x ) each pair of codes and check its correct functionality. Study carefully the use of each routine and how the previous directives are followed.","title":"Examples"},{"location":"Subjects/NP2/P2/#example-a-tcp-client","text":"#include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error in socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error in connect\\n\"); return 1; } const char* data_to_send = \"Hello, NP2!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Received: '%s'\\n\", buffer); } close(sock); return 0; }","title":"Example: a TCP client"},{"location":"Subjects/NP2/P2/#example-a-tcp-server","text":"#include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error in socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error in bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error in listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error in accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Received: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Task 1.2 Reproduce the logic of the previous client/server echo system using UDP.","title":"Example: a TCP server"},{"location":"Subjects/NP2/P2/#message-construction","text":"In order to send messages that encapsulate different types of data in one invocation, you can define a message as follows: typedef struct { int x; int y; } message; Giving value to each field and sending the structure offering the address of the structure: message.x = x; message.y = y; send( socketfd, &message, sizeof( message ), 0 ); Task 1.3 Modify the UDP client to encapsulate and send a structure with different fields (for example, two integers), that will be received by a Python server following the directives of Lab 1. In this case, do not use fields of floating point type (we will see how to do it in the future). The goal of the Task is to demonstrate that a client programmed in C and a server programmed in Python can communicate transparently. Hence, it is not expected from you to develop a complex system.","title":"Message construction"},{"location":"Subjects/NP2/P2/#clientserver-systems-on-the-esp32","text":"The reason behind the previous exercises lies on the fact that the TCP/IP stack implemented in ESP-IDF ( Lightweight TCP/IP (lwIP) ) implements almost at 100% that API. Hence, the basic firmware structure for a client/server and its API remains unmodified. In this last section, we will work with two basic examples of implementation of client/server systems TCP and UDP on the ESP32, with the goal of studying its functionality, check its interoperability and perform modifications to adapt them to a hypothetical IoT application.","title":"Client/server systems on the ESP32"},{"location":"Subjects/NP2/P2/#udp-clientserver-on-the-esp32","text":"In this part, you will work with two examples provided within the examples collection from ESP-IDF. Hence, copy in your workspace (out of the main ESP-IDF tree) both examples: Server UDP : examples/protocols/sockets/udp_server/ Cient UDP : examples/protocols/sockets/udp_client/","title":"UDP client/server on the ESP32"},{"location":"Subjects/NP2/P2/#general-structure","text":"Observe the codes ( udp_server.c for the server, and udp_client.c for the client). Check that both the basic structure of both components and the invocations to the sockets API match with those seen for the echo system programmed in C. Regarding the main task (function app_main ) observe that it performs a series of invoations to configuration APIs of some subsystems from FreeRTOS, mainly: // Initializes the NVS (Non-volatile storage) by default. ESP_ERROR_CHECK(nvs_flash_init()); // Initializes the ESP-NETIF infrastructure. ESP_ERROR_CHECK(esp_netif_init()); // Creates the main default event loop. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* This funtion configures WiFi or Ethernet, as selected via menunconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , function outside ESP-IDF, that establishes a WiFi or Ethernet connection. The function is blocking, and returns when a connection has been established. The features of the WiFi connection (SSID and password) must be provided via menuconfig . The goal of ESP-NETIF is to provide an abstraction layer on top of the TCP/IP stack, so that it can be migrated without modifications on user codes. You can check the documentation in the oficial webpage . Last, a task is created that executes the server logic (same for the client). Observe that, in the code, the error messages are annotated using the macro ESP_LOGE and the informative ones with ESP_LOGI ; try to follow this mechanism in your codes.","title":"General structure"},{"location":"Subjects/NP2/P2/#deployment-option-1","text":"In this case, you will deploy a client on an ESP32 and a server in the other. Obviously, both ESP32s must be part of the same wireless network, so they will be connected to the same access point (at home or at class, you can use a mobile phone for that). Configure the following point in the infrastructure: Configure the SSID and password of the access point via menuconfig before compiling and flashing the code both in the client and in the server. In the server, configure via menuconfig the listen port. Boot first the server node and take note of the proposed IP by the access point; use it in the client to configure the destintation IP of the communication. Do not forget to also configure the destination port using that configured for the server. At this point, you can boot the client and you should be communicating two ESP32 nodes via UDP.","title":"Deployment. Option 1"},{"location":"Subjects/NP2/P2/#deployment-option-2","text":"If you only have one node, or just want to test other way of communication between a PC node and an ESP32, you can use any of the system tools: Note Take into account that your PC (that is, the virtual machine) and the ESP32 must be part of the same network. To accomplish it, stop your virtual machine and add a new network interface of type bridge connected to the WiFi interface of your PC. Proceeding this way, you will have an interface with IP within the network, granted directly by your access point. To receive a UDP packge via a port /that is, emulate a UDP server): nc -ul -p 3333 To send a UDP package to a remote IP/port (that is, emulate a client): nc -u IP_REMOTE 3333 In the scripts folder of the examples folder, you can find small client/server UDP Pythhon exmaples that you can also use.","title":"Deployment. Option 2"},{"location":"Subjects/NP2/P2/#tcp-clientserver-on-the-esp32","text":"The deployment of the client and server in their TCP version is equivalent to UDP. To receive a TCP package via a port (that is, to emulate a TCP server): nc -l IP -p 3333 To send a TCP package to a remote IP/port (that is, emulate a client): nc IP 3333 Again, you can find TCP Python scripts to use on the scripts folder. Task Experiment with the examples provide in ESP-IDF (client/server TCP and UDP) and execute them on the ESP32. Deliverable task At this point, you will have a set of codes that implement client/server systems both in a host (using Python and/or C) and on the ESP32 (using C and ESP-IDF), and you should have checked their correct functioning. Specifically, you should have developed: A client/server system developed for Lab1, written in Python and implementing a basic application-level protocol proposed by you. Basic C code for the implementation of a client/server echo system, with codes given in this Lab. Basic C/ESP-IDF codes to implement client/servers echo on the ESP32. As a deliverable task, you need to adapt your deliverable of Lab 1 so that both client and server can work on the host (using Python or C) and on the ESP32. You will deliver the developed codes and a short report with screen capture and explanations that demonstrate the correctness of the system.","title":"TCP client/server on the ESP32"},{"location":"Subjects/NP2/P3/","text":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS) Objetivos Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS). Contenido del paquete proporcionado y setup b\u00e1sico El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl24 Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n. Cliente/servidor TLS. Ejemplo b\u00e1sico en host Servidor TLS Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c . Cabeceras y constantes El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 . Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n. Cliente/servidor DTLS. Ejemplo b\u00e1sico en host El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos. TLS en el ESP32. El componente ESP-TLS ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla,y se basa en el uso de cuatro funciones b\u00e1sicas: Establecimiento de conexi\u00f3n TLS ( esp_tls_conn_new() ) Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n. Destrucci\u00f3n de conexi\u00f3n TLS ( esp_tls_conn_delete() ) void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n. Escritura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo. Lectura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n. Estructura b\u00e1sica de un cliente TCP usando ESP-IDF Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente (puedes compararlo con tus clientes TCP desarrollados en sesiones anteriores). La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Observa como, efectivamente, el c\u00f3digo del cliente se simplifica en gran medida con respecto a tu cliente TCP original. Toma el c\u00f3digo del proyecto que utilizaste para desarrollar tu cliente TCP original y, siguiendo las anteriores directivas, adapta la \u00fanica tarea a crear (por ejemplo, puede recibir el nombre tls_client_task ) para que realice un env\u00edo y recepci\u00f3n de datos (una cadena) al servidor TLS que probaste en el host . Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo . Note Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Adapta tu sistema cliente/servidor TCP desarrollado en la anterior pr\u00e1ctica para que se ejecute sobre el binomio host /ESP32 utlizando TLS. Entrega el c\u00f3digo generado junto con una captura de tr\u00e1fico que demuestre su correcto funcionamiento.","title":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS)"},{"location":"Subjects/NP2/P3/#practica-3-seguridad-tls-y-dtls","text":"","title":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS)"},{"location":"Subjects/NP2/P3/#objetivos","text":"Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS).","title":"Objetivos"},{"location":"Subjects/NP2/P3/#contenido-del-paquete-proporcionado-y-setup-basico","text":"El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl24 Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n.","title":"Contenido del paquete proporcionado y setup b\u00e1sico"},{"location":"Subjects/NP2/P3/#clienteservidor-tls-ejemplo-basico-en-host","text":"","title":"Cliente/servidor TLS. Ejemplo b\u00e1sico en host"},{"location":"Subjects/NP2/P3/#servidor-tls","text":"Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c .","title":"Servidor TLS"},{"location":"Subjects/NP2/P3/#cabeceras-y-constantes","text":"El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 .","title":"Cabeceras y constantes"},{"location":"Subjects/NP2/P3/#objetos-basicos-wolfssl-contexto-y-objeto-ssl","text":"Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n.","title":"Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL"},{"location":"Subjects/NP2/P3/#clienteservidor-dtls-ejemplo-basico-en-host","text":"El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos.","title":"Cliente/servidor DTLS. Ejemplo b\u00e1sico en host"},{"location":"Subjects/NP2/P3/#tls-en-el-esp32-el-componente-esp-tls","text":"ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla,y se basa en el uso de cuatro funciones b\u00e1sicas:","title":"TLS en el ESP32. El componente ESP-TLS"},{"location":"Subjects/NP2/P3/#establecimiento-de-conexion-tls-esp_tls_conn_new","text":"Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n.","title":"Establecimiento de conexi\u00f3n TLS (esp_tls_conn_new())"},{"location":"Subjects/NP2/P3/#destruccion-de-conexion-tls-esp_tls_conn_delete","text":"void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n.","title":"Destrucci\u00f3n de conexi\u00f3n TLS (esp_tls_conn_delete())"},{"location":"Subjects/NP2/P3/#escritura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo.","title":"Escritura de datos (esp_tls_conn_read())"},{"location":"Subjects/NP2/P3/#lectura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n.","title":"Lectura de datos (esp_tls_conn_read())"},{"location":"Subjects/NP2/P3/#estructura-basica-de-un-cliente-tcp-usando-esp-idf","text":"Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente (puedes compararlo con tus clientes TCP desarrollados en sesiones anteriores). La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Observa como, efectivamente, el c\u00f3digo del cliente se simplifica en gran medida con respecto a tu cliente TCP original. Toma el c\u00f3digo del proyecto que utilizaste para desarrollar tu cliente TCP original y, siguiendo las anteriores directivas, adapta la \u00fanica tarea a crear (por ejemplo, puede recibir el nombre tls_client_task ) para que realice un env\u00edo y recepci\u00f3n de datos (una cadena) al servidor TLS que probaste en el host . Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo . Note Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Adapta tu sistema cliente/servidor TCP desarrollado en la anterior pr\u00e1ctica para que se ejecute sobre el binomio host /ESP32 utlizando TLS. Entrega el c\u00f3digo generado junto con una captura de tr\u00e1fico que demuestre su correcto funcionamiento.","title":"Estructura b\u00e1sica de un cliente TCP usando ESP-IDF"},{"location":"Subjects/NP2/P4/","text":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets Objetivos Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets . Estudar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar mecanismos de mantenimiento y publicaci\u00f3n de estado a clientes conectados, t\u00edpicos en un entorno IoT. Estudiar el componente websockets client en ESP-IDF, y desarrollar un firmware b\u00e1sico que interact\u00fae con un servidor Python. Introducir la gesti\u00f3n de objetos JSON en ESP-IDF. Los ficheros necesarios para completar la pr\u00e1ctica pueden descargarse aqu\u00ed . Ejemplo b\u00e1sico: sistema cliente/servidor usando Websockets en Python (\u00b4client1.py, server1.py`) En primer lugar, introducimos el uso del m\u00f3dulo Python websockets , que proporciona toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor utilizando websockets . El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste, tal y como hemos visto en otras pr\u00e1cticas. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea entregable Ejecuta el servidor en una terminal de tu m\u00e1quina virtual, y a continuaci\u00f3n el cliente en otra. Analiza el tr\u00e1fico intercambiado y responde a las siguientes preguntas: \u00bfEn qu\u00e9 protocolo de capa de transporte se basa la comunicaci\u00f3n v\u00eda Websockets? En la fase de handshake , \u00bfqu\u00e9 peticiones HTTP se intercambian? Analiza sus emisores y destinatarios, e investiga el cometido principal de cada uno de los campos de sus encabezados (f\u00edjate principalmente en el campo Upgrade y los campos espec\u00edficos para Websockets). En la fase de intercambio de datos, \u00bfqu\u00e9 opcode se especifica en el encabezado de cada paquete? \u00bfPor qu\u00e9? \u00bfSe env\u00edan los datos en claro o cifrados? \u00bfQu\u00e9 opcode se a\u00f1ade en los mensajes de cierre de conexi\u00f3n? Interactuando con un navegador web ( client_for_web.html , server_for_web.py ) Aunque fuera del inter\u00e9s de esta pr\u00e1ctica, es conveniente observar una de las ventajas de websockets : el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, y observarlo a trav\u00e9s de un navegador web convencional (la mayor\u00eda de navegadores modernos soportan websockets a trav\u00e9s de scripts Javascript ). En este caso, simplemente observa la interacci\u00f3n de un servidor websocket que env\u00eda mensajes que incluyen la hora actual separados un n\u00famero aleatorio de tiempo entre ellos: #!/usr/bin/env python # WS server that sends messages at random intervals import asyncio import datetime import random import websockets async def time(websocket, path): while True: now = datetime.datetime.utcnow().isoformat() + \"Z\" await websocket.send(now) await asyncio.sleep(random.random() * 3) start_server = websockets.serve(time, \"127.0.0.1\", 5678) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Con un cliente (una p\u00e1gina HTML) que establece la conexi\u00f3n v\u00eda websockets , y muestra en la misma un elemento de texto con la marca de tiempo recibida tras la recepci\u00f3n de cada mensaje: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> </head> <body> <script> var ws = new WebSocket(\"ws://127.0.0.1:5678/\"), messages = document.createElement('ul'); ws.onmessage = function (event) { var messages = document.getElementsByTagName('ul')[0], message = document.createElement('li'), content = document.createTextNode(event.data); message.appendChild(content); messages.appendChild(message); }; document.body.appendChild(messages); </script> </body> </html> Tarea Ejecuta el servidor en tu m\u00e1quina virtual y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con un navegador. Observa como la p\u00e1gina se actualiza a medida que recibe mensajes a trav\u00e9s del socket. Si quieres, puedes observar el intercambio de mensajes. \u00bfQu\u00e9 ocurre si, en otra pesta\u00f1a, vuelves a abrir la p\u00e1gina cliente? Un ejemplo m\u00e1s complejo: sincronizaci\u00f3n entre m\u00faltiples clientes ( server2.py , client.html ) Un servidor websocket puede recibir eventos desde distintos clientes, procesarlos para, por ejemplo, mantener actualizado un estado a nivel de aplicaci\u00f3n, y sincronizar dicho estado entre todos los clientes conectados, envi\u00e1ndoles mensajes de forma as\u00edncrona a trav\u00e9s del socket bidireccional, a modo de \"notificaciones push \". A continuaci\u00f3n, se muestra el c\u00f3digo de un servidor que mantiene dos tipos de informaci\u00f3n de estado siempre actualizada: el valor de un contador ( STATE ), que puede ser modificado por los clientes conectados sumando o restando uno a su valor a trav\u00e9s de mensajes enviados por el socket ; y el n\u00famero de clientes conectados ( USERS ). #!/usr/bin/env python import asyncio import json import logging import websockets logging.basicConfig() STATE = {\"value\": 0} USERS = set() def state_event(): return json.dumps({\"type\": \"state\", **STATE}) def users_event(): return json.dumps({\"type\": \"users\", \"count\": len(USERS)}) async def notify_state(): if USERS: # asyncio.wait doesn't accept an empty list message = state_event() await asyncio.wait([user.send(message) for user in USERS]) async def notify_users(): if USERS: # asyncio.wait doesn't accept an empty list message = users_event() await asyncio.wait([user.send(message) for user in USERS]) async def register(websocket): USERS.add(websocket) await notify_users() async def unregister(websocket): USERS.remove(websocket) await notify_users() async def counter(websocket, path): # register(websocket) sends user_event() to websocket await register(websocket) try: await websocket.send(state_event()) async for message in websocket: data = json.loads(message) if data[\"action\"] == \"minus\": STATE[\"value\"] -= 1 await notify_state() elif data[\"action\"] == \"plus\": STATE[\"value\"] += 1 await notify_state() else: logging.error(\"unsupported event: {}\", data) finally: await unregister(websocket) start_server = websockets.serve(counter, \"localhost\", 6789) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Observa el c\u00f3digo del servidor. El manejador counter procesa cada conexi\u00f3n entrante, registrando a su entrada a un nuevo cliente en el sistema ( register ) y desregistr\u00e1ndolo antes de finalizar ( unregister ). Ante cada registro o desregistro, se notifica a los usuarios este hecho, enviando a cada cliente un peque\u00f1o texto en formato JSON cuyo contenido es: {\"type\": \"users\", \"count\": usuarios} Es decir, un mensaje con dos campos (veremos JSON en la pr\u00f3xima pr\u00e1ctica): campo type , con valor fijo users , y campo count , con un valor entero que indica el n\u00famero de clientes conectados. A continuaci\u00f3n, para cada mensaje recibido a trav\u00e9s del socket, \u00e9ste se procesa, esperando tambi\u00e9n un fichero JSON con la acci\u00f3n que el cliente solicita (sumar o restar 1 al contador), por ejemplo: {\"action\": \"minus\"} o {\"action\": \"plus\"} En funci\u00f3n de la acci\u00f3n solicitada, el servidor actualiza el valor de STATE , y env\u00eda (rutina notify_state ) dicho valor actualizado a TODOS los clientes conectados mediante un peque\u00f1o mensaje de texto en formato JSON: {\"type\": \"state\", \"value\": VALOR} La parte cliente sigue la misma filosof\u00eda, utilizando de nuevo el navegador como plataforma para visualizar la interacci\u00f3n con el cliente. El c\u00f3digo HTML que puedes abrir en tu navegador es el siguiente: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> <style type=\"text/css\"> body { font-family: \"Courier New\", sans-serif; text-align: center; } .buttons { font-size: 4em; display: flex; justify-content: center; } .button, .value { line-height: 1; padding: 2rem; margin: 2rem; border: medium solid; min-height: 1em; min-width: 1em; } .button { cursor: pointer; user-select: none; } .minus { color: red; } .plus { color: green; } .value { min-width: 2em; } .state { font-size: 2em; } </style> </head> <body> <div class=\"buttons\"> <div class=\"minus button\">-</div> <div class=\"value\">?</div> <div class=\"plus button\">+</div> </div> <div class=\"state\"> <span class=\"users\">?</span> online </div> <script> var minus = document.querySelector('.minus'), plus = document.querySelector('.plus'), value = document.querySelector('.value'), users = document.querySelector('.users'), websocket = new WebSocket(\"ws://127.0.0.1:6789/\"); minus.onclick = function (event) { websocket.send(JSON.stringify({action: 'minus'})); } plus.onclick = function (event) { websocket.send(JSON.stringify({action: 'plus'})); } websocket.onmessage = function (event) { data = JSON.parse(event.data); switch (data.type) { case 'state': value.textContent = data.value; break; case 'users': users.textContent = ( data.count.toString() + \" user\" + (data.count == 1 ? \"\" : \"s\")); break; default: console.error( \"unsupported event\", data); } }; </script> </body> </html> Observa c\u00f3mo el script env\u00eda mensajes de suma o resta en formato JSON acorde al esperado por el servidor, y procesa los mensajes de entrada actualizando la informaci\u00f3n mostrada en pantalla recibida acerca del valor del contador actualizado y n\u00famero de usuarios. Tarea Ejecuta el servidor en tu m\u00e1quina virtual, y m\u00faltiples clientes en distintas ventanas/pesta\u00f1as del navegador (con ventanas lo ver\u00e1s mejor). Interact\u00faa desde un cliente aumentando o reduciendo el valor del contador, y observa c\u00f3mo dicho valor es actualizado (a trav\u00e9s del servidor) en el resto de clientes abiertos. Conecta y desconecta nuevos clientes y observa tambi\u00e9n como el campo correspondiente en la p\u00e1gina web se actualiza correctamente. Si quieres, puedes analizar el tr\u00e1fico Websockets generado v\u00eda Wireshark. Websockets en el ESP32 El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9sd el componente websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente websocket client ofrece soporte para el protocolo websocket sobre TCP y tambi\u00e9n, opcionalmente, sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, sin intercambio de datos. WEBSOCKET_EVENT_DISCONNECTED : se emite en el instante de la desconexi\u00f3n entre cliente y servidor. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que accarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: const char * data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DISCONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256*data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( event_data ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:123\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos *Websocket * esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos. Ejemplo b\u00e1sico: cliente echo Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo examples/protocols/websockets . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (disponible en ws://websockets.org ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo? Ejercicio entregable: Comunicaci\u00f3n as\u00edncrona El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con el servidor Python que se prob\u00f3 en la secci\u00f3n anterior, y que implementaba comunicaci\u00f3n bidireccional para mantener y difundir el estado interno (contador y n\u00famero de clientes conectados) entre todos los clientes conectados. Para ello, se pide modificar el ejemplo de cliente echo para que: El cliente conecte con el servidor Python especificando su IP y puerto. El cliente sea cien por cien pasivo, es decir, no env\u00ede nunca mensajes al servidor. La funci\u00f3n de manejo de paquetes recibidos trate de forma especial el tipo de mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos tipos de mensajes de texto: Mensajes de estado: {\"type\": \"users\", \"count\": usuarios} Mensajes de usuarios: {\"type\": \"state\", \"value\": VALOR} Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con una representaci\u00f3n JSON de la informaci\u00f3n. Para tratarla desde ESP-IDF, puedes hacer uso del componente cJSON del framework . Por ejemplo, para tratar un mensaje de entrada de tipo \"state\", podr\u00edamos a\u00f1adir la siguiente secuencia de c\u00f3digo en nuestro manejador: #include \"cJSON.h\" // ... if( data->op_code == 1 ) { // Text frame only. cJSON *root = cJSON_Parse((char*)data->data_ptr); char *type = cJSON_GetObjectItem(root,\"type\")->valuestring; ESP_LOGI(TAG, \"type=%s\",type); int field = 0; if( strcmp( type, \"state\" ) == 0) { field = cJSON_GetObjectItem(root,\"value\")->valueint; ESP_LOGI(TAG, \"value=%d\",field); } } Tarea entregable Modifica el firmware de ejemplo websockets para que pueda comunicarse en modo lectura con el servidor Python que mantiene y publicita estado, cuyo c\u00f3digo se te proporciona. El programa ESP-IDF, al menos, mostar\u00e1 por pantalla un mensaje con los datos asociados cada vez que se reciban paquetes de tipo texto ( state o users ). Tambi\u00e9n mostrar\u00e1 un mensaje cada vez que el servidor env\u00ede un mensaje de tipo ping o pong (para ello, consulta el RFC que describe el protocolo para determinar el opcode asociado). Para comprobar el funcionamiento de la soluci\u00f3n, arranca el servidor y al menos dos clientes web. Cuando arranques el ESP32, ambos deber\u00e1n incrementar el n\u00famero de clientes reportado, en respuesta al mensaje enviado por el servidor. Cuando cualquiera de los clientes web incremente el valor del contador, el ESP32 recibir\u00e1 un mensaje con el valor actualizado, del mismo modo que cuando cierres uno de los navegadores web. Tarea opcional Modifica el c\u00f3digo para que el cliente, peri\u00f3dicamente, env\u00ede un mensaje de petici\u00f3n de suma o resta siguiendo las especificaciones y tipos de mensaje que se explicaron anteriormente.","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets"},{"location":"Subjects/NP2/P4/#practica-4-protocolos-basicos-de-capa-de-aplicacion-websockets","text":"","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets"},{"location":"Subjects/NP2/P4/#objetivos","text":"Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets . Estudar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar mecanismos de mantenimiento y publicaci\u00f3n de estado a clientes conectados, t\u00edpicos en un entorno IoT. Estudiar el componente websockets client en ESP-IDF, y desarrollar un firmware b\u00e1sico que interact\u00fae con un servidor Python. Introducir la gesti\u00f3n de objetos JSON en ESP-IDF. Los ficheros necesarios para completar la pr\u00e1ctica pueden descargarse aqu\u00ed .","title":"Objetivos"},{"location":"Subjects/NP2/P4/#ejemplo-basico-sistema-clienteservidor-usando-websockets-en-python-client1py-server1py","text":"En primer lugar, introducimos el uso del m\u00f3dulo Python websockets , que proporciona toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor utilizando websockets . El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste, tal y como hemos visto en otras pr\u00e1cticas. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea entregable Ejecuta el servidor en una terminal de tu m\u00e1quina virtual, y a continuaci\u00f3n el cliente en otra. Analiza el tr\u00e1fico intercambiado y responde a las siguientes preguntas: \u00bfEn qu\u00e9 protocolo de capa de transporte se basa la comunicaci\u00f3n v\u00eda Websockets? En la fase de handshake , \u00bfqu\u00e9 peticiones HTTP se intercambian? Analiza sus emisores y destinatarios, e investiga el cometido principal de cada uno de los campos de sus encabezados (f\u00edjate principalmente en el campo Upgrade y los campos espec\u00edficos para Websockets). En la fase de intercambio de datos, \u00bfqu\u00e9 opcode se especifica en el encabezado de cada paquete? \u00bfPor qu\u00e9? \u00bfSe env\u00edan los datos en claro o cifrados? \u00bfQu\u00e9 opcode se a\u00f1ade en los mensajes de cierre de conexi\u00f3n?","title":"Ejemplo b\u00e1sico: sistema cliente/servidor usando Websockets en Python (\u00b4client1.py, server1.py`)"},{"location":"Subjects/NP2/P4/#interactuando-con-un-navegador-web-client_for_webhtml-server_for_webpy","text":"Aunque fuera del inter\u00e9s de esta pr\u00e1ctica, es conveniente observar una de las ventajas de websockets : el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, y observarlo a trav\u00e9s de un navegador web convencional (la mayor\u00eda de navegadores modernos soportan websockets a trav\u00e9s de scripts Javascript ). En este caso, simplemente observa la interacci\u00f3n de un servidor websocket que env\u00eda mensajes que incluyen la hora actual separados un n\u00famero aleatorio de tiempo entre ellos: #!/usr/bin/env python # WS server that sends messages at random intervals import asyncio import datetime import random import websockets async def time(websocket, path): while True: now = datetime.datetime.utcnow().isoformat() + \"Z\" await websocket.send(now) await asyncio.sleep(random.random() * 3) start_server = websockets.serve(time, \"127.0.0.1\", 5678) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Con un cliente (una p\u00e1gina HTML) que establece la conexi\u00f3n v\u00eda websockets , y muestra en la misma un elemento de texto con la marca de tiempo recibida tras la recepci\u00f3n de cada mensaje: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> </head> <body> <script> var ws = new WebSocket(\"ws://127.0.0.1:5678/\"), messages = document.createElement('ul'); ws.onmessage = function (event) { var messages = document.getElementsByTagName('ul')[0], message = document.createElement('li'), content = document.createTextNode(event.data); message.appendChild(content); messages.appendChild(message); }; document.body.appendChild(messages); </script> </body> </html> Tarea Ejecuta el servidor en tu m\u00e1quina virtual y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con un navegador. Observa como la p\u00e1gina se actualiza a medida que recibe mensajes a trav\u00e9s del socket. Si quieres, puedes observar el intercambio de mensajes. \u00bfQu\u00e9 ocurre si, en otra pesta\u00f1a, vuelves a abrir la p\u00e1gina cliente?","title":"Interactuando con un navegador web (client_for_web.html, server_for_web.py)"},{"location":"Subjects/NP2/P4/#un-ejemplo-mas-complejo-sincronizacion-entre-multiples-clientes-server2py-clienthtml","text":"Un servidor websocket puede recibir eventos desde distintos clientes, procesarlos para, por ejemplo, mantener actualizado un estado a nivel de aplicaci\u00f3n, y sincronizar dicho estado entre todos los clientes conectados, envi\u00e1ndoles mensajes de forma as\u00edncrona a trav\u00e9s del socket bidireccional, a modo de \"notificaciones push \". A continuaci\u00f3n, se muestra el c\u00f3digo de un servidor que mantiene dos tipos de informaci\u00f3n de estado siempre actualizada: el valor de un contador ( STATE ), que puede ser modificado por los clientes conectados sumando o restando uno a su valor a trav\u00e9s de mensajes enviados por el socket ; y el n\u00famero de clientes conectados ( USERS ). #!/usr/bin/env python import asyncio import json import logging import websockets logging.basicConfig() STATE = {\"value\": 0} USERS = set() def state_event(): return json.dumps({\"type\": \"state\", **STATE}) def users_event(): return json.dumps({\"type\": \"users\", \"count\": len(USERS)}) async def notify_state(): if USERS: # asyncio.wait doesn't accept an empty list message = state_event() await asyncio.wait([user.send(message) for user in USERS]) async def notify_users(): if USERS: # asyncio.wait doesn't accept an empty list message = users_event() await asyncio.wait([user.send(message) for user in USERS]) async def register(websocket): USERS.add(websocket) await notify_users() async def unregister(websocket): USERS.remove(websocket) await notify_users() async def counter(websocket, path): # register(websocket) sends user_event() to websocket await register(websocket) try: await websocket.send(state_event()) async for message in websocket: data = json.loads(message) if data[\"action\"] == \"minus\": STATE[\"value\"] -= 1 await notify_state() elif data[\"action\"] == \"plus\": STATE[\"value\"] += 1 await notify_state() else: logging.error(\"unsupported event: {}\", data) finally: await unregister(websocket) start_server = websockets.serve(counter, \"localhost\", 6789) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Observa el c\u00f3digo del servidor. El manejador counter procesa cada conexi\u00f3n entrante, registrando a su entrada a un nuevo cliente en el sistema ( register ) y desregistr\u00e1ndolo antes de finalizar ( unregister ). Ante cada registro o desregistro, se notifica a los usuarios este hecho, enviando a cada cliente un peque\u00f1o texto en formato JSON cuyo contenido es: {\"type\": \"users\", \"count\": usuarios} Es decir, un mensaje con dos campos (veremos JSON en la pr\u00f3xima pr\u00e1ctica): campo type , con valor fijo users , y campo count , con un valor entero que indica el n\u00famero de clientes conectados. A continuaci\u00f3n, para cada mensaje recibido a trav\u00e9s del socket, \u00e9ste se procesa, esperando tambi\u00e9n un fichero JSON con la acci\u00f3n que el cliente solicita (sumar o restar 1 al contador), por ejemplo: {\"action\": \"minus\"} o {\"action\": \"plus\"} En funci\u00f3n de la acci\u00f3n solicitada, el servidor actualiza el valor de STATE , y env\u00eda (rutina notify_state ) dicho valor actualizado a TODOS los clientes conectados mediante un peque\u00f1o mensaje de texto en formato JSON: {\"type\": \"state\", \"value\": VALOR} La parte cliente sigue la misma filosof\u00eda, utilizando de nuevo el navegador como plataforma para visualizar la interacci\u00f3n con el cliente. El c\u00f3digo HTML que puedes abrir en tu navegador es el siguiente: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> <style type=\"text/css\"> body { font-family: \"Courier New\", sans-serif; text-align: center; } .buttons { font-size: 4em; display: flex; justify-content: center; } .button, .value { line-height: 1; padding: 2rem; margin: 2rem; border: medium solid; min-height: 1em; min-width: 1em; } .button { cursor: pointer; user-select: none; } .minus { color: red; } .plus { color: green; } .value { min-width: 2em; } .state { font-size: 2em; } </style> </head> <body> <div class=\"buttons\"> <div class=\"minus button\">-</div> <div class=\"value\">?</div> <div class=\"plus button\">+</div> </div> <div class=\"state\"> <span class=\"users\">?</span> online </div> <script> var minus = document.querySelector('.minus'), plus = document.querySelector('.plus'), value = document.querySelector('.value'), users = document.querySelector('.users'), websocket = new WebSocket(\"ws://127.0.0.1:6789/\"); minus.onclick = function (event) { websocket.send(JSON.stringify({action: 'minus'})); } plus.onclick = function (event) { websocket.send(JSON.stringify({action: 'plus'})); } websocket.onmessage = function (event) { data = JSON.parse(event.data); switch (data.type) { case 'state': value.textContent = data.value; break; case 'users': users.textContent = ( data.count.toString() + \" user\" + (data.count == 1 ? \"\" : \"s\")); break; default: console.error( \"unsupported event\", data); } }; </script> </body> </html> Observa c\u00f3mo el script env\u00eda mensajes de suma o resta en formato JSON acorde al esperado por el servidor, y procesa los mensajes de entrada actualizando la informaci\u00f3n mostrada en pantalla recibida acerca del valor del contador actualizado y n\u00famero de usuarios. Tarea Ejecuta el servidor en tu m\u00e1quina virtual, y m\u00faltiples clientes en distintas ventanas/pesta\u00f1as del navegador (con ventanas lo ver\u00e1s mejor). Interact\u00faa desde un cliente aumentando o reduciendo el valor del contador, y observa c\u00f3mo dicho valor es actualizado (a trav\u00e9s del servidor) en el resto de clientes abiertos. Conecta y desconecta nuevos clientes y observa tambi\u00e9n como el campo correspondiente en la p\u00e1gina web se actualiza correctamente. Si quieres, puedes analizar el tr\u00e1fico Websockets generado v\u00eda Wireshark.","title":"Un ejemplo m\u00e1s complejo: sincronizaci\u00f3n entre m\u00faltiples clientes (server2.py, client.html)"},{"location":"Subjects/NP2/P4/#websockets-en-el-esp32","text":"El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9sd el componente websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente websocket client ofrece soporte para el protocolo websocket sobre TCP y tambi\u00e9n, opcionalmente, sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, sin intercambio de datos. WEBSOCKET_EVENT_DISCONNECTED : se emite en el instante de la desconexi\u00f3n entre cliente y servidor. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que accarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: const char * data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DISCONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256*data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( event_data ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:123\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos *Websocket * esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos.","title":"Websockets en el ESP32"},{"location":"Subjects/NP2/P4/#ejemplo-basico-cliente-echo","text":"Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo examples/protocols/websockets . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (disponible en ws://websockets.org ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo?","title":"Ejemplo b\u00e1sico: cliente echo"},{"location":"Subjects/NP2/P4/#ejercicio-entregable-comunicacion-asincrona","text":"El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con el servidor Python que se prob\u00f3 en la secci\u00f3n anterior, y que implementaba comunicaci\u00f3n bidireccional para mantener y difundir el estado interno (contador y n\u00famero de clientes conectados) entre todos los clientes conectados. Para ello, se pide modificar el ejemplo de cliente echo para que: El cliente conecte con el servidor Python especificando su IP y puerto. El cliente sea cien por cien pasivo, es decir, no env\u00ede nunca mensajes al servidor. La funci\u00f3n de manejo de paquetes recibidos trate de forma especial el tipo de mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos tipos de mensajes de texto: Mensajes de estado: {\"type\": \"users\", \"count\": usuarios} Mensajes de usuarios: {\"type\": \"state\", \"value\": VALOR} Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con una representaci\u00f3n JSON de la informaci\u00f3n. Para tratarla desde ESP-IDF, puedes hacer uso del componente cJSON del framework . Por ejemplo, para tratar un mensaje de entrada de tipo \"state\", podr\u00edamos a\u00f1adir la siguiente secuencia de c\u00f3digo en nuestro manejador: #include \"cJSON.h\" // ... if( data->op_code == 1 ) { // Text frame only. cJSON *root = cJSON_Parse((char*)data->data_ptr); char *type = cJSON_GetObjectItem(root,\"type\")->valuestring; ESP_LOGI(TAG, \"type=%s\",type); int field = 0; if( strcmp( type, \"state\" ) == 0) { field = cJSON_GetObjectItem(root,\"value\")->valueint; ESP_LOGI(TAG, \"value=%d\",field); } } Tarea entregable Modifica el firmware de ejemplo websockets para que pueda comunicarse en modo lectura con el servidor Python que mantiene y publicita estado, cuyo c\u00f3digo se te proporciona. El programa ESP-IDF, al menos, mostar\u00e1 por pantalla un mensaje con los datos asociados cada vez que se reciban paquetes de tipo texto ( state o users ). Tambi\u00e9n mostrar\u00e1 un mensaje cada vez que el servidor env\u00ede un mensaje de tipo ping o pong (para ello, consulta el RFC que describe el protocolo para determinar el opcode asociado). Para comprobar el funcionamiento de la soluci\u00f3n, arranca el servidor y al menos dos clientes web. Cuando arranques el ESP32, ambos deber\u00e1n incrementar el n\u00famero de clientes reportado, en respuesta al mensaje enviado por el servidor. Cuando cualquiera de los clientes web incremente el valor del contador, el ESP32 recibir\u00e1 un mensaje con el valor actualizado, del mismo modo que cuando cierres uno de los navegadores web. Tarea opcional Modifica el c\u00f3digo para que el cliente, peri\u00f3dicamente, env\u00ede un mensaje de petici\u00f3n de suma o resta siguiendo las especificaciones y tipos de mensaje que se explicaron anteriormente.","title":"Ejercicio entregable: Comunicaci\u00f3n as\u00edncrona"},{"location":"Subjects/NP2/P5/","text":"Pr\u00e1ctica 5. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR Objetivos Entender los mecanismos ofrecidos por ESP-IDF para la creaci\u00f3n de un servidor REST HTTP. Implementar, a trav\u00e9s de los mecanismos ofrecidos por ESP-IDF, una API REST extendida en el ESP32. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de JSON. Implementar, a trav\u00e9s de la biblioteca cJSON , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de CBOR, y evaluar sus ventajas con respecto a JSON. Implementar, a trav\u00e9s de la biblioteca tinycbor , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor, comparando los tama\u00f1os de payload con respecto al intercambio JSON. Desarrollo de un servidor REST en ESP-IDF En la primera parte de la pr\u00e1ctica, veremos c\u00f3mo desarrollar, utilizando las funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API REST mediante la cual ser\u00e1 posible interactuar, en modos lectura y escritura, con un servidor (en nuestro caso, un dispositivo ESP32). Concretamente, trabajaremos con el ejemplo example/protocols/http_server/rest_server de la distribuci\u00f3n de IDF (versi\u00f3n 4.1). Descripci\u00f3n de la API El ejemplo que estudiaremos construye una sencilla interfaz (API) con tres endpoints que permiten interactuar con distintas funcionalidades del ESP32. N\u00f3tese que tanto las URLs como la funcionalidad asociada a ellas es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades de nuestra aplicaci\u00f3n. La siguiente tabla resume la funcionalidad de cada endpoint , as\u00ed como posibles ejemplos de valores enviados o devueltos a/por el servidor: API M\u00e9todo Ejemplo de recurso le\u00eddo/escrito Descripci\u00f3n URL /api/v1/system/info GET { version:\"v4.0-dev\", cores:2 } Utilizado por los clientes para obtener informaci\u00f3n de la placa (versi\u00f3n, n\u00famero de cores, ...) / /api/v1/temp/raw GET { raw:22 } Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32) /chart /api/v1/light/brightness POST { red:160, green:160, blue:160 } Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs /light Configuraci\u00f3n y compilaci\u00f3n del ejemplo En primer lugar, configura, compila y flashea el ejemplo mencionado. En este caso, las instrucciones se dividen en dos partes: compilaci\u00f3n del firmware para el ESP32, y preparaci\u00f3n de un cliente web sencillo que nos permitir\u00e1 observar la interacci\u00f3n con el mismo. Esta \u00faltima parte no es estrictamente necesaria, pero nos ayudar\u00e1 en la interacci\u00f3n con el dispositivo de forma visual hasta que veamos c\u00f3mo hacerlo a trav\u00e9s de l\u00ednea de comandos. A trav\u00e9s del men\u00fa de configuraci\u00f3n, configura un nombre para el dispositivo (por ejemplo, 'esp_home_tunombre'), e indica que el modo de despliegue ( Website deploy mode ) sea Deploy website to SPI Nor Flash . Por \u00faltimo, configura las credenciales del punto de acceso WiFi al que conectar\u00e1, siguiendo la metodolog\u00eda habitual. En segundo lugar, necesitamos instalar los componentes necesarios para desplegar el cliente web. Para ello, navega al subdirectorio front/web-demo , donde reside el c\u00f3digo fuente del cliente. Ejecuta los siguientes comandos para instalar las dependencias necesarias: sudo apt-get install npm node-vue* npm install npm run build En este punto, ya podr\u00e1s ejecutar, desde el directorio base del ejemplo, la orden de compilaci\u00f3n y flasheado: idf.py build idf.py flash idf.py monitor Interacci\u00f3n con el dispositivo v\u00eda interfaz web Si todo ha ido bien, podr\u00e1s observar en la salida de monitorizaci\u00f3n la IP proporcionada al ESP32. Abre un navegador en la m\u00e1quina virtual o en tu PC (estando conectada a la misma red que tu ESP32), navega hacia la direcci\u00f3n IP del ESP32, y deber\u00edas observar una p\u00e1gina como la siguiente: Esta es una p\u00e1gina web servida por el propio ESP32, que te permitir\u00e1 interactuar con \u00e9l. Concretamente, la p\u00e1gina dispone de dos funcionalidades: Chart : consulta peri\u00f3dicamente el valor de temperatura devuelto por el ESP32 a trav\u00e9s del endpoint /api/v1/temp/raw . Light : permite enviar al ESP32 nuevos valores para las tres componentes de luminosidad que hipot\u00e9ticamente podr\u00eda equipar el ESP32. Tarea Interact\u00faa con el sensor de luminosidad del ESP32 enviando distintos valores. Observa c\u00f3mo la salida de monitorizaci\u00f3n del ESP32 responde mostrando los valores recibidos. Analiza el tr\u00e1fico generado para una de dichas peticiones utilizando Wireshark. \u00bfC\u00f3mo se codifican los datos en el env\u00edo? \u00bfC\u00f3mo se codifican los datos peri\u00f3dicos de temperatura recibidos? Interacci\u00f3n con el dispositivo v\u00eda l\u00ednea de comandos ( curl ) curl es una herramienta orientada a la transferencia de archivos por red. Entre otras (muchas) funcionalidades, curl soporta los m\u00e9todos GET y PUT del protocolo HTTP, justo las necesarias para realizar peticiones de lectura y escritura sobre nuestro servidor HTTP REST. Concretamente, para realizar una petici\u00f3n HTTP GET sobre nuestro servidor, podemos ejecutar: curl http://IP/URI Por ejemplo, la petici\u00f3n: curl http://192.168.1.26/api/v1/temp/raw (siendo 192.168.1.26 la IP del ESP32) nos responder\u00e1 con el valor de temperatura instant\u00e1nea. Del mismo modo, para escribir (m\u00e9todo POST ) sobre el servidor, utilizaremos el par\u00e1metro -d , seguido del recurso que queramos enviar. Ten en cuenta que es responsabilidad del cliente enviar un recurso bien formado e interpretable por el dispositivo: curl -d '{\"red\":70,\"green\":80,\"blue\":99}' -H \"Content-Type: application/json\" -X POST http://192.168.1.26/api/v1/light/brightness Observa que hemos incluido el tipo de recurso enviado ( JSON ) y la operacion solicitada ( POST ). Volveremos a esto en breve. Tarea Comprueba que, efectivamente, el tr\u00e1fico generado por las anteriores \u00f3rdenes es el mismo que el que observaste en el caso del cliente web. Observa qu\u00e9 ocurre si consultas un endpoint inexistente, o si env\u00edas un JSON mal formado o con informaci\u00f3n incorrecta. Implementaci\u00f3n de un servidor HTTP con API REST La implementaci\u00f3n de un servidor HTTP en ESP-IDF se delega al componente HTTP Server , que implementa toda la funcionalida necesaria para tal fin de forma eficiente y ligera. La construcci\u00f3n de un servidor puede resumirse en tres funciones principales (observa la implementaci\u00f3n de la funcion start_rest_server en el fichero rest_server.c ) del ejemplo: httpd_start : crea una instancia de servidor HTTP, y aloja recursos para ella seg\u00fan la configuraci\u00f3n proporcionada. En funci\u00f3n del tr\u00e1fico generado (URIs solicitadas), se utilizar\u00e1n manejadores espec\u00edficos definidos por el usuario para analizarlo y, en caso necesario, enviar respuestas al cliente correspondiente. httpd_stop : finaliza el servidor HTTP, cerrando cualquier conexi\u00f3n previamente establecida con clientes. httpd_register_uri_handler : registra un manejador (una funci\u00f3n definida por el usuario) para tratar una petici\u00f3n sobre una URI determinada. La estructura proporcionada dispone de campos para indicar la URI destino ( uri ), el m\u00e9todo que se espera recibir ( method , por ejemplo HTTPD_GET o HTTPD_POST ) y un puntero a una funci\u00f3n que procesar\u00e1 la petici\u00f3n recibida a trav\u00e9s de la URI indicada. Dicha funci\u00f3n s\u00f3lo se ejecutar\u00e1 si el m\u00e9todo coincide con el indicado. La funci\u00f3n start_rest_server del ejemplo proporciona los mecanismos b\u00e1sicos para la creaci\u00f3n de la API anteriormente descrita. As\u00ed, para crear el endpoint /api/v1/system/info , procederemos, en primer lugar, registr\u00e1ndolo en el servidor, preparando previamente la estructura de tipo httpd_uri_t : httpd_uri_t system_info_get_uri = { .uri = \"/api/v1/system/info\", .method = HTTP_GET, .handler = system_info_get_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &system_info_get_uri); En este caso, la operaci\u00f3n asociada a la invocaci\u00f3n del handler ser\u00e1, exclusivamente GET ; de hecho, si invocamos a un m\u00e9todo POST sobre este endpoint , el servidor nos responder\u00e1 autom\u00e1ticamente con un aviso que indicar\u00e1 que dicho m\u00e9todo no est\u00e1 soportado. El procesamiento de la petici\u00f3n GET se realiza en la funci\u00f3n system_info_get_handler , y el esquema que se sigue es, en cualquier caso, sencillo: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de respuesta. httpd_resp_set_type(req, \"application/json\"); // Preparaci\u00f3n del buffer de respuesta. char * buffer = // En el ejemplo preparamos un buffer JSON. // Env\u00edo de respuesta. https_resp_sendstr( req, buffer ); return ESP_OK; Alternativamente, si la respuesta es binaria, podr\u00edamos utilizar la funci\u00f3n https_resp_send( req, buffer, buffer_len ) para procesarla y enviarla (lo necesitar\u00e1s para enviar un buffer binario CBOR). La creaci\u00f3n de un endpoint con soporte para m\u00e9todo POST resulta algo m\u00e1s larga, aunque el registro del mismo no difiere del ejemplo anterior: /* URI handler for light brightness control */ httpd_uri_t light_brightness_post_uri = { .uri = \"/api/v1/light/brightness\", .method = HTTP_POST, .handler = light_brightness_post_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &light_brightness_post_uri); Observa el cuerpo de la funci\u00f3n light_brightness_post_handler . La recepci\u00f3n del objeto enviado por parte del cliente se realiza en base a m\u00faltiples invocaciones a la rutina httpd_req_recv : /* Simple handler for light brightness control */ static esp_err_t light_brightness_post_handler(httpd_req_t *req) { int total_len = req->content_len; int cur_len = 0; char *buf = ((rest_server_context_t *)(req->user_ctx))->scratch; int received = 0; if (total_len >= SCRATCH_BUFSIZE) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"content too long\"); return ESP_FAIL; } while (cur_len < total_len) { received = httpd_req_recv(req, buf + cur_len, total_len); if (received <= 0) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"Failed to post control value\"); return ESP_FAIL; } cur_len += received; } buf[total_len] = '\\0'; /// A partir de este punto, disponemos en buf del objeto recibido v\u00eda HTTP. /// ... Tarea entregable Observa y estudia los c\u00f3digos de los manejadores implementados en el ejemplo. Extiende la API proporcionada para crear un nuevo endpoint que permita obtener la temperatura (n\u00famero aleatorio), pero transform\u00e1ndola a grados Fahrenheit. En este caso, el valor devuelto en el fichero JSON ser\u00e1 un n\u00famero en punto flotante (en la siguiente secci\u00f3n te se explicar\u00e1 c\u00f3mo hacerlo, por lo que de momento puedes enviar \u00fanicamente la parte entera del mismo). Representaci\u00f3n de la informaci\u00f3n. JSON JSON es un formato de representaci\u00f3n de datos en modo texto para el intercambio de datos entre sistemas inform\u00e1ticos. Se cre\u00f3 inicialmente como una notaci\u00f3n literal de los objetos Javascript, pero dada su amplia aceptaci\u00f3n (realmente como alternativa a XML), se considera a d\u00eda de hoy un componente totalmente independiente al lenguaje. Los tipos de datos soportados por JSON incluyen: Valores num\u00e9ricos: permitiendo n\u00fameros con y sin signo, y con parte decimla en notaci\u00f3n separada por puntos. Cadenas: secuencias de cero o m\u00e1s caracteres. Booleanos: true y false . Arrays: listas ordenadas de cero o m\u00e1s valores de cualquier tipo, separados por comas y encerrados entre corchetes. Objetos: colecciones no ordenadas de pares <nombre>:<valor> , separados por comas y encerrados entre llaves. ESP-IDF incluye el componente cJSON para parsear y construir objetos de tipo JSON de forma sencilla y consistente. La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, v\u00e9ase: /* The cJSON structure: */ typedef struct cJSON { struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; double valuedouble; char *string; } cJSON; El campo type informa sobre el tipo de dato contenido en el objeto, v\u00e9ase: cJSON_False ( cJSON_IsFalse() ): representa un valor booleano falso. cJSON_True ( cJSON_IsTrue() ): representa un valor booleano verdadero. cJSON_NULL ( cJSON_IsNULL() ): representa un valor nulo. cJSON_Number ( cJSON_IsNumber() ): representa un valor num\u00e9rico. Dicho valor se almacena en el campo valuedouble como flotante y en valueint como entero. cJSON_String ( cJSON_IsString() ): representa un valor cadena, y se almacena en el campo valuestring como un array de bytes terminado por el car\u00e1cter nulo ('\\0'). cJSON_Array ( cJSON_IsArray() ): representa un array de valores. En el campo child se almacena una lista enlazada con los elementos del array, terminada en NULL. cJSON_Object ( cJSON_IsObject() ): representa un valor objeto. Sus valores se almacenan de la misma manera que el array anterior, pero en el campo string se almacenan adem\u00e1s las claves del objeto a modo de lista. Creaci\u00f3n y parseado de una estructura JSON Para cada tipo de datos, existe una rutina asociada con nombre cJSON_Create... que permite crear un item del tipo correspondiente. Todas estas funciones alojan memoria suficiente como para albergar el dato creado. Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo) utilizando la funci\u00f3n cJSON_Parse : cJSON * json = cJSON_Parse( string ); Para imprimir el contenido de una estructura JSON en modo texto, podemos hacer uso de la funci\u00f3n cJSON_Print(json) : char * string = cJSON_Print( json ); Ejemplos Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor REST. Concretamente, c\u00e9ntrate en la funci\u00f3n system_info_get_handler , que construye un objeto JSON con dos campos, de tipo cadena (\"version\") y num\u00e9rico (\"cores\"): /* Simple handler for getting system handler */ static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de datos de la respuesta. httpd_resp_set_type(req, \"application/json\"); // Creaci\u00f3n del objeto JSON. cJSON *root = cJSON_CreateObject(); // Obtenci\u00f3n del dato. esp_chip_info_t chip_info; esp_chip_info(&chip_info); // Anyadimos un campo de tipo cadena. cJSON_AddStringToObject(root, \"version\", IDF_VER); // Anyadimos un campo de tipo num\u00e9rico. cJSON_AddNumberToObject(root, \"cores\", chip_info.cores); // Imprimimos a cadena previo al env\u00edo. const char *sys_info = cJSON_Print(root); // Enviamos cabecera + objeto JSON en modo texto v\u00eda HTTP. httpd_resp_sendstr(req, sys_info); // Liberamos recursos. free((void *)sys_info); // Liberamos recursos del objeto JSON. cJSON_Delete(root); return ESP_OK; } La funci\u00f3n light_brightness_post_handler realiza un parseado del objeto JSON recibido. Observa su cuerpo: // buf contiene la cadena recibida a trav\u00e9s de HTTP (m\u00e9todo POST). // ... // Parseamos el objeto JSON. cJSON *root = cJSON_Parse(buf); // Obtenemos tres valores num\u00e9ricos (RGB). int red = cJSON_GetObjectItem(root, \"red\")->valueint; int green = cJSON_GetObjectItem(root, \"green\")->valueint; int blue = cJSON_GetObjectItem(root, \"blue\")->valueint; // Mostramos por pantalla los valores parseados. ESP_LOGI(REST_TAG, \"Light control: red = %d, green = %d, blue = %d\", red, green, blue); // Liberamos recursos JSON. cJSON_Delete(root); // Enviamos una respuesta generica en modo texto. httpd_resp_sendstr(req, \"Post control value successfully\"); return ESP_OK; Tarea entregable Extiende la tarea anterior para a\u00f1adir el dato en formato punto flotante de la temperatura en grados Fahrenheit. Tarea entregable Crea un nuevo endpoint que utilice un formato m\u00e1s complejo de objetos JSON, incluyendo distintos tipos de datos que puedan dar respuesta a un hipot\u00e9tico entorno IoT. Documenta la API generada y el formato de los objetos que has dise\u00f1ado. Puedes, si as\u00ed lo deseas, incluir capturas Wireshark para ilustrar el intercambio de mensajes producido. Nos interesar\u00e1, especialmente, el n\u00famero de bytes transportados para enviar/recibir tus mensajes JSON. Representaci\u00f3n de la informaci\u00f3n. CBOR CBOR ( Concise Binary Object Representation ) es el formato de serializaci\u00f3n de datos recomendado en muchos de los stacks IoT, espec\u00edficamente en aquellos basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con JSON, ya que sigue su mismo modelo de datos: valores num\u00e9ricos, strings , arrays, mapas (objetos en JSON) y valores booleanos y nulos. Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en este punto radica una de sus ventajas: es posible intercambiar datos entre un cliente y un servidor sin ce\u00f1irse a un esquema de datos concreto conocido por ambas partes. El hecho de ser un formato binario implica mejoras sustanciales con respecto a JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos gr\u00e1ficos, o valores flotantes sensorizados, entre otros muchos); estos datos sol\u00edan codificarse en JSON utilizando, por ejemplo, formato base64 , a\u00f1adiendo complejidad al proceso de codificaci\u00f3n/decodificaci\u00f3n. En general, el uso de un formato binario implica menor complejidad a la hora de ser integrado en aplicaciones, y es por esta raz\u00f3n por la que se considera \u00f3ptimo para nodos de bajas prestaciones, t\u00edpicos en IoT. El formato CBOR est\u00e1 documentado en el RFC 7049 , y por tanto se considera un est\u00e1ndar bien documentado y estable de cara al futuro. CBOR en el ESP32 ESP-IDF incluye la biblioteca tinyCBOR como implementaci\u00f3n ligera del est\u00e1ndar, que permite tanto codificar distintos tipos de datos a formato CBOR, parsear estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable como a JSON. TinyCBOR est\u00e1 mantenido como proyecto de software libre por parte de Intel, y su documentaci\u00f3n detallada (se sugiere consultarla) se encuentra disponible en el siguiente enlace . Estudiaremos el funcionamiento de tinyCBOR a trav\u00e9s de un ejemplo funcional (lo puedes encontrar en examples/protocols/cbor ). El ejemplo muestra los mecanismos necesarios para, en primer lugar, crear un objeto CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo para convertir dicho objeto a representaci\u00f3n JSON, as\u00ed como para parsearlo manualmente. En primer lugar, compila, flashea y ejecuta el ejemplo. Ver\u00e1s que la salida deber\u00eda ser similar a la siguiente: I (320) example: encoded buffer size 67 I (320) example: convert CBOR to JSON [{\"chip\":\"esp32\",\"unicore\":false,\"ip\":[192,168,1,100]},3.1400001049041748,\"simple(99)\",\"2019-07-10 09:00:00+0000\",\"undefined\"] I (340) example: decode CBOR manually Array[ Map{ chip esp32 unicore false ip Array[ 192 168 1 100 ] } 3.14 simple(99) 2019-07-10 09:00:00+0000 undefined ] Observa que la estructura del objeto CBOR ser\u00e1 medianamente compleja: constar\u00e1 de un array formado por cinco elementos: Un mapa (conjunto no ordenado de pares clave-valor ), combinando cadenas, booleanos y un segundo array para especificar una direcci\u00f3n IP. Un valor flotante (3.14). Un valor num\u00e9rico \"simple\" (99). Una fecha (en forma de cadena). Un valor indefinido. El firmware procede en tres etapas: Etapa 1: creaci\u00f3n (codificaci\u00f3n) del objeto CBOR Observa el cuerpo de la tarea principal ( app_main ). El codificador CBOR se basa en dos variables: CborEncoder Root_encoder; // Codificador CBOR. uint8_t buf[100]; // Buffer para alojar el objeto CBOR (array de bytes). En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos constructores especiales para dichos objetos: // Creaci\u00f3n de Array. CborEncoder array_encoder; CborEncoder map_encoder; cbor_encoder_create_array(&root_encoder, &array_encoder, 5); // [ // 1. Creaci\u00f3n del Mapa. cbor_encoder_create_map(&array_encoder, &map_encoder, 3); // { A partir de este punto, podemos proceder con la construcci\u00f3n de los objetos siguiendo el esquema deseado: // chip: esp32 (cadena:cadena) cbor_encode_text_stringz(&map_encoder, \"chip\"); cbor_encode_text_stringz(&map_encoder, \"esp32\"); // unicore: false (cadena:booleano) cbor_encode_text_stringz(&map_encoder, \"unicore\"); cbor_encode_boolean(&map_encoder, false); // IP:[192,168,1,100] (cadena:array) cbor_encode_text_stringz(&map_encoder, \"ip\"); CborEncoder array2; cbor_encoder_create_array(&map_encoder, &array2, 4); // [ // Valores num\u00e9ricos. cbor_encode_uint(&array2, 192); cbor_encode_uint(&array2, 168); cbor_encode_uint(&array2, 1); cbor_encode_uint(&array2, 100); cbor_encoder_close_container(&map_encoder, &array2); // ] cbor_encoder_close_container(&array_encoder, &map_encoder); // } // 2. Flotante cbor_encode_float(&array_encoder, 3.14); // 3. Valor simple cbor_encode_simple_value(&array_encoder, 99); // 4. Cadena cbor_encode_text_stringz(&array_encoder, \"2019-07-10 09:00:00+0000\"); // 5. Undefined value. cbor_encode_undefined(&array_encoder); cbor_encoder_close_container(&root_encoder, &array_encoder); // ] // Mostramos el tama\u00f1o del buffer creado. ESP_LOGI(TAG, \"encoded buffer size %d\", cbor_encoder_get_buffer_size(&root_encoder, buf)); Etapa 2: conversi\u00f3n a JSON La conversi\u00f3n a JSON (t\u00edpicamente por motivos de visualizaci\u00f3n o depuraci\u00f3n), puede realizarse del siguiente modo: // Initialize the cbor parser and the value iterator cbor_parser_init(buf, sizeof(buf), 0, &root_parser, &it); ESP_LOGI(TAG, \"convert CBOR to JSON\"); // Dump the values in JSON format cbor_value_to_json(stdout, &it, 0); Etapa 3: parseado manual de un objeto CBOR Por \u00faltimo, el parseado manual del objeto CBOR se deja como ejercicio de estudio para el alumno, y est\u00e1 implementado en la funci\u00f3n example_dump_cbor_buffer del ejemplo. B\u00e1sicamente, la funci\u00f3n itera por cada uno de los elementos del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia. Para aquellos tipos complejos (e.g. arrays o mapas), la funci\u00f3n se invoca recursivamente hasta encontrar un elemento de tipo b\u00e1sico. En este caso, simplemente imprime por pantalla su valor (e.g. en el caso de un entero, caso CborIntegerType ). Tarea entregable Se pide extender la API REST con un nuevo endpoint que permita obtener la misma informaci\u00f3n que el endpoint JSON desarrollado en la anterior tarea, pero en esta ocasi\u00f3n, utilizando formato CBOR. El objetivo del ejercicio es comparar la cantidad de tr\u00e1fico generado en cada representaci\u00f3n, por lo que se sugiere que el objeto intercambiado sea relativamente complejo (es decir, incluya disintos tipos de datos num\u00e9ricos, arrays, o mapas). A continuaci\u00f3n se incluyen notas adicionales que te permitir\u00e1n depurar tu desarrollo, observando los valores devueltos por el servidor HTTP. Notas adicionales: creaci\u00f3n y consulta de un endpoint CBOR en la API REST Las modificaciones a realizar en la funci\u00f3n manejadora del endpoint para responder con un objeto CBOR son m\u00ednimas. De hecho, se centran simplemente en el tipo de respuesta y el mecanismo a usar para enviarla, v\u00e9ase: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Tipo de respuesta. httpd_resp_set_type(req, \"application/cbor\"); CborEncoder root_encoder; uint8_t buf[100]; // Codificador CBOR. cbor_encoder_init(&root_encoder, buf, sizeof(buf), 0); // Codificamos CBOR. // ... // Enviamos respuesta, consultando previamente el tama\u00f1o del buffer codificado. httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &root_encoder, buf)); return ESP_OK; Para consultar desde l\u00ednea de comandos sobre este endpoint , podemos utilizar directamente curl , volcando la salida recibida a un fichero (por ejemplo, output.cbor ): curl http://192.168.1.26/api/v1/system/info > output.cbor Si visualizas el contenido del fichero, ver\u00e1s que contiene datos binarios dif\u00edcilmente interpretables. A continuaci\u00f3n veremos distintos mecanismos de visualizaci\u00f3n. Notas adicionales: visualizaci\u00f3n de datos CBOR Una opci\u00f3n de visualizaci\u00f3n consiste en utilizar la web cbor.me . En el panel derecho, podr\u00e1s pegar el contenido binario le\u00eddo. Si necesitas realizar la conversi\u00f3n antes de pegarlo en la web, puedes hacerlo con la orden: xxd -ps output.cbor Un ejemplo de salida (a pegar en el panel derecho de la web), podr\u00eda ser: $ xxd -ps output.cbor 85a3646368697065657370333267756e69636f7265f46269708418c018a8 011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30 302b30303030f7 Deber\u00edas observar una salida similar a la siguiente (ten en cuenta que la herramiente autom\u00e1ticamente indenta el contenido del panel derecho; recuerda que simplemente debes pegar la salida generada por xxd ): Otra opci\u00f3n de visualizaci\u00f3n puede ser un programa Python (podr\u00edas integrarlo en tu servidor TCP/UDP, por ejemplo), que haga uso del m\u00f3dulo cbor2 ( documentaci\u00f3n ). Para comprobar su funcionamiento, primero inst\u00e1lalo: pip install cbor2 Y comprueba si efectivamente funciona utilizando el siguiente programa Python: from cbor2 import dumps, loads, dump, load with open('output.cbor', 'rb') as fp: obj = load(fp) print(obj) Al ejecutarlo, observar\u00e1s el contenido del objeto: python cbor.py [{'chip': 'esp32', 'unicore': False, 'ip': [192, 168, 1, 100]}, 3.140000104904175, CBORSimpleValue(value=99), '2019-07-10 09:00:00+0000', undefined]","title":"Pr\u00e1ctica 5. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR"},{"location":"Subjects/NP2/P5/#practica-5-servidores-rest-y-representacion-de-la-informacion-json-y-cbor","text":"","title":"Pr\u00e1ctica 5. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR"},{"location":"Subjects/NP2/P5/#objetivos","text":"Entender los mecanismos ofrecidos por ESP-IDF para la creaci\u00f3n de un servidor REST HTTP. Implementar, a trav\u00e9s de los mecanismos ofrecidos por ESP-IDF, una API REST extendida en el ESP32. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de JSON. Implementar, a trav\u00e9s de la biblioteca cJSON , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de CBOR, y evaluar sus ventajas con respecto a JSON. Implementar, a trav\u00e9s de la biblioteca tinycbor , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor, comparando los tama\u00f1os de payload con respecto al intercambio JSON.","title":"Objetivos"},{"location":"Subjects/NP2/P5/#desarrollo-de-un-servidor-rest-en-esp-idf","text":"En la primera parte de la pr\u00e1ctica, veremos c\u00f3mo desarrollar, utilizando las funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API REST mediante la cual ser\u00e1 posible interactuar, en modos lectura y escritura, con un servidor (en nuestro caso, un dispositivo ESP32). Concretamente, trabajaremos con el ejemplo example/protocols/http_server/rest_server de la distribuci\u00f3n de IDF (versi\u00f3n 4.1).","title":"Desarrollo de un servidor REST en ESP-IDF"},{"location":"Subjects/NP2/P5/#descripcion-de-la-api","text":"El ejemplo que estudiaremos construye una sencilla interfaz (API) con tres endpoints que permiten interactuar con distintas funcionalidades del ESP32. N\u00f3tese que tanto las URLs como la funcionalidad asociada a ellas es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades de nuestra aplicaci\u00f3n. La siguiente tabla resume la funcionalidad de cada endpoint , as\u00ed como posibles ejemplos de valores enviados o devueltos a/por el servidor: API M\u00e9todo Ejemplo de recurso le\u00eddo/escrito Descripci\u00f3n URL /api/v1/system/info GET { version:\"v4.0-dev\", cores:2 } Utilizado por los clientes para obtener informaci\u00f3n de la placa (versi\u00f3n, n\u00famero de cores, ...) / /api/v1/temp/raw GET { raw:22 } Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32) /chart /api/v1/light/brightness POST { red:160, green:160, blue:160 } Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs /light","title":"Descripci\u00f3n de la API"},{"location":"Subjects/NP2/P5/#configuracion-y-compilacion-del-ejemplo","text":"En primer lugar, configura, compila y flashea el ejemplo mencionado. En este caso, las instrucciones se dividen en dos partes: compilaci\u00f3n del firmware para el ESP32, y preparaci\u00f3n de un cliente web sencillo que nos permitir\u00e1 observar la interacci\u00f3n con el mismo. Esta \u00faltima parte no es estrictamente necesaria, pero nos ayudar\u00e1 en la interacci\u00f3n con el dispositivo de forma visual hasta que veamos c\u00f3mo hacerlo a trav\u00e9s de l\u00ednea de comandos. A trav\u00e9s del men\u00fa de configuraci\u00f3n, configura un nombre para el dispositivo (por ejemplo, 'esp_home_tunombre'), e indica que el modo de despliegue ( Website deploy mode ) sea Deploy website to SPI Nor Flash . Por \u00faltimo, configura las credenciales del punto de acceso WiFi al que conectar\u00e1, siguiendo la metodolog\u00eda habitual. En segundo lugar, necesitamos instalar los componentes necesarios para desplegar el cliente web. Para ello, navega al subdirectorio front/web-demo , donde reside el c\u00f3digo fuente del cliente. Ejecuta los siguientes comandos para instalar las dependencias necesarias: sudo apt-get install npm node-vue* npm install npm run build En este punto, ya podr\u00e1s ejecutar, desde el directorio base del ejemplo, la orden de compilaci\u00f3n y flasheado: idf.py build idf.py flash idf.py monitor","title":"Configuraci\u00f3n y compilaci\u00f3n del ejemplo"},{"location":"Subjects/NP2/P5/#interaccion-con-el-dispositivo-via-interfaz-web","text":"Si todo ha ido bien, podr\u00e1s observar en la salida de monitorizaci\u00f3n la IP proporcionada al ESP32. Abre un navegador en la m\u00e1quina virtual o en tu PC (estando conectada a la misma red que tu ESP32), navega hacia la direcci\u00f3n IP del ESP32, y deber\u00edas observar una p\u00e1gina como la siguiente: Esta es una p\u00e1gina web servida por el propio ESP32, que te permitir\u00e1 interactuar con \u00e9l. Concretamente, la p\u00e1gina dispone de dos funcionalidades: Chart : consulta peri\u00f3dicamente el valor de temperatura devuelto por el ESP32 a trav\u00e9s del endpoint /api/v1/temp/raw . Light : permite enviar al ESP32 nuevos valores para las tres componentes de luminosidad que hipot\u00e9ticamente podr\u00eda equipar el ESP32. Tarea Interact\u00faa con el sensor de luminosidad del ESP32 enviando distintos valores. Observa c\u00f3mo la salida de monitorizaci\u00f3n del ESP32 responde mostrando los valores recibidos. Analiza el tr\u00e1fico generado para una de dichas peticiones utilizando Wireshark. \u00bfC\u00f3mo se codifican los datos en el env\u00edo? \u00bfC\u00f3mo se codifican los datos peri\u00f3dicos de temperatura recibidos?","title":"Interacci\u00f3n con el dispositivo v\u00eda interfaz web"},{"location":"Subjects/NP2/P5/#interaccion-con-el-dispositivo-via-linea-de-comandos-curl","text":"curl es una herramienta orientada a la transferencia de archivos por red. Entre otras (muchas) funcionalidades, curl soporta los m\u00e9todos GET y PUT del protocolo HTTP, justo las necesarias para realizar peticiones de lectura y escritura sobre nuestro servidor HTTP REST. Concretamente, para realizar una petici\u00f3n HTTP GET sobre nuestro servidor, podemos ejecutar: curl http://IP/URI Por ejemplo, la petici\u00f3n: curl http://192.168.1.26/api/v1/temp/raw (siendo 192.168.1.26 la IP del ESP32) nos responder\u00e1 con el valor de temperatura instant\u00e1nea. Del mismo modo, para escribir (m\u00e9todo POST ) sobre el servidor, utilizaremos el par\u00e1metro -d , seguido del recurso que queramos enviar. Ten en cuenta que es responsabilidad del cliente enviar un recurso bien formado e interpretable por el dispositivo: curl -d '{\"red\":70,\"green\":80,\"blue\":99}' -H \"Content-Type: application/json\" -X POST http://192.168.1.26/api/v1/light/brightness Observa que hemos incluido el tipo de recurso enviado ( JSON ) y la operacion solicitada ( POST ). Volveremos a esto en breve. Tarea Comprueba que, efectivamente, el tr\u00e1fico generado por las anteriores \u00f3rdenes es el mismo que el que observaste en el caso del cliente web. Observa qu\u00e9 ocurre si consultas un endpoint inexistente, o si env\u00edas un JSON mal formado o con informaci\u00f3n incorrecta.","title":"Interacci\u00f3n con el dispositivo v\u00eda l\u00ednea de comandos (curl)"},{"location":"Subjects/NP2/P5/#implementacion-de-un-servidor-http-con-api-rest","text":"La implementaci\u00f3n de un servidor HTTP en ESP-IDF se delega al componente HTTP Server , que implementa toda la funcionalida necesaria para tal fin de forma eficiente y ligera. La construcci\u00f3n de un servidor puede resumirse en tres funciones principales (observa la implementaci\u00f3n de la funcion start_rest_server en el fichero rest_server.c ) del ejemplo: httpd_start : crea una instancia de servidor HTTP, y aloja recursos para ella seg\u00fan la configuraci\u00f3n proporcionada. En funci\u00f3n del tr\u00e1fico generado (URIs solicitadas), se utilizar\u00e1n manejadores espec\u00edficos definidos por el usuario para analizarlo y, en caso necesario, enviar respuestas al cliente correspondiente. httpd_stop : finaliza el servidor HTTP, cerrando cualquier conexi\u00f3n previamente establecida con clientes. httpd_register_uri_handler : registra un manejador (una funci\u00f3n definida por el usuario) para tratar una petici\u00f3n sobre una URI determinada. La estructura proporcionada dispone de campos para indicar la URI destino ( uri ), el m\u00e9todo que se espera recibir ( method , por ejemplo HTTPD_GET o HTTPD_POST ) y un puntero a una funci\u00f3n que procesar\u00e1 la petici\u00f3n recibida a trav\u00e9s de la URI indicada. Dicha funci\u00f3n s\u00f3lo se ejecutar\u00e1 si el m\u00e9todo coincide con el indicado. La funci\u00f3n start_rest_server del ejemplo proporciona los mecanismos b\u00e1sicos para la creaci\u00f3n de la API anteriormente descrita. As\u00ed, para crear el endpoint /api/v1/system/info , procederemos, en primer lugar, registr\u00e1ndolo en el servidor, preparando previamente la estructura de tipo httpd_uri_t : httpd_uri_t system_info_get_uri = { .uri = \"/api/v1/system/info\", .method = HTTP_GET, .handler = system_info_get_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &system_info_get_uri); En este caso, la operaci\u00f3n asociada a la invocaci\u00f3n del handler ser\u00e1, exclusivamente GET ; de hecho, si invocamos a un m\u00e9todo POST sobre este endpoint , el servidor nos responder\u00e1 autom\u00e1ticamente con un aviso que indicar\u00e1 que dicho m\u00e9todo no est\u00e1 soportado. El procesamiento de la petici\u00f3n GET se realiza en la funci\u00f3n system_info_get_handler , y el esquema que se sigue es, en cualquier caso, sencillo: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de respuesta. httpd_resp_set_type(req, \"application/json\"); // Preparaci\u00f3n del buffer de respuesta. char * buffer = // En el ejemplo preparamos un buffer JSON. // Env\u00edo de respuesta. https_resp_sendstr( req, buffer ); return ESP_OK; Alternativamente, si la respuesta es binaria, podr\u00edamos utilizar la funci\u00f3n https_resp_send( req, buffer, buffer_len ) para procesarla y enviarla (lo necesitar\u00e1s para enviar un buffer binario CBOR). La creaci\u00f3n de un endpoint con soporte para m\u00e9todo POST resulta algo m\u00e1s larga, aunque el registro del mismo no difiere del ejemplo anterior: /* URI handler for light brightness control */ httpd_uri_t light_brightness_post_uri = { .uri = \"/api/v1/light/brightness\", .method = HTTP_POST, .handler = light_brightness_post_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &light_brightness_post_uri); Observa el cuerpo de la funci\u00f3n light_brightness_post_handler . La recepci\u00f3n del objeto enviado por parte del cliente se realiza en base a m\u00faltiples invocaciones a la rutina httpd_req_recv : /* Simple handler for light brightness control */ static esp_err_t light_brightness_post_handler(httpd_req_t *req) { int total_len = req->content_len; int cur_len = 0; char *buf = ((rest_server_context_t *)(req->user_ctx))->scratch; int received = 0; if (total_len >= SCRATCH_BUFSIZE) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"content too long\"); return ESP_FAIL; } while (cur_len < total_len) { received = httpd_req_recv(req, buf + cur_len, total_len); if (received <= 0) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"Failed to post control value\"); return ESP_FAIL; } cur_len += received; } buf[total_len] = '\\0'; /// A partir de este punto, disponemos en buf del objeto recibido v\u00eda HTTP. /// ... Tarea entregable Observa y estudia los c\u00f3digos de los manejadores implementados en el ejemplo. Extiende la API proporcionada para crear un nuevo endpoint que permita obtener la temperatura (n\u00famero aleatorio), pero transform\u00e1ndola a grados Fahrenheit. En este caso, el valor devuelto en el fichero JSON ser\u00e1 un n\u00famero en punto flotante (en la siguiente secci\u00f3n te se explicar\u00e1 c\u00f3mo hacerlo, por lo que de momento puedes enviar \u00fanicamente la parte entera del mismo).","title":"Implementaci\u00f3n de un servidor HTTP con API REST"},{"location":"Subjects/NP2/P5/#representacion-de-la-informacion-json","text":"JSON es un formato de representaci\u00f3n de datos en modo texto para el intercambio de datos entre sistemas inform\u00e1ticos. Se cre\u00f3 inicialmente como una notaci\u00f3n literal de los objetos Javascript, pero dada su amplia aceptaci\u00f3n (realmente como alternativa a XML), se considera a d\u00eda de hoy un componente totalmente independiente al lenguaje. Los tipos de datos soportados por JSON incluyen: Valores num\u00e9ricos: permitiendo n\u00fameros con y sin signo, y con parte decimla en notaci\u00f3n separada por puntos. Cadenas: secuencias de cero o m\u00e1s caracteres. Booleanos: true y false . Arrays: listas ordenadas de cero o m\u00e1s valores de cualquier tipo, separados por comas y encerrados entre corchetes. Objetos: colecciones no ordenadas de pares <nombre>:<valor> , separados por comas y encerrados entre llaves. ESP-IDF incluye el componente cJSON para parsear y construir objetos de tipo JSON de forma sencilla y consistente. La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, v\u00e9ase: /* The cJSON structure: */ typedef struct cJSON { struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; double valuedouble; char *string; } cJSON; El campo type informa sobre el tipo de dato contenido en el objeto, v\u00e9ase: cJSON_False ( cJSON_IsFalse() ): representa un valor booleano falso. cJSON_True ( cJSON_IsTrue() ): representa un valor booleano verdadero. cJSON_NULL ( cJSON_IsNULL() ): representa un valor nulo. cJSON_Number ( cJSON_IsNumber() ): representa un valor num\u00e9rico. Dicho valor se almacena en el campo valuedouble como flotante y en valueint como entero. cJSON_String ( cJSON_IsString() ): representa un valor cadena, y se almacena en el campo valuestring como un array de bytes terminado por el car\u00e1cter nulo ('\\0'). cJSON_Array ( cJSON_IsArray() ): representa un array de valores. En el campo child se almacena una lista enlazada con los elementos del array, terminada en NULL. cJSON_Object ( cJSON_IsObject() ): representa un valor objeto. Sus valores se almacenan de la misma manera que el array anterior, pero en el campo string se almacenan adem\u00e1s las claves del objeto a modo de lista.","title":"Representaci\u00f3n de la informaci\u00f3n. JSON"},{"location":"Subjects/NP2/P5/#creacion-y-parseado-de-una-estructura-json","text":"Para cada tipo de datos, existe una rutina asociada con nombre cJSON_Create... que permite crear un item del tipo correspondiente. Todas estas funciones alojan memoria suficiente como para albergar el dato creado. Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo) utilizando la funci\u00f3n cJSON_Parse : cJSON * json = cJSON_Parse( string ); Para imprimir el contenido de una estructura JSON en modo texto, podemos hacer uso de la funci\u00f3n cJSON_Print(json) : char * string = cJSON_Print( json );","title":"Creaci\u00f3n y parseado de una estructura JSON"},{"location":"Subjects/NP2/P5/#ejemplos","text":"Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor REST. Concretamente, c\u00e9ntrate en la funci\u00f3n system_info_get_handler , que construye un objeto JSON con dos campos, de tipo cadena (\"version\") y num\u00e9rico (\"cores\"): /* Simple handler for getting system handler */ static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de datos de la respuesta. httpd_resp_set_type(req, \"application/json\"); // Creaci\u00f3n del objeto JSON. cJSON *root = cJSON_CreateObject(); // Obtenci\u00f3n del dato. esp_chip_info_t chip_info; esp_chip_info(&chip_info); // Anyadimos un campo de tipo cadena. cJSON_AddStringToObject(root, \"version\", IDF_VER); // Anyadimos un campo de tipo num\u00e9rico. cJSON_AddNumberToObject(root, \"cores\", chip_info.cores); // Imprimimos a cadena previo al env\u00edo. const char *sys_info = cJSON_Print(root); // Enviamos cabecera + objeto JSON en modo texto v\u00eda HTTP. httpd_resp_sendstr(req, sys_info); // Liberamos recursos. free((void *)sys_info); // Liberamos recursos del objeto JSON. cJSON_Delete(root); return ESP_OK; } La funci\u00f3n light_brightness_post_handler realiza un parseado del objeto JSON recibido. Observa su cuerpo: // buf contiene la cadena recibida a trav\u00e9s de HTTP (m\u00e9todo POST). // ... // Parseamos el objeto JSON. cJSON *root = cJSON_Parse(buf); // Obtenemos tres valores num\u00e9ricos (RGB). int red = cJSON_GetObjectItem(root, \"red\")->valueint; int green = cJSON_GetObjectItem(root, \"green\")->valueint; int blue = cJSON_GetObjectItem(root, \"blue\")->valueint; // Mostramos por pantalla los valores parseados. ESP_LOGI(REST_TAG, \"Light control: red = %d, green = %d, blue = %d\", red, green, blue); // Liberamos recursos JSON. cJSON_Delete(root); // Enviamos una respuesta generica en modo texto. httpd_resp_sendstr(req, \"Post control value successfully\"); return ESP_OK; Tarea entregable Extiende la tarea anterior para a\u00f1adir el dato en formato punto flotante de la temperatura en grados Fahrenheit. Tarea entregable Crea un nuevo endpoint que utilice un formato m\u00e1s complejo de objetos JSON, incluyendo distintos tipos de datos que puedan dar respuesta a un hipot\u00e9tico entorno IoT. Documenta la API generada y el formato de los objetos que has dise\u00f1ado. Puedes, si as\u00ed lo deseas, incluir capturas Wireshark para ilustrar el intercambio de mensajes producido. Nos interesar\u00e1, especialmente, el n\u00famero de bytes transportados para enviar/recibir tus mensajes JSON.","title":"Ejemplos"},{"location":"Subjects/NP2/P5/#representacion-de-la-informacion-cbor","text":"CBOR ( Concise Binary Object Representation ) es el formato de serializaci\u00f3n de datos recomendado en muchos de los stacks IoT, espec\u00edficamente en aquellos basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con JSON, ya que sigue su mismo modelo de datos: valores num\u00e9ricos, strings , arrays, mapas (objetos en JSON) y valores booleanos y nulos. Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en este punto radica una de sus ventajas: es posible intercambiar datos entre un cliente y un servidor sin ce\u00f1irse a un esquema de datos concreto conocido por ambas partes. El hecho de ser un formato binario implica mejoras sustanciales con respecto a JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos gr\u00e1ficos, o valores flotantes sensorizados, entre otros muchos); estos datos sol\u00edan codificarse en JSON utilizando, por ejemplo, formato base64 , a\u00f1adiendo complejidad al proceso de codificaci\u00f3n/decodificaci\u00f3n. En general, el uso de un formato binario implica menor complejidad a la hora de ser integrado en aplicaciones, y es por esta raz\u00f3n por la que se considera \u00f3ptimo para nodos de bajas prestaciones, t\u00edpicos en IoT. El formato CBOR est\u00e1 documentado en el RFC 7049 , y por tanto se considera un est\u00e1ndar bien documentado y estable de cara al futuro.","title":"Representaci\u00f3n de la informaci\u00f3n. CBOR"},{"location":"Subjects/NP2/P5/#cbor-en-el-esp32","text":"ESP-IDF incluye la biblioteca tinyCBOR como implementaci\u00f3n ligera del est\u00e1ndar, que permite tanto codificar distintos tipos de datos a formato CBOR, parsear estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable como a JSON. TinyCBOR est\u00e1 mantenido como proyecto de software libre por parte de Intel, y su documentaci\u00f3n detallada (se sugiere consultarla) se encuentra disponible en el siguiente enlace . Estudiaremos el funcionamiento de tinyCBOR a trav\u00e9s de un ejemplo funcional (lo puedes encontrar en examples/protocols/cbor ). El ejemplo muestra los mecanismos necesarios para, en primer lugar, crear un objeto CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo para convertir dicho objeto a representaci\u00f3n JSON, as\u00ed como para parsearlo manualmente. En primer lugar, compila, flashea y ejecuta el ejemplo. Ver\u00e1s que la salida deber\u00eda ser similar a la siguiente: I (320) example: encoded buffer size 67 I (320) example: convert CBOR to JSON [{\"chip\":\"esp32\",\"unicore\":false,\"ip\":[192,168,1,100]},3.1400001049041748,\"simple(99)\",\"2019-07-10 09:00:00+0000\",\"undefined\"] I (340) example: decode CBOR manually Array[ Map{ chip esp32 unicore false ip Array[ 192 168 1 100 ] } 3.14 simple(99) 2019-07-10 09:00:00+0000 undefined ] Observa que la estructura del objeto CBOR ser\u00e1 medianamente compleja: constar\u00e1 de un array formado por cinco elementos: Un mapa (conjunto no ordenado de pares clave-valor ), combinando cadenas, booleanos y un segundo array para especificar una direcci\u00f3n IP. Un valor flotante (3.14). Un valor num\u00e9rico \"simple\" (99). Una fecha (en forma de cadena). Un valor indefinido. El firmware procede en tres etapas:","title":"CBOR en el ESP32"},{"location":"Subjects/NP2/P5/#etapa-1-creacion-codificacion-del-objeto-cbor","text":"Observa el cuerpo de la tarea principal ( app_main ). El codificador CBOR se basa en dos variables: CborEncoder Root_encoder; // Codificador CBOR. uint8_t buf[100]; // Buffer para alojar el objeto CBOR (array de bytes). En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos constructores especiales para dichos objetos: // Creaci\u00f3n de Array. CborEncoder array_encoder; CborEncoder map_encoder; cbor_encoder_create_array(&root_encoder, &array_encoder, 5); // [ // 1. Creaci\u00f3n del Mapa. cbor_encoder_create_map(&array_encoder, &map_encoder, 3); // { A partir de este punto, podemos proceder con la construcci\u00f3n de los objetos siguiendo el esquema deseado: // chip: esp32 (cadena:cadena) cbor_encode_text_stringz(&map_encoder, \"chip\"); cbor_encode_text_stringz(&map_encoder, \"esp32\"); // unicore: false (cadena:booleano) cbor_encode_text_stringz(&map_encoder, \"unicore\"); cbor_encode_boolean(&map_encoder, false); // IP:[192,168,1,100] (cadena:array) cbor_encode_text_stringz(&map_encoder, \"ip\"); CborEncoder array2; cbor_encoder_create_array(&map_encoder, &array2, 4); // [ // Valores num\u00e9ricos. cbor_encode_uint(&array2, 192); cbor_encode_uint(&array2, 168); cbor_encode_uint(&array2, 1); cbor_encode_uint(&array2, 100); cbor_encoder_close_container(&map_encoder, &array2); // ] cbor_encoder_close_container(&array_encoder, &map_encoder); // } // 2. Flotante cbor_encode_float(&array_encoder, 3.14); // 3. Valor simple cbor_encode_simple_value(&array_encoder, 99); // 4. Cadena cbor_encode_text_stringz(&array_encoder, \"2019-07-10 09:00:00+0000\"); // 5. Undefined value. cbor_encode_undefined(&array_encoder); cbor_encoder_close_container(&root_encoder, &array_encoder); // ] // Mostramos el tama\u00f1o del buffer creado. ESP_LOGI(TAG, \"encoded buffer size %d\", cbor_encoder_get_buffer_size(&root_encoder, buf));","title":"Etapa 1: creaci\u00f3n (codificaci\u00f3n) del objeto CBOR"},{"location":"Subjects/NP2/P5/#etapa-2-conversion-a-json","text":"La conversi\u00f3n a JSON (t\u00edpicamente por motivos de visualizaci\u00f3n o depuraci\u00f3n), puede realizarse del siguiente modo: // Initialize the cbor parser and the value iterator cbor_parser_init(buf, sizeof(buf), 0, &root_parser, &it); ESP_LOGI(TAG, \"convert CBOR to JSON\"); // Dump the values in JSON format cbor_value_to_json(stdout, &it, 0);","title":"Etapa 2: conversi\u00f3n a JSON"},{"location":"Subjects/NP2/P5/#etapa-3-parseado-manual-de-un-objeto-cbor","text":"Por \u00faltimo, el parseado manual del objeto CBOR se deja como ejercicio de estudio para el alumno, y est\u00e1 implementado en la funci\u00f3n example_dump_cbor_buffer del ejemplo. B\u00e1sicamente, la funci\u00f3n itera por cada uno de los elementos del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia. Para aquellos tipos complejos (e.g. arrays o mapas), la funci\u00f3n se invoca recursivamente hasta encontrar un elemento de tipo b\u00e1sico. En este caso, simplemente imprime por pantalla su valor (e.g. en el caso de un entero, caso CborIntegerType ). Tarea entregable Se pide extender la API REST con un nuevo endpoint que permita obtener la misma informaci\u00f3n que el endpoint JSON desarrollado en la anterior tarea, pero en esta ocasi\u00f3n, utilizando formato CBOR. El objetivo del ejercicio es comparar la cantidad de tr\u00e1fico generado en cada representaci\u00f3n, por lo que se sugiere que el objeto intercambiado sea relativamente complejo (es decir, incluya disintos tipos de datos num\u00e9ricos, arrays, o mapas). A continuaci\u00f3n se incluyen notas adicionales que te permitir\u00e1n depurar tu desarrollo, observando los valores devueltos por el servidor HTTP.","title":"Etapa 3: parseado manual de un objeto CBOR"},{"location":"Subjects/NP2/P5/#notas-adicionales-creacion-y-consulta-de-un-endpoint-cbor-en-la-api-rest","text":"Las modificaciones a realizar en la funci\u00f3n manejadora del endpoint para responder con un objeto CBOR son m\u00ednimas. De hecho, se centran simplemente en el tipo de respuesta y el mecanismo a usar para enviarla, v\u00e9ase: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Tipo de respuesta. httpd_resp_set_type(req, \"application/cbor\"); CborEncoder root_encoder; uint8_t buf[100]; // Codificador CBOR. cbor_encoder_init(&root_encoder, buf, sizeof(buf), 0); // Codificamos CBOR. // ... // Enviamos respuesta, consultando previamente el tama\u00f1o del buffer codificado. httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &root_encoder, buf)); return ESP_OK; Para consultar desde l\u00ednea de comandos sobre este endpoint , podemos utilizar directamente curl , volcando la salida recibida a un fichero (por ejemplo, output.cbor ): curl http://192.168.1.26/api/v1/system/info > output.cbor Si visualizas el contenido del fichero, ver\u00e1s que contiene datos binarios dif\u00edcilmente interpretables. A continuaci\u00f3n veremos distintos mecanismos de visualizaci\u00f3n.","title":"Notas adicionales: creaci\u00f3n y consulta de un endpoint CBOR en la API REST"},{"location":"Subjects/NP2/P5/#notas-adicionales-visualizacion-de-datos-cbor","text":"Una opci\u00f3n de visualizaci\u00f3n consiste en utilizar la web cbor.me . En el panel derecho, podr\u00e1s pegar el contenido binario le\u00eddo. Si necesitas realizar la conversi\u00f3n antes de pegarlo en la web, puedes hacerlo con la orden: xxd -ps output.cbor Un ejemplo de salida (a pegar en el panel derecho de la web), podr\u00eda ser: $ xxd -ps output.cbor 85a3646368697065657370333267756e69636f7265f46269708418c018a8 011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30 302b30303030f7 Deber\u00edas observar una salida similar a la siguiente (ten en cuenta que la herramiente autom\u00e1ticamente indenta el contenido del panel derecho; recuerda que simplemente debes pegar la salida generada por xxd ): Otra opci\u00f3n de visualizaci\u00f3n puede ser un programa Python (podr\u00edas integrarlo en tu servidor TCP/UDP, por ejemplo), que haga uso del m\u00f3dulo cbor2 ( documentaci\u00f3n ). Para comprobar su funcionamiento, primero inst\u00e1lalo: pip install cbor2 Y comprueba si efectivamente funciona utilizando el siguiente programa Python: from cbor2 import dumps, loads, dump, load with open('output.cbor', 'rb') as fp: obj = load(fp) print(obj) Al ejecutarlo, observar\u00e1s el contenido del objeto: python cbor.py [{'chip': 'esp32', 'unicore': False, 'ip': [192, 168, 1, 100]}, 3.140000104904175, CBORSimpleValue(value=99), '2019-07-10 09:00:00+0000', undefined]","title":"Notas adicionales: visualizaci\u00f3n de datos CBOR"},{"location":"Subjects/NP2/P5/notas/","text":"Implementaci\u00f3n de una interfaz REST v\u00eda HTTP Ejemplo Ejemplo: restful_server navegar a front/webdemo apt-get install npm node-vue* npm install y npm run build en direcrorio front/web-demo idf.py build","title":"Notas"},{"location":"Subjects/NP2/P5/notas/#implementacion-de-una-interfaz-rest-via-http","text":"","title":"Implementaci\u00f3n de una interfaz REST v\u00eda HTTP"},{"location":"Subjects/NP2/P5/notas/#ejemplo","text":"Ejemplo: restful_server navegar a front/webdemo apt-get install npm node-vue* npm install y npm run build en direcrorio front/web-demo idf.py build","title":"Ejemplo"},{"location":"Subjects/NP2/P6/","text":"Pr\u00e1ctica 6. El protocolo MQTT (I). Despliegue de clientes y servidores/ brokers . An\u00e1lisis de tr\u00e1fico Objetivos Familiarizarse con el uso de brokers y clientes de suscripci\u00f3n/publicaci\u00f3n utilizando MQTT. Desplegar un sistema basado en MQTT local, incluyendo broker y clientes. Utilizar Eclipse Paho para integrar funcionalidad MQTT en programas Python. Familiarizarse con el uso de wildcards MQTT. Publicaci\u00f3n/suscripci\u00f3n contra un broker en la nube En la primera parte de la pr\u00e1ctica, utilizaremos un servidor/ broker disponible en la nube para su uso libre por parte de los usuarios ( test.mosquitto.org ). Este servidor suele utilizarse con fines de pruebas b\u00e1sicas y depuraci\u00f3n, y hay que ser consciente de que toda la informaci\u00f3n que en \u00e9l se publica puede ser le\u00edda por cualquier suscriptor. Debe tenerse este dato en cuenta a la hora de publicar informaci\u00f3n sensible a trav\u00e9s de MQTT cuando se use el servidor de pruebas. El servidor escucha en los siguientes puertos: 1883 : MQTT, sin encriptaci\u00f3n. 8883 : MQTT, con encriptaci\u00f3n. 8884 : MQTT, con encriptaci\u00f3n, certificado de cliente requerido. 8080 : MQTT sobre WebSockets, sin encriptaci\u00f3n. 8081 : MQTT sobre WebSockets, con encriptaci\u00f3n. Para realizar publicaciones/suscripciones contra el broker utilizaremos la distribuci\u00f3n mosquitto del proyecto Eclipse IoT. Aunque mosquitto es principalmente una implementaci\u00f3n de broker MQTT, nosotros la utilizaremos en este paso a modo de cliente, lo que nos permitir\u00e1 suscribirnos o publicar sobre cualquier topic MQTT. En primer lugar, instala mosquitto : sudo apt-get install mosquitto mosquitto-clients mosquitto-dev libmosquitto* Si todo ha ido bien, deber\u00edas disponer de dos binarios listos para ejecuci\u00f3n: mosquitto_sub : permite suscribirse a un determinado topic utilizando un broker . mosquitto_pub : permite publicar un mensaje asociado a un determinado topic utilizando un broker . Tarea Observa la ayuda de ambas ordenes, utilizando el argumento --help . Identifica los par\u00e1metros que te permitir\u00e1n especificar el broker destino, el topic a utilizar y, en el caso de la publicaci\u00f3n, el mensaje a enviar. Suscrib\u00e1monos al topic # en el broker , utilizando para ello la orden: mosquitto_sub -h test.mosquitto.org -t \"#\" Tarea Pausa la salida en cuanto puedas. \u00bfA qu\u00e9 corresponden los mensajes que est\u00e1s obteniendo? A continuaci\u00f3n, vamos a realizar un proceso de publicaci\u00f3n/suscripcion con un topic conocido (por ejemplo, /MIOT/tunombre/ ). Para publicar un mensaje bajo dicho topic : mosquitto_pub -h test.mosquitto.org -t \"/MIOT/tunombre\" -m \"Hola, soy tunombre\" Tarea Suscr\u00edbete al topic /MIOT/tunombre y observa si recibes los resultados tras la publicaci\u00f3n correspondiente. \u00bfC\u00f3mo podr\u00edas suscribirte a todos los mensajes publicados por compa\u00f1eros? Tarea entregable Realiza un an\u00e1lisis del intercambio de mensajes necesario para un proceso de publicaci\u00f3n/suscripci\u00f3n contra el broker de test. Incide en el tipo de protocolo de capa de transporte que utiliza MQTT, mensajes de datos y control, sobrecarga del protocolo de capa de aplicaci\u00f3n, y en general, cualquier aspecto que consideres de inter\u00e9s. Despliegue de un broker local usando Eclipse Mosquitto El uso de un servidor remoto presenta ventajas (facilidad de uso), pero una gran cantidad de inconvenientes (seguridad, imposibilidad de configuraci\u00f3n avanzada, ...) En esta secci\u00f3n, configuraremos un broker mosquitto para el despliegue de una infraestructura MQTT local o remota bajo nuestro control. El arranque de un broker (servidor) mosquitto se realiza mediante el propio comando mosquitto : mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] Sin embargo, en la mayor\u00eda de distribuciones Linux, el broker arranca por defecto y se ejecuta constantemente en segundo plano. Para comprobar el estado de funcionamiento del broker , basta con ejecutar: sudo service mosquitto status Observar\u00e1s un mensaje que indica que el servicio est\u00e1 activo. Las opciones restart , start o stop te permitir\u00e1n controlar el estado del broker en todo momento. Tarea Comprueba que, con el broker arrancado, puedes realizar un proceso de suscripci\u00f3n/publicaci\u00f3n contra el mismo. El broker mosquitto permite monitorizar sus propias estad\u00edsticas e informaci\u00f3n de estado utilizando el protocolo MQTT. As\u00ed, los topics $SYS retornan, bien peri\u00f3dicamente o bien cuando sucede un evento de inter\u00e9s, la informaci\u00f3n de estado del broker . Puedes consultar m\u00e1s detalles en la p\u00e1gina de manual de mosquitto (comando man mosquitto ), en el ep\u00edgrafe BROKER STATUS . Note Comprueba el estado del broker mientras realizas procesos de suscripci\u00f3n/publicaci\u00f3n reportando bytes recibidos/enviados, n\u00famero de conexiones activas e inactivas, y n\u00famero de mensajes enviados/recibidos por el broker . Desarrollo de un cliente local usando Eclipse Paho Los clientes mosquitto_pub y mosquitto_sub son b\u00e1sicamente herramientas de desarrollo y pruebas, pero resulta interesante conocer bibliotecas que permitan la integraci\u00f3n de MQTT en programas existentes. Una de ellas es Eclipse Paho . Paho es una infraestructura desarrollada en el proyecto Eclipse IoT para dar soporte a implementaciones de protocolos de mensajer\u00eda M2M e IoT, aunque, en este momento, su uso principal se centra exclusivamente en MQTT. En nuestro caso, utilizaremos la versi\u00f3n Python de la biblioteca, instalable v\u00eda: pip install paho-mqtt Dispones de la documentaci\u00f3n del m\u00f3dulo a trav\u00e9s de este enlace . El despliegue de un ejemplo sencillo para un cliente que se conecta a un broker y se suscribe al t\u00f3pico $SYS , imprimiendo los mensajes recibidos, resultar\u00eda, utilizando Paho, en el siguiente c\u00f3digo Python: import paho.mqtt.client as mqtt # Funcion callback invocada cuandl el cliente recibe un CONNACK desde el broker. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \"+str(rc)) # Suscribirse en on_connect() asegura que si se pierde la conexi\u00f3n y # se reestablece, las suscripciones se renovar\u00e1n. client.subscribe(\"$SYS/#\") # Funcion callback al recibir un mensaje de publicacion (PUBLISH) desde el # broker. def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"mqtt.eclipse.org\", 1883, 60) # Llamada bloqueante que procesa el tr\u00e1fico de red, invoca callbacks # y maneja la reconexi\u00f3n al broker. client.loop_forever() La clase cliente puede utilizarse para: Crear una instancia de cliente MQTT. Conectar a un broker usando las funciones de la familia connect*() . Invocar a funciones de la familia loop*() para mantener el tr\u00e1fico de datos con el servidor. Utilizar subscribe() para suscribirse a un topic y recibir mensajes. Utilizar publish() publicar mensajes en el broker . Utilizar disconnect() para desconectar del broker . Los callbacks se invocar\u00e1n autom\u00e1ticamente para permitir el procesamiento de eventos. De entre los m\u00e1s utilizados, destacan: ON_CONNECT : invocado cuando el broker responde a nuestra petici\u00f3n de conexi\u00f3n. Ejemplo: def on_connect(client, userdata, flags, rc): print(\"Connection returned result: \"+connack_string(rc)) ON_DISCONNECT : invocado cuando el cliente se desconecta del broker . Ejemplo: def on_disconnect(client, userdata, rc): if rc != 0: print(\"Unexpected disconnection.\") ON_MESSAGE : invocado cuando se recibe un mensaje en un topic al que el cliente est\u00e1 suscrito. Ejemplo: def on_message(client, userdata, message): print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos)) Para publicar de forma puntual sobre un broker (sin mantener una conexi\u00f3n establecida), es posible utilizar la siguiente secuencia de ordenes: import paho.mqtt.publish as publish publish.single(\"paho/test/single\", \"payload\", hostname=\"mqtt.eclipse.org\") Del mismo modo, podemos suscribirnos de forma puntual mediante una llamada bloqueante a: import paho.mqtt.subscribe as subscribe msg = subscribe.simple(\"paho/test/simple\", hostname=\"mqtt.eclipse.org\") print(\"%s %s\" % (msg.topic, msg.payload)) Toda la informaci\u00f3n y documentaci\u00f3n asociada al m\u00f3dulo puede consultarse aqu\u00ed . Wildcards Adem\u00e1s de permitir el uso de topics completos para el proceso de suscripci\u00f3n, los topics pueden incluir wildcards o comodines en su estructura. + es la wildcard utilizada para obtener correspondencias con un \u00fanico nivel de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d +/b/c/d a/+/c/d a/+/+/d +/+/+/+ Pero no las siguientes: a/b/c b/+/c/d +/+/+ La segunda wildcard soportada es # , y permite corresponencias con cualquier nivel sucesivo de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d # a/# a/b/# a/b/c/# +/b/c/# Tarea entregable Cada alumno propondr\u00e1 una soluci\u00f3n para monitorizar un edificio inteligente a trav\u00e9s de un sistema de mensajer\u00eda MQTT. Para ello, cabe destacar que el edificio constar\u00e1 de: Un identificador del tipo EDIFICIO_TUPUESTODELABORATORIO. Un conjunto de plantas, identificadas por la cadena \"P_NUMPLANTA\". En cada planta, cuatro alas (norte -N-, sur -S-, este -E-, oeste -O-) En cada ala, un conjunto de salas, identificadas por un valor num\u00e9rico. En cada sala, cuatro sensores: TEMP (temperatura), HUM (humedad), LUX (luminosidad), VIBR (vibraci\u00f3n). Se pide, en primer lugar, dise\u00f1ar la jerarqu\u00eda de topics que permita una correcta monitorizaci\u00f3n de los edificios. En segundo lugar, se desarrollar\u00e1 un programa Python cliente que publique, peri\u00f3dicamente y de forma aleatoria, objetos JSON (opcionalmente puedes utilizar CBOR) que incluyan el valor de temperatura, humedad, luminosidad o vibraci\u00f3n para una determinada sala del edificio, elegida tambi\u00e9n aleatoriamente, a trav\u00e9s del topic correspondiente. Estos mensajes estar\u00e1n espaciados en el tiempo un n\u00famero aleatorio de segundos. En tercer lugar, se piden las wildcards que permitan consultar distintos tipos de informaci\u00f3n jer\u00e1rquica. Por ejemplo: Todos los mensajes de temperatura para el edificio. Todos los mensajes de vibraci\u00f3n del ala oeste de la planta 2 del edificio. Todos los mensajes de sensorizaci\u00f3n de la sala 4 del ala Sur de la planta 7 del edificio. ... En \u00faltimo lugar, se pide desarrollar un programa Python que act\u00fae a modo de alarma, y que muestre mensajes s\u00f3lo si alg\u00fan valor recibido para los datos sensorizados supera un umbral preestablecido. En dicho caso, el programa mostrar\u00e1 el edificio, planta, ala, sala y sensor que ha producido la alarma, junto con su valor num\u00e9rico. Puedes utilizar el m\u00f3dulo JSON para parsear los objetos recibidos.","title":"Pr\u00e1ctica 6. El protocolo MQTT (I). Despliegue de clientes y servidores/*brokers*. An\u00e1lisis de tr\u00e1fico"},{"location":"Subjects/NP2/P6/#practica-6-el-protocolo-mqtt-i-despliegue-de-clientes-y-servidoresbrokers-analisis-de-trafico","text":"","title":"Pr\u00e1ctica 6. El protocolo MQTT (I). Despliegue de clientes y servidores/brokers. An\u00e1lisis de tr\u00e1fico"},{"location":"Subjects/NP2/P6/#objetivos","text":"Familiarizarse con el uso de brokers y clientes de suscripci\u00f3n/publicaci\u00f3n utilizando MQTT. Desplegar un sistema basado en MQTT local, incluyendo broker y clientes. Utilizar Eclipse Paho para integrar funcionalidad MQTT en programas Python. Familiarizarse con el uso de wildcards MQTT.","title":"Objetivos"},{"location":"Subjects/NP2/P6/#publicacionsuscripcion-contra-un-broker-en-la-nube","text":"En la primera parte de la pr\u00e1ctica, utilizaremos un servidor/ broker disponible en la nube para su uso libre por parte de los usuarios ( test.mosquitto.org ). Este servidor suele utilizarse con fines de pruebas b\u00e1sicas y depuraci\u00f3n, y hay que ser consciente de que toda la informaci\u00f3n que en \u00e9l se publica puede ser le\u00edda por cualquier suscriptor. Debe tenerse este dato en cuenta a la hora de publicar informaci\u00f3n sensible a trav\u00e9s de MQTT cuando se use el servidor de pruebas. El servidor escucha en los siguientes puertos: 1883 : MQTT, sin encriptaci\u00f3n. 8883 : MQTT, con encriptaci\u00f3n. 8884 : MQTT, con encriptaci\u00f3n, certificado de cliente requerido. 8080 : MQTT sobre WebSockets, sin encriptaci\u00f3n. 8081 : MQTT sobre WebSockets, con encriptaci\u00f3n. Para realizar publicaciones/suscripciones contra el broker utilizaremos la distribuci\u00f3n mosquitto del proyecto Eclipse IoT. Aunque mosquitto es principalmente una implementaci\u00f3n de broker MQTT, nosotros la utilizaremos en este paso a modo de cliente, lo que nos permitir\u00e1 suscribirnos o publicar sobre cualquier topic MQTT. En primer lugar, instala mosquitto : sudo apt-get install mosquitto mosquitto-clients mosquitto-dev libmosquitto* Si todo ha ido bien, deber\u00edas disponer de dos binarios listos para ejecuci\u00f3n: mosquitto_sub : permite suscribirse a un determinado topic utilizando un broker . mosquitto_pub : permite publicar un mensaje asociado a un determinado topic utilizando un broker . Tarea Observa la ayuda de ambas ordenes, utilizando el argumento --help . Identifica los par\u00e1metros que te permitir\u00e1n especificar el broker destino, el topic a utilizar y, en el caso de la publicaci\u00f3n, el mensaje a enviar. Suscrib\u00e1monos al topic # en el broker , utilizando para ello la orden: mosquitto_sub -h test.mosquitto.org -t \"#\" Tarea Pausa la salida en cuanto puedas. \u00bfA qu\u00e9 corresponden los mensajes que est\u00e1s obteniendo? A continuaci\u00f3n, vamos a realizar un proceso de publicaci\u00f3n/suscripcion con un topic conocido (por ejemplo, /MIOT/tunombre/ ). Para publicar un mensaje bajo dicho topic : mosquitto_pub -h test.mosquitto.org -t \"/MIOT/tunombre\" -m \"Hola, soy tunombre\" Tarea Suscr\u00edbete al topic /MIOT/tunombre y observa si recibes los resultados tras la publicaci\u00f3n correspondiente. \u00bfC\u00f3mo podr\u00edas suscribirte a todos los mensajes publicados por compa\u00f1eros? Tarea entregable Realiza un an\u00e1lisis del intercambio de mensajes necesario para un proceso de publicaci\u00f3n/suscripci\u00f3n contra el broker de test. Incide en el tipo de protocolo de capa de transporte que utiliza MQTT, mensajes de datos y control, sobrecarga del protocolo de capa de aplicaci\u00f3n, y en general, cualquier aspecto que consideres de inter\u00e9s.","title":"Publicaci\u00f3n/suscripci\u00f3n contra un broker en la nube"},{"location":"Subjects/NP2/P6/#despliegue-de-un-broker-local-usando-eclipse-mosquitto","text":"El uso de un servidor remoto presenta ventajas (facilidad de uso), pero una gran cantidad de inconvenientes (seguridad, imposibilidad de configuraci\u00f3n avanzada, ...) En esta secci\u00f3n, configuraremos un broker mosquitto para el despliegue de una infraestructura MQTT local o remota bajo nuestro control. El arranque de un broker (servidor) mosquitto se realiza mediante el propio comando mosquitto : mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] Sin embargo, en la mayor\u00eda de distribuciones Linux, el broker arranca por defecto y se ejecuta constantemente en segundo plano. Para comprobar el estado de funcionamiento del broker , basta con ejecutar: sudo service mosquitto status Observar\u00e1s un mensaje que indica que el servicio est\u00e1 activo. Las opciones restart , start o stop te permitir\u00e1n controlar el estado del broker en todo momento. Tarea Comprueba que, con el broker arrancado, puedes realizar un proceso de suscripci\u00f3n/publicaci\u00f3n contra el mismo. El broker mosquitto permite monitorizar sus propias estad\u00edsticas e informaci\u00f3n de estado utilizando el protocolo MQTT. As\u00ed, los topics $SYS retornan, bien peri\u00f3dicamente o bien cuando sucede un evento de inter\u00e9s, la informaci\u00f3n de estado del broker . Puedes consultar m\u00e1s detalles en la p\u00e1gina de manual de mosquitto (comando man mosquitto ), en el ep\u00edgrafe BROKER STATUS . Note Comprueba el estado del broker mientras realizas procesos de suscripci\u00f3n/publicaci\u00f3n reportando bytes recibidos/enviados, n\u00famero de conexiones activas e inactivas, y n\u00famero de mensajes enviados/recibidos por el broker .","title":"Despliegue de un broker local usando Eclipse Mosquitto"},{"location":"Subjects/NP2/P6/#desarrollo-de-un-cliente-local-usando-eclipse-paho","text":"Los clientes mosquitto_pub y mosquitto_sub son b\u00e1sicamente herramientas de desarrollo y pruebas, pero resulta interesante conocer bibliotecas que permitan la integraci\u00f3n de MQTT en programas existentes. Una de ellas es Eclipse Paho . Paho es una infraestructura desarrollada en el proyecto Eclipse IoT para dar soporte a implementaciones de protocolos de mensajer\u00eda M2M e IoT, aunque, en este momento, su uso principal se centra exclusivamente en MQTT. En nuestro caso, utilizaremos la versi\u00f3n Python de la biblioteca, instalable v\u00eda: pip install paho-mqtt Dispones de la documentaci\u00f3n del m\u00f3dulo a trav\u00e9s de este enlace . El despliegue de un ejemplo sencillo para un cliente que se conecta a un broker y se suscribe al t\u00f3pico $SYS , imprimiendo los mensajes recibidos, resultar\u00eda, utilizando Paho, en el siguiente c\u00f3digo Python: import paho.mqtt.client as mqtt # Funcion callback invocada cuandl el cliente recibe un CONNACK desde el broker. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \"+str(rc)) # Suscribirse en on_connect() asegura que si se pierde la conexi\u00f3n y # se reestablece, las suscripciones se renovar\u00e1n. client.subscribe(\"$SYS/#\") # Funcion callback al recibir un mensaje de publicacion (PUBLISH) desde el # broker. def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"mqtt.eclipse.org\", 1883, 60) # Llamada bloqueante que procesa el tr\u00e1fico de red, invoca callbacks # y maneja la reconexi\u00f3n al broker. client.loop_forever() La clase cliente puede utilizarse para: Crear una instancia de cliente MQTT. Conectar a un broker usando las funciones de la familia connect*() . Invocar a funciones de la familia loop*() para mantener el tr\u00e1fico de datos con el servidor. Utilizar subscribe() para suscribirse a un topic y recibir mensajes. Utilizar publish() publicar mensajes en el broker . Utilizar disconnect() para desconectar del broker . Los callbacks se invocar\u00e1n autom\u00e1ticamente para permitir el procesamiento de eventos. De entre los m\u00e1s utilizados, destacan: ON_CONNECT : invocado cuando el broker responde a nuestra petici\u00f3n de conexi\u00f3n. Ejemplo: def on_connect(client, userdata, flags, rc): print(\"Connection returned result: \"+connack_string(rc)) ON_DISCONNECT : invocado cuando el cliente se desconecta del broker . Ejemplo: def on_disconnect(client, userdata, rc): if rc != 0: print(\"Unexpected disconnection.\") ON_MESSAGE : invocado cuando se recibe un mensaje en un topic al que el cliente est\u00e1 suscrito. Ejemplo: def on_message(client, userdata, message): print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos)) Para publicar de forma puntual sobre un broker (sin mantener una conexi\u00f3n establecida), es posible utilizar la siguiente secuencia de ordenes: import paho.mqtt.publish as publish publish.single(\"paho/test/single\", \"payload\", hostname=\"mqtt.eclipse.org\") Del mismo modo, podemos suscribirnos de forma puntual mediante una llamada bloqueante a: import paho.mqtt.subscribe as subscribe msg = subscribe.simple(\"paho/test/simple\", hostname=\"mqtt.eclipse.org\") print(\"%s %s\" % (msg.topic, msg.payload)) Toda la informaci\u00f3n y documentaci\u00f3n asociada al m\u00f3dulo puede consultarse aqu\u00ed .","title":"Desarrollo de un cliente local usando Eclipse Paho"},{"location":"Subjects/NP2/P6/#wildcards","text":"Adem\u00e1s de permitir el uso de topics completos para el proceso de suscripci\u00f3n, los topics pueden incluir wildcards o comodines en su estructura. + es la wildcard utilizada para obtener correspondencias con un \u00fanico nivel de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d +/b/c/d a/+/c/d a/+/+/d +/+/+/+ Pero no las siguientes: a/b/c b/+/c/d +/+/+ La segunda wildcard soportada es # , y permite corresponencias con cualquier nivel sucesivo de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d # a/# a/b/# a/b/c/# +/b/c/# Tarea entregable Cada alumno propondr\u00e1 una soluci\u00f3n para monitorizar un edificio inteligente a trav\u00e9s de un sistema de mensajer\u00eda MQTT. Para ello, cabe destacar que el edificio constar\u00e1 de: Un identificador del tipo EDIFICIO_TUPUESTODELABORATORIO. Un conjunto de plantas, identificadas por la cadena \"P_NUMPLANTA\". En cada planta, cuatro alas (norte -N-, sur -S-, este -E-, oeste -O-) En cada ala, un conjunto de salas, identificadas por un valor num\u00e9rico. En cada sala, cuatro sensores: TEMP (temperatura), HUM (humedad), LUX (luminosidad), VIBR (vibraci\u00f3n). Se pide, en primer lugar, dise\u00f1ar la jerarqu\u00eda de topics que permita una correcta monitorizaci\u00f3n de los edificios. En segundo lugar, se desarrollar\u00e1 un programa Python cliente que publique, peri\u00f3dicamente y de forma aleatoria, objetos JSON (opcionalmente puedes utilizar CBOR) que incluyan el valor de temperatura, humedad, luminosidad o vibraci\u00f3n para una determinada sala del edificio, elegida tambi\u00e9n aleatoriamente, a trav\u00e9s del topic correspondiente. Estos mensajes estar\u00e1n espaciados en el tiempo un n\u00famero aleatorio de segundos. En tercer lugar, se piden las wildcards que permitan consultar distintos tipos de informaci\u00f3n jer\u00e1rquica. Por ejemplo: Todos los mensajes de temperatura para el edificio. Todos los mensajes de vibraci\u00f3n del ala oeste de la planta 2 del edificio. Todos los mensajes de sensorizaci\u00f3n de la sala 4 del ala Sur de la planta 7 del edificio. ... En \u00faltimo lugar, se pide desarrollar un programa Python que act\u00fae a modo de alarma, y que muestre mensajes s\u00f3lo si alg\u00fan valor recibido para los datos sensorizados supera un umbral preestablecido. En dicho caso, el programa mostrar\u00e1 el edificio, planta, ala, sala y sensor que ha producido la alarma, junto con su valor num\u00e9rico. Puedes utilizar el m\u00f3dulo JSON para parsear los objetos recibidos.","title":"Wildcards"},{"location":"Subjects/NP2/P6-II/","text":"Pr\u00e1ctica 6. El protocolo MQTT (II). Despliegue de clientes en el ESP32 Objetivos Familiarizarse con el componente MQTT en ESP-IDF. Desplegar un cliente completo MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n. Implementar QoS y LWT en el ESP32. El componente MQTT en ESP-IDF El componente ESP-MQTT es una implementaci\u00f3n del protocolo MQTT en su parte cliente, que permite la implementaci\u00f3n completa de clientes MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n a brokers existentes. El componente soporte MQTT sobre TCP por defecto, as\u00ed como funcionalidades avanzadas como SSL/TLS o MQTT sobre Websockets. Adem\u00e1s, permite el despliegue de m\u00faltiples instancias de cliente MQTT sobre la misma placa; el componente implementa tambi\u00e9n par\u00e1metros avanzados soportados por el protocolo MQTT, como autenticaci\u00f3n (mediante nombre de usuario y contrase\u00f1a), mensajes last will y tres niveles de calidad de servicio (QoS). Eventos Como otros componentes, la interacci\u00f3n entre el cliente MQTT y la aplicaci\u00f3n se basa en la recepci\u00f3n de eventos, entre los que destacan: MQTT_EVENT_BEFORE_CONNECT : El cliente se ha inicializado y va a comenzar el proceso de conexi\u00f3n con el broker . MQTT_EVENT_CONNECTED : El cliente ha establecido de forma exitosa una conexi\u00f3n con el broker y est\u00e1 listo para enviar y recibir datos. MQTT_EVENT_DISCONNECTED : El cliente ha abortado la conexi\u00f3n. MQTT_EVENT_SUBSCRIBED : El broker ha confirmado la petici\u00f3n de suscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de suscripci\u00f3n. MQTT_EVENT_UNSUBSCRIBED : El broker confirma la petici\u00f3n de desuscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de desuscripci\u00f3n . MQTT_EVENT_PUBLISHED : El broker ha acusado la recepci\u00f3n de un mensaje previamente publicado por el cliente. Este evento s\u00f3lo se producir\u00e1 cuando QoS sea 1 o 2, ya que el nivel 0 de QoS no utiliza acuses de recibo. Los datos asociados al evento contendr\u00e1n el ID del mensaje publicado. MQTT_EVENT_DATA : El cliente ha recibido un mensaje publicado en el broker . Los datos asociados al evento contienen el ID del mensaje, nombre del topic , datos recibidos y su longitud. API esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config) Rutina de inicializaci\u00f3n del cliente MQTT. Devuelve un manejador de la conexi\u00f3n, o NULL en caso de error. El par\u00e1metro config es una estructura con los par\u00e1metros que regir\u00e1n la conexi\u00f3n, entre los que destacan (v\u00e9ase la documentaci\u00f3n del componente para par\u00e1metros adicionales): esp_event_loop_handle_t event_loop_handle : manejador para eventos MQTT. const char *uri : URI del broker MQTT. uint32_t port : puerto del broker MQTT. const char *username : nombre de usuario, en caso de estar soportado por el broker . const char *password : contrase\u00f1a, en caso de estar soportada por el broker . const char *lwt_topic : topic del mensaje LWT ( Last Will and Testament ). const char *lwt_msg : contenido del mensaje LWT. int lwt_qos : QoS del mensaje LWT. int lwt_retain : flag retain para el mensaje LWT. int lwt_msg_len : longitud del mensaje LWT. int keepalive : valor del temporizador de keepalive (por defecto 120 segundos). esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) Rutina de arranque del cliente MQTT. Su \u00fanico par\u00e1metro es el manejador devuelto por la anterior rutina. int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) Realiza la suscripci\u00f3n del cliente a un topic con el QoS determinado a trav\u00e9s de su tercer par\u00e1metro. El cliente debe estar conectado al broker para enviar el mensaje de suscripci\u00f3n. int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) Desuscribe al cliente de un determinado topic. El ciente debe estar conectado al broker para poder enviar el mensaje correspondiente. int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) El cliente publica un mensaje en el broker . El cliente no tiene que estar conectado al broker para enviar el mensaje de publicaci\u00f3n. En dicho caso, si qos=0 , los mensajes se descartar\u00e1n, y si qos>=1 , los mensajes se encolar\u00e1n a la espera de ser enviados. Devuelve el identificador del mensaje publicado (si qos=0 , el valor de retorno siempre ser\u00e1 0), o -1 en caso de error. Par\u00e1metros de inter\u00e9s: client : manejador del cliente MQTT. topic : topic (en forma de cadena) bajo el cual se publicar\u00e1 el mensaje. data : contenido del mensaje a publicar (es posible publicar un mensaje sin contenido, en cuyo caso se proporcionar\u00e1 un valor NULL en este par\u00e1metro). len : longitud de los datos a enviar. Si se proporciona el valor 0 , se calcula su longitud a partir de la cadena data . qos : nivel de QoS deseado. retain : flag Retain . Tarea Analiza el ejemplo examples/protocols/mqtt/tcp , y configuralo para que utilice como broker el que desplegaste en la m\u00e1quina virtual (aseg\u00farate de que tanto m\u00e1quina virtual como ESP32 pertenecen a la misma red). Realiza procesos de publicaci\u00f3n y suscripci\u00f3n en la m\u00e1quina virtual que permitan visualizar los mensajes publicados por el ESP32 en tu terminal Linux, y los mensajes publicados desde el terminal Linux en la salida de monitorizaci\u00f3n del ESP32. Modifica el ejemplo y analiza el tr\u00e1fico generado (a trav\u00e9s de Wireshark) para los siguientes casos: Publicaci\u00f3n de mensajes con niveles de QoS 0, 1 y 2. Activaci\u00f3n o desactivaci\u00f3n del flag retain en la publicaci\u00f3n desde el ESP32. Configuraci\u00f3n de un mensaje LWT con el topic /disconnected . Para ello, reduce el valor de keepalive a 10 segundos, para que la detecci\u00f3n de desconexi\u00f3n sea m\u00e1s r\u00e1pida. Deber\u00e1s observar el env\u00edo del mensaje con dicho topic transcurrido dicho tiempo desde una desconexi\u00f3n forzada del ESP32 si est\u00e1s suscrito al mismo desde tu terminal Linux. Tarea Modifica el ejemplo proporcionado para que se integre en tu entorno de monitorizaci\u00f3n de un edificio. As\u00ed, el firmware proceder\u00e1 creando una tarea que, peri\u00f3dicamente (cada interval segundos), publique un valor aleatorio para los cuatro par\u00e1metros monitorizados. Adem\u00e1s, deber\u00e1s dise\u00f1a un sistema basado en MQTT mediante el cual puedas controlar, externamente, el comportamiento del sensor, atendiendo a los siguientes criterios: El tiempo ( interval ) mediante que transcurrir\u00e1 entre publicaciones ser\u00e1 configurable a trav\u00e9s de un proceso de publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. La sensorizaci\u00f3n (y publicaci\u00f3n de datos) podr\u00e1 activarse o desactivarse bajo demanda a trav\u00e9s de la publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. Por ejemplo, imagina que tu sensor publica mensajes de sensorizaci\u00f3n en el topic /EDIFICIO_3/P_4/N/12/(TEMP|HUM|LUX|VIBR) . Para controlar el intervalo de publicaci\u00f3n de datos desde dicho ESP32 y fijarlo a 1 segundo, podr\u00edamos publicar un mensaje utilizando la orden: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/interval -m \"1000\" -h IP_BROKER Para desactivar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/disable -m \"\" -h IP_BROKER Para activar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/enable -m \"\" -h IP_BROKER Opcionalmente, puedes ampliar tu soluci\u00f3n para que cada sensor se active o desactive individualmente bajo demanda. En este caso, elige y documenta el topic utilizado.","title":"Pr\u00e1ctica 6. El protocolo MQTT (II). Despliegue de clientes en el ESP32"},{"location":"Subjects/NP2/P6-II/#practica-6-el-protocolo-mqtt-ii-despliegue-de-clientes-en-el-esp32","text":"","title":"Pr\u00e1ctica 6. El protocolo MQTT (II). Despliegue de clientes en el ESP32"},{"location":"Subjects/NP2/P6-II/#objetivos","text":"Familiarizarse con el componente MQTT en ESP-IDF. Desplegar un cliente completo MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n. Implementar QoS y LWT en el ESP32.","title":"Objetivos"},{"location":"Subjects/NP2/P6-II/#el-componente-mqtt-en-esp-idf","text":"El componente ESP-MQTT es una implementaci\u00f3n del protocolo MQTT en su parte cliente, que permite la implementaci\u00f3n completa de clientes MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n a brokers existentes. El componente soporte MQTT sobre TCP por defecto, as\u00ed como funcionalidades avanzadas como SSL/TLS o MQTT sobre Websockets. Adem\u00e1s, permite el despliegue de m\u00faltiples instancias de cliente MQTT sobre la misma placa; el componente implementa tambi\u00e9n par\u00e1metros avanzados soportados por el protocolo MQTT, como autenticaci\u00f3n (mediante nombre de usuario y contrase\u00f1a), mensajes last will y tres niveles de calidad de servicio (QoS).","title":"El componente MQTT en ESP-IDF"},{"location":"Subjects/NP2/P6-II/#eventos","text":"Como otros componentes, la interacci\u00f3n entre el cliente MQTT y la aplicaci\u00f3n se basa en la recepci\u00f3n de eventos, entre los que destacan: MQTT_EVENT_BEFORE_CONNECT : El cliente se ha inicializado y va a comenzar el proceso de conexi\u00f3n con el broker . MQTT_EVENT_CONNECTED : El cliente ha establecido de forma exitosa una conexi\u00f3n con el broker y est\u00e1 listo para enviar y recibir datos. MQTT_EVENT_DISCONNECTED : El cliente ha abortado la conexi\u00f3n. MQTT_EVENT_SUBSCRIBED : El broker ha confirmado la petici\u00f3n de suscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de suscripci\u00f3n. MQTT_EVENT_UNSUBSCRIBED : El broker confirma la petici\u00f3n de desuscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de desuscripci\u00f3n . MQTT_EVENT_PUBLISHED : El broker ha acusado la recepci\u00f3n de un mensaje previamente publicado por el cliente. Este evento s\u00f3lo se producir\u00e1 cuando QoS sea 1 o 2, ya que el nivel 0 de QoS no utiliza acuses de recibo. Los datos asociados al evento contendr\u00e1n el ID del mensaje publicado. MQTT_EVENT_DATA : El cliente ha recibido un mensaje publicado en el broker . Los datos asociados al evento contienen el ID del mensaje, nombre del topic , datos recibidos y su longitud.","title":"Eventos"},{"location":"Subjects/NP2/P6-II/#api","text":"esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config) Rutina de inicializaci\u00f3n del cliente MQTT. Devuelve un manejador de la conexi\u00f3n, o NULL en caso de error. El par\u00e1metro config es una estructura con los par\u00e1metros que regir\u00e1n la conexi\u00f3n, entre los que destacan (v\u00e9ase la documentaci\u00f3n del componente para par\u00e1metros adicionales): esp_event_loop_handle_t event_loop_handle : manejador para eventos MQTT. const char *uri : URI del broker MQTT. uint32_t port : puerto del broker MQTT. const char *username : nombre de usuario, en caso de estar soportado por el broker . const char *password : contrase\u00f1a, en caso de estar soportada por el broker . const char *lwt_topic : topic del mensaje LWT ( Last Will and Testament ). const char *lwt_msg : contenido del mensaje LWT. int lwt_qos : QoS del mensaje LWT. int lwt_retain : flag retain para el mensaje LWT. int lwt_msg_len : longitud del mensaje LWT. int keepalive : valor del temporizador de keepalive (por defecto 120 segundos). esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) Rutina de arranque del cliente MQTT. Su \u00fanico par\u00e1metro es el manejador devuelto por la anterior rutina. int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) Realiza la suscripci\u00f3n del cliente a un topic con el QoS determinado a trav\u00e9s de su tercer par\u00e1metro. El cliente debe estar conectado al broker para enviar el mensaje de suscripci\u00f3n. int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) Desuscribe al cliente de un determinado topic. El ciente debe estar conectado al broker para poder enviar el mensaje correspondiente. int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) El cliente publica un mensaje en el broker . El cliente no tiene que estar conectado al broker para enviar el mensaje de publicaci\u00f3n. En dicho caso, si qos=0 , los mensajes se descartar\u00e1n, y si qos>=1 , los mensajes se encolar\u00e1n a la espera de ser enviados. Devuelve el identificador del mensaje publicado (si qos=0 , el valor de retorno siempre ser\u00e1 0), o -1 en caso de error. Par\u00e1metros de inter\u00e9s: client : manejador del cliente MQTT. topic : topic (en forma de cadena) bajo el cual se publicar\u00e1 el mensaje. data : contenido del mensaje a publicar (es posible publicar un mensaje sin contenido, en cuyo caso se proporcionar\u00e1 un valor NULL en este par\u00e1metro). len : longitud de los datos a enviar. Si se proporciona el valor 0 , se calcula su longitud a partir de la cadena data . qos : nivel de QoS deseado. retain : flag Retain . Tarea Analiza el ejemplo examples/protocols/mqtt/tcp , y configuralo para que utilice como broker el que desplegaste en la m\u00e1quina virtual (aseg\u00farate de que tanto m\u00e1quina virtual como ESP32 pertenecen a la misma red). Realiza procesos de publicaci\u00f3n y suscripci\u00f3n en la m\u00e1quina virtual que permitan visualizar los mensajes publicados por el ESP32 en tu terminal Linux, y los mensajes publicados desde el terminal Linux en la salida de monitorizaci\u00f3n del ESP32. Modifica el ejemplo y analiza el tr\u00e1fico generado (a trav\u00e9s de Wireshark) para los siguientes casos: Publicaci\u00f3n de mensajes con niveles de QoS 0, 1 y 2. Activaci\u00f3n o desactivaci\u00f3n del flag retain en la publicaci\u00f3n desde el ESP32. Configuraci\u00f3n de un mensaje LWT con el topic /disconnected . Para ello, reduce el valor de keepalive a 10 segundos, para que la detecci\u00f3n de desconexi\u00f3n sea m\u00e1s r\u00e1pida. Deber\u00e1s observar el env\u00edo del mensaje con dicho topic transcurrido dicho tiempo desde una desconexi\u00f3n forzada del ESP32 si est\u00e1s suscrito al mismo desde tu terminal Linux. Tarea Modifica el ejemplo proporcionado para que se integre en tu entorno de monitorizaci\u00f3n de un edificio. As\u00ed, el firmware proceder\u00e1 creando una tarea que, peri\u00f3dicamente (cada interval segundos), publique un valor aleatorio para los cuatro par\u00e1metros monitorizados. Adem\u00e1s, deber\u00e1s dise\u00f1a un sistema basado en MQTT mediante el cual puedas controlar, externamente, el comportamiento del sensor, atendiendo a los siguientes criterios: El tiempo ( interval ) mediante que transcurrir\u00e1 entre publicaciones ser\u00e1 configurable a trav\u00e9s de un proceso de publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. La sensorizaci\u00f3n (y publicaci\u00f3n de datos) podr\u00e1 activarse o desactivarse bajo demanda a trav\u00e9s de la publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. Por ejemplo, imagina que tu sensor publica mensajes de sensorizaci\u00f3n en el topic /EDIFICIO_3/P_4/N/12/(TEMP|HUM|LUX|VIBR) . Para controlar el intervalo de publicaci\u00f3n de datos desde dicho ESP32 y fijarlo a 1 segundo, podr\u00edamos publicar un mensaje utilizando la orden: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/interval -m \"1000\" -h IP_BROKER Para desactivar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/disable -m \"\" -h IP_BROKER Para activar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/enable -m \"\" -h IP_BROKER Opcionalmente, puedes ampliar tu soluci\u00f3n para que cada sensor se active o desactive individualmente bajo demanda. En este caso, elige y documenta el topic utilizado.","title":"API"},{"location":"Subjects/NP2/P7/","text":"Pr\u00e1ctica 7. El protocolo CoAP Objetivos El objetivo de esta pr\u00e1ctica es realizar una introducci\u00f3n al protocolo CoAP, uno de los m\u00e1s extendidos a d\u00eda de hoy para llevar a cabo comunicaciones M2M. Los objetivos did\u00e1cticos de la pr\u00e1ctica son: Entender la estructura cliente-servidor del protocolo CoAP. Comprender los mensajes utilizados para establecer una comunicaci\u00f3n CoAP, tanto a nivel de sintaxis como de sem\u00e1ntica. Modificar una aplicaci\u00f3n cliente/servidor ejemplo basada en libcoap que realice una comunicaci\u00f3n sencilla a trav\u00e9s del protocolo CoAP en un entorno Linux. Estudiar el componente libcoap en ESP-IDF para reproducir el comportamiento del servidor CoAP para ofrecer su fucionalidad desde un ESP32. Instalaci\u00f3n y requisitos previos En esta pr\u00e1ctica realizaremos un estudio del protocolo CoAP utilizando una implementaci\u00f3n ya desarrollada para un sistema cliente/servidor que hace uso del protocolo CoAP, distribuida a trav\u00e9s de la biblioteca libcoap . N\u00f3tese que se trata de una pr\u00e1ctica introductoria, ya que el protocolo CoAP se utilizar\u00e1, en sucesivas pr\u00e1cticas, para dar soporte a protocolos de m\u00e1s alto nivel (principalmente LWM2M). El objetivo principal de la pr\u00e1ctica es, pues, introducir a alto nivel las caracter\u00edsticas de CoAP como protocolo de capa de aplicaci\u00f3n, as\u00ed como ser capaces de interactuar con un servidor existente a trav\u00e9s de herramientas ya desarrolladas. De forma adicional, se estudiar\u00e1 la posibilidad de implementar un servidor CoAP en el ESP32. Instalaci\u00f3n de requisitos adicionales y libcoap En primer lugar, instalemos los prerequisitos necesarios para hacer funcionar {\\tt libcoap}. Para ello, en la m\u00e1quina virtual, ejecutaremos las siguientes \u00f3rdenes: sudo apt-get update sudo apt-get install libtool Procedemos ahora con la instalaci\u00f3n de {\\tt libcoap}. Para ello, descarga la \u00faltima versi\u00f3n de la biblioteca desde la p\u00e1gina web del proyecto, descompr\u00edmelo y pasa a la fase de compilaci\u00f3n e instalaci\u00f3n: sh autogen.sh ./configure --enable-examples --enable-dtls --with-openssl --disable-documentation make make install Si no hay ning\u00fan error, libcoap se habr\u00e1 instalado con \u00e9xito. Ser\u00e1 de especial inter\u00e9s para nosotros la instalaci\u00f3n de programas servidor ( coap-server ) y cliente ( coap-client ) de ejemplo en el directorio examples . Tarea Ejecuta los programas servidor y cliente CoAP del directorio examples . Estudia sus opciones y par\u00e1metros de configuraci\u00f3n. \u00bfEn qu\u00e9 puertos y bajo qu\u00e9 protocolos escucha el servidor CoAP tras su arranque? Intercambio de mensajes CoAP Tarea entregable En la presente secci\u00f3n se proponen distintos intercambios de mensajes CoAP entre el cliente y el servidor de ejemplo proporcionados como parte de la instalaci\u00f3n de libcoap . Para cada uno de ellos, se pide un estudio b\u00e1sico de los paquetes intercambiados, haciendo especial hincapi\u00e9 en la pila de protocolos utilizados, contenido de los paquetes y n\u00famero de paquetes intercambiados. Este estudio, incluyendo capturas y comentarios adicionales, conformar\u00e1 el entregable asociado a la pr\u00e1ctica. Arranque del servidor CoAP En primer lugar, realizaremos un intercambio b\u00e1sico de mensajes CoAP entre el cliente y el servidor. Para ello, abriremos dos terminales desde las que ejecutaremos, respectivamente, el servidor y el cliente. Tarea Investiga las opciones disponibles en el cliente y servidor con respecto a la cantidad de mensajes de depuraci\u00f3n a mostrar. Ejecuta el servidor CoAP con suficiente nivel de detalle en los mensajes de depuraci\u00f3n. Una vez arrancado el servidor, ejecuta la orden correspondiente desde l\u00ednea de \u00f3rdenes para averiguar qu\u00e9 puertos ha abierto, y por tanto c\u00f3mo nos podemos comunicar con \u00e9l. Averigua si estos puertos son bien conocidos well-known , valor menor a 1024) y, en su caso, c\u00f3mo pueden modificarse. Obtenci\u00f3n de informaci\u00f3n del servidor ( Resource Discovery ) En primer lugar, obtendremos la informaci\u00f3n sobre los recursos disponibles en el servidor CoAP. Para ello, realizaremos una petici\u00f3n GET sobre el recurso /.well-known/core del servidor. Esta transacci\u00f3n nos devolver\u00e1 los recursos disponibles en el mismo, as\u00ed como algunas caracter\u00edsticas adicionales. Tarea \u00bfQu\u00e9 recursos est\u00e1n disponibles en el servidor? Estudia el c\u00f3digo fuente del mismo para observar la correlaci\u00f3n entre los recursos descubiertos y los programados en el c\u00f3digo. Averigua el significado de los atributos rt , ct , if y *title. Obtenci\u00f3n de informaci\u00f3n desde recursos Utilizando el cliente CoAP proporcionado, resulta sencillo realizar consultas para obtener datos desde el servidor. Para ello, utilizaremos la acci\u00f3n (verbo) {\\tt GET}, seguido del recurso a consultar y, opcionalmente, de una consulta concreta. Tarea Consulta la marca de tiempo proporcionada por el servidor en modo legible (por ejemplo, Dec 13 14:20:43 ), y tambi\u00e9n en forma de ticks de reloj, utilizando la consulta adecuada. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito? Modificaci\u00f3n de recursos Al igual que con el verbo GET, es posible realizar modificaciones en el servidor utilizando el verbo PUT. Consulta la ayuda del cliente proporcionado para observar alg\u00fan ejemplo que d\u00e9 soporte a esta funcionalidad. Tarea Modifica la marca de tiempo que proporciona el servidor CoAP. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito? Eliminaci\u00f3n y creaci\u00f3n de recursos Es posible eliminar un determinado recurso (en el ejemplo, el temporizador), utilizando el verbo DELETE . Investiga c\u00f3mo hacerlo desde el cliente proporcionado. Tarea Elimina el recurso time del servidor y, a continuaci\u00f3n, modifica la marca de tiempo mediante una orden PUT }. \u00bfQu\u00e9 valores de retorno (c\u00f3digo) se devuelven en ambos casos?} Suscripci\u00f3n (observaci\u00f3n) de recursos Es posible suscribirse a los cambios en el valor de un recurso utilizando la opci\u00f3n -s del cliente. Tarea Activa la observaci\u00f3n sobre el recurso time del servidor y analiza tanto la frecuencia de respuesta como el intercambio de mensajes producido (a trav\u00e9s de Wireshark ). \u00bfSe producen peticiones peri\u00f3dicas usando GET ? CoAP sobre TCP Alternativamente, CoAP puede funcionar utilizando el protocolo de capa de transporte TCP. En este caso, como es l\u00f3gico, se establecer\u00e1 una conexi\u00f3n entre cliente y servidor previa a cualquier intercambio de datos. Tarea Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP? Tareas entregables Tarea entregable Deber\u00e1s entregar una memoria en la que se incida en detalles observados y aprendidos acerca del protocolo CoAP, con especial atenci\u00f3n a las capturas obtenidas a trav\u00e9s de Wireshark. Tarea entregable Estudia el c\u00f3digo del servidor proporcionado, especialmente de la funci\u00f3n init_resources , y a\u00f1ade un nuevo recurso llamado temperature . Este recurso aceptar\u00e1 dos consultas distintas: ?celsius (consulta por defecto) devolver\u00e1 el valor de temperatura expresado en grados cent\u00edgrados, mientras que \\tt fahrenheit devolver\u00e1 la temperatura en grados Fahrenheit. En este caso, el valor de temperatura se obtendr\u00e1 directamente a trav\u00e9s de un n\u00famero aleatorio, pero se valorar\u00e1 su obtenci\u00f3n a partir de un sensor real. Tarea entregable ESP-IDF incluye un port de libcoap . El ejemplo examples/protocols/coap_server implementa un servidor CoAP b\u00e1sico, con un s\u00f3lo recurso (puedes consultarlo t\u00fa mismo/a obteniendo la informaci\u00f3n del recurso /well-known/core ). Analiza el c\u00f3digo y observa que la biblioteca libcoap se utiliza de forma exacta a como has estudiado en el c\u00f3digo del servidor de ejemplo. Se pide modificar el firmware para dar soporte al recurso time de forma id\u00e9ntica (con la misma sem\u00e1ntica) que la utilizada en el host .","title":"Pr\u00e1ctica 7. El protocolo CoAP"},{"location":"Subjects/NP2/P7/#practica-7-el-protocolo-coap","text":"","title":"Pr\u00e1ctica 7. El protocolo CoAP"},{"location":"Subjects/NP2/P7/#objetivos","text":"El objetivo de esta pr\u00e1ctica es realizar una introducci\u00f3n al protocolo CoAP, uno de los m\u00e1s extendidos a d\u00eda de hoy para llevar a cabo comunicaciones M2M. Los objetivos did\u00e1cticos de la pr\u00e1ctica son: Entender la estructura cliente-servidor del protocolo CoAP. Comprender los mensajes utilizados para establecer una comunicaci\u00f3n CoAP, tanto a nivel de sintaxis como de sem\u00e1ntica. Modificar una aplicaci\u00f3n cliente/servidor ejemplo basada en libcoap que realice una comunicaci\u00f3n sencilla a trav\u00e9s del protocolo CoAP en un entorno Linux. Estudiar el componente libcoap en ESP-IDF para reproducir el comportamiento del servidor CoAP para ofrecer su fucionalidad desde un ESP32.","title":"Objetivos"},{"location":"Subjects/NP2/P7/#instalacion-y-requisitos-previos","text":"En esta pr\u00e1ctica realizaremos un estudio del protocolo CoAP utilizando una implementaci\u00f3n ya desarrollada para un sistema cliente/servidor que hace uso del protocolo CoAP, distribuida a trav\u00e9s de la biblioteca libcoap . N\u00f3tese que se trata de una pr\u00e1ctica introductoria, ya que el protocolo CoAP se utilizar\u00e1, en sucesivas pr\u00e1cticas, para dar soporte a protocolos de m\u00e1s alto nivel (principalmente LWM2M). El objetivo principal de la pr\u00e1ctica es, pues, introducir a alto nivel las caracter\u00edsticas de CoAP como protocolo de capa de aplicaci\u00f3n, as\u00ed como ser capaces de interactuar con un servidor existente a trav\u00e9s de herramientas ya desarrolladas. De forma adicional, se estudiar\u00e1 la posibilidad de implementar un servidor CoAP en el ESP32.","title":"Instalaci\u00f3n y requisitos previos"},{"location":"Subjects/NP2/P7/#instalacion-de-requisitos-adicionales-y-libcoap","text":"En primer lugar, instalemos los prerequisitos necesarios para hacer funcionar {\\tt libcoap}. Para ello, en la m\u00e1quina virtual, ejecutaremos las siguientes \u00f3rdenes: sudo apt-get update sudo apt-get install libtool Procedemos ahora con la instalaci\u00f3n de {\\tt libcoap}. Para ello, descarga la \u00faltima versi\u00f3n de la biblioteca desde la p\u00e1gina web del proyecto, descompr\u00edmelo y pasa a la fase de compilaci\u00f3n e instalaci\u00f3n: sh autogen.sh ./configure --enable-examples --enable-dtls --with-openssl --disable-documentation make make install Si no hay ning\u00fan error, libcoap se habr\u00e1 instalado con \u00e9xito. Ser\u00e1 de especial inter\u00e9s para nosotros la instalaci\u00f3n de programas servidor ( coap-server ) y cliente ( coap-client ) de ejemplo en el directorio examples . Tarea Ejecuta los programas servidor y cliente CoAP del directorio examples . Estudia sus opciones y par\u00e1metros de configuraci\u00f3n. \u00bfEn qu\u00e9 puertos y bajo qu\u00e9 protocolos escucha el servidor CoAP tras su arranque?","title":"Instalaci\u00f3n de requisitos adicionales y libcoap"},{"location":"Subjects/NP2/P7/#intercambio-de-mensajes-coap","text":"Tarea entregable En la presente secci\u00f3n se proponen distintos intercambios de mensajes CoAP entre el cliente y el servidor de ejemplo proporcionados como parte de la instalaci\u00f3n de libcoap . Para cada uno de ellos, se pide un estudio b\u00e1sico de los paquetes intercambiados, haciendo especial hincapi\u00e9 en la pila de protocolos utilizados, contenido de los paquetes y n\u00famero de paquetes intercambiados. Este estudio, incluyendo capturas y comentarios adicionales, conformar\u00e1 el entregable asociado a la pr\u00e1ctica.","title":"Intercambio de mensajes CoAP"},{"location":"Subjects/NP2/P7/#arranque-del-servidor-coap","text":"En primer lugar, realizaremos un intercambio b\u00e1sico de mensajes CoAP entre el cliente y el servidor. Para ello, abriremos dos terminales desde las que ejecutaremos, respectivamente, el servidor y el cliente. Tarea Investiga las opciones disponibles en el cliente y servidor con respecto a la cantidad de mensajes de depuraci\u00f3n a mostrar. Ejecuta el servidor CoAP con suficiente nivel de detalle en los mensajes de depuraci\u00f3n. Una vez arrancado el servidor, ejecuta la orden correspondiente desde l\u00ednea de \u00f3rdenes para averiguar qu\u00e9 puertos ha abierto, y por tanto c\u00f3mo nos podemos comunicar con \u00e9l. Averigua si estos puertos son bien conocidos well-known , valor menor a 1024) y, en su caso, c\u00f3mo pueden modificarse.","title":"Arranque del servidor CoAP"},{"location":"Subjects/NP2/P7/#obtencion-de-informacion-del-servidor-resource-discovery","text":"En primer lugar, obtendremos la informaci\u00f3n sobre los recursos disponibles en el servidor CoAP. Para ello, realizaremos una petici\u00f3n GET sobre el recurso /.well-known/core del servidor. Esta transacci\u00f3n nos devolver\u00e1 los recursos disponibles en el mismo, as\u00ed como algunas caracter\u00edsticas adicionales. Tarea \u00bfQu\u00e9 recursos est\u00e1n disponibles en el servidor? Estudia el c\u00f3digo fuente del mismo para observar la correlaci\u00f3n entre los recursos descubiertos y los programados en el c\u00f3digo. Averigua el significado de los atributos rt , ct , if y *title.","title":"Obtenci\u00f3n de informaci\u00f3n del servidor (Resource Discovery)"},{"location":"Subjects/NP2/P7/#obtencion-de-informacion-desde-recursos","text":"Utilizando el cliente CoAP proporcionado, resulta sencillo realizar consultas para obtener datos desde el servidor. Para ello, utilizaremos la acci\u00f3n (verbo) {\\tt GET}, seguido del recurso a consultar y, opcionalmente, de una consulta concreta. Tarea Consulta la marca de tiempo proporcionada por el servidor en modo legible (por ejemplo, Dec 13 14:20:43 ), y tambi\u00e9n en forma de ticks de reloj, utilizando la consulta adecuada. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito?","title":"Obtenci\u00f3n de informaci\u00f3n desde recursos"},{"location":"Subjects/NP2/P7/#modificacion-de-recursos","text":"Al igual que con el verbo GET, es posible realizar modificaciones en el servidor utilizando el verbo PUT. Consulta la ayuda del cliente proporcionado para observar alg\u00fan ejemplo que d\u00e9 soporte a esta funcionalidad. Tarea Modifica la marca de tiempo que proporciona el servidor CoAP. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito?","title":"Modificaci\u00f3n de recursos"},{"location":"Subjects/NP2/P7/#eliminacion-y-creacion-de-recursos","text":"Es posible eliminar un determinado recurso (en el ejemplo, el temporizador), utilizando el verbo DELETE . Investiga c\u00f3mo hacerlo desde el cliente proporcionado. Tarea Elimina el recurso time del servidor y, a continuaci\u00f3n, modifica la marca de tiempo mediante una orden PUT }. \u00bfQu\u00e9 valores de retorno (c\u00f3digo) se devuelven en ambos casos?}","title":"Eliminaci\u00f3n y creaci\u00f3n de recursos"},{"location":"Subjects/NP2/P7/#suscripcion-observacion-de-recursos","text":"Es posible suscribirse a los cambios en el valor de un recurso utilizando la opci\u00f3n -s del cliente. Tarea Activa la observaci\u00f3n sobre el recurso time del servidor y analiza tanto la frecuencia de respuesta como el intercambio de mensajes producido (a trav\u00e9s de Wireshark ). \u00bfSe producen peticiones peri\u00f3dicas usando GET ?","title":"Suscripci\u00f3n (observaci\u00f3n) de recursos"},{"location":"Subjects/NP2/P7/#coap-sobre-tcp","text":"Alternativamente, CoAP puede funcionar utilizando el protocolo de capa de transporte TCP. En este caso, como es l\u00f3gico, se establecer\u00e1 una conexi\u00f3n entre cliente y servidor previa a cualquier intercambio de datos. Tarea Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP?","title":"CoAP sobre TCP"},{"location":"Subjects/NP2/P7/#tareas-entregables","text":"Tarea entregable Deber\u00e1s entregar una memoria en la que se incida en detalles observados y aprendidos acerca del protocolo CoAP, con especial atenci\u00f3n a las capturas obtenidas a trav\u00e9s de Wireshark. Tarea entregable Estudia el c\u00f3digo del servidor proporcionado, especialmente de la funci\u00f3n init_resources , y a\u00f1ade un nuevo recurso llamado temperature . Este recurso aceptar\u00e1 dos consultas distintas: ?celsius (consulta por defecto) devolver\u00e1 el valor de temperatura expresado en grados cent\u00edgrados, mientras que \\tt fahrenheit devolver\u00e1 la temperatura en grados Fahrenheit. En este caso, el valor de temperatura se obtendr\u00e1 directamente a trav\u00e9s de un n\u00famero aleatorio, pero se valorar\u00e1 su obtenci\u00f3n a partir de un sensor real. Tarea entregable ESP-IDF incluye un port de libcoap . El ejemplo examples/protocols/coap_server implementa un servidor CoAP b\u00e1sico, con un s\u00f3lo recurso (puedes consultarlo t\u00fa mismo/a obteniendo la informaci\u00f3n del recurso /well-known/core ). Analiza el c\u00f3digo y observa que la biblioteca libcoap se utiliza de forma exacta a como has estudiado en el c\u00f3digo del servidor de ejemplo. Se pide modificar el firmware para dar soporte al recurso time de forma id\u00e9ntica (con la misma sem\u00e1ntica) que la utilizada en el host .","title":"Tareas entregables"},{"location":"Subjects/NP2/P8/","text":"Pr\u00e1ctica 8. El protocolo LWM2M Objetivos Familiarizarse con el protocolo LWM2M, tanto en la interacci\u00f3n con servidores como en la generaci\u00f3n y definici\u00f3n de objetos y recursos. Familiarizarse con el protocolo de bootstrapping LWM2M y entender su importancia en entornos reales. Conocer dos herramientas para el desarrollo de sistemas basados en LWM2M: Wakaama y Leshan. Experimentar con el proceso de definici\u00f3n de objetos en Wakaama. Observar y poner en marcha un proceso de provisionamiento ( bootstrapping ) usando Wakaama. Desplegar servidores locales LWM2M usando tanto Wakaama como Leshan. El protocolo LWM2M OMA Lightweight M2M (LWM2M) es un protocolo impulsado por la Open Mobile Alliance para la comunicaci\u00f3n M2M entre dispositivos y su gesti\u00f3n en entornos IoT. LWM2M est\u00e1 construido sobre el protocolo CoAP, y soporta, a nivel de transporte, el protocolo UDP (tambi\u00e9n presenta soporte para SMS). Entre las funcionalidades b\u00e1sicas de LWM2M destacan la existencia de servidores LWM2M, bootstrapping , control de acceso, gesti\u00f3n de dispositivos, actualizaciones de firmware , localizaci\u00f3n o estad\u00edsticas de conectividad. Adem\u00e1s, soporta seguridad a trav\u00e9s de DTLS. Concretamente, la primera especificaci\u00f3n de LWM2M (versi\u00f3n 1.0) introdujo las siguientes caracter\u00edsticas b\u00e1sicas: Definici\u00f3n de un modelo simple para la definici\u00f3n de recursos, basado en objetos. Definici\u00f3n de operaciones de creaci\u00f3n, consulta, modificaci\u00f3n, borrado y configuraci\u00f3n de recursos. Observaci\u00f3n/notificaci\u00f3n sobre recursos. Soporte para formato de datos JSON, texto plano y TLV. Colas de mensajes para soportar modos de bajo consumo en dispositivos. Soporte para m\u00faltiples servidores LWM2M. Objetos b\u00e1sicos LWM2M: Seguridad, Servidor, Control de Acceso, Dispositivo, Conectividad, Actualizaci\u00f3n de Firmware, Localizaci\u00f3n, Estad\u00edsticas de Conectividad. Para m\u00e1s informaci\u00f3n sobre los objetos predefinidos, consulta el siguiente enlace . Versiones subsiguientes del protocolo (1.1 y 1.2) introdujeron caracter\u00edsticas adicionales, como por ejemplo: Mejora del proceso de bootstrapping . Mejora del soporte para PKI. Soporte para TCP/TLS. Soporte para CBOR. Soporte para MQTT y HTTP como protocolos subyacentes. Implementaciones LWM2M En la presente pr\u00e1ctica, utilizaremos dos paquetes de software pertenecientes al proyecto Eclipse IoT, ambos con soporte completo para LWM2M. Cada uno de ellos presenta ventajas e inconvenientes que es necesario conocer. Eclipse Wakaama Eclipse Wakaama es un conjunto de ficheros fuente escritos en C que permiten ser integrados en cualquier proyecto para proporcionar funcionalidad de cliente , servidor y servidor de bootstrap LWM2M hasta su versi\u00f3n 1.1. En el lado cliente, Wakaama permite la definici\u00f3n de objetos conforme al est\u00e1ndar, as\u00ed como la recepci\u00f3n de comandos desde servidores y su enrutado hacia el objeto u objetos correspondientes. Desde el punto de vista servidor, Wakaama proporciona APIs para enviar comandos a clientes LWM2M registrados. Todo el proyecto es compatible con POSIX, y en esta pr\u00e1ctica experimentaremos con su funcionalidad trabajando desde Linux (modo cliente, servidor y servidor de bootstrap ) y desde el ESP32 (modo cliente). Instalaci\u00f3n Utilizaremos una versi\u00f3n espec\u00edfica que permitir\u00e1 ser ejecutada tanto en Linux como en el ESP32. Para ello, clonamos en primer lugar la versi\u00f3n correspondiente del proyecto (es importante que utilices este commit espec\u00edfico): git clone https://github.com/eclipse/wakaama.git cd wakaama git reset --hard 31d64c0c41fae9653c1fa53ef58d1a44e49017fa El proyecto Wakaama proporciona cuatro componentes que utilizaremos durante la pr\u00e1ctica, todos dentro del directorio examples : bootstrap_server : implementa un servidor de bootstrap con l\u00ednea de comandos propia. client : implementa un cliente complejo, con definici\u00f3n de nueve objetos que siguen las especificaciones de la OMA m\u00e1s uno propio, y soporte para bootstrapping . lightclient : implementa un cliente sencillo, con definici\u00f3n de tres objetos seg\u00fan especificaciones OMA y un cuarto objeto propio. server : implementa un servidor LWM2M que ofrece l\u00ednea de comandos para la interacci\u00f3n con clientes registrados. El modo de compilar cada uno de los ejemplos es exactamente el mismo: Dir\u00edgete al directorio del ejemplo. Crea un directorio build y accede a \u00e9l. Configura el proyecto con la orden cmake .. . Compila el ejemplo con la orden make . Si todo ha ido bien, deber\u00edas tener un binario distinto en el directorio build correspondiente, con los que trabajar\u00e1s el resto de la pr\u00e1ctica. Tarea Compila cada uno de los ejemplos anteriormente mencionados en tu m\u00e1quina virtual, utilizando los par\u00e1metros por defecto para cada uno de ellos. Eclipse Leshan Eclipse Leshan es un proyecto alternativo que proporciona implementaciones en Java de clientes, servidores y servidores de bootstrap LWM2M, y est\u00e1 especialmente dise\u00f1ado para ser adaptable y extensible, permitiendo a los desarrolladores implementar sus propias versiones de cada uno de los tres anteriores elmentos adaptados a sus necesidades espec\u00edficas. Al igual que Wakaama, Leshan proporciona la definici\u00f3n e interacci\u00f3n con objetos IPSO, construcci\u00f3n sobre DTLS y utilizaci\u00f3n de CoAP como protocolo subyacente. Adem\u00e1s, el proyecto proporciona dos servidores de test que resultan muy \u00fatiles a la hora de desarrollar, v\u00e9ase: Servidor LWM2M en leshan.eclipseprojects.io , disponible en coap://leshan.eclipseprojects.io:5683 y coaps://leshan.eclipseprojects.io:5684 . Servidor de bootstrap en leshan.eclipseprojects.io/bs , disponible en coap://leshan.eclipseprojects.io:5783 y coaps://leshan.eclipseprojects.io:5784 . Instalaci\u00f3n Instala en primer lugar los prerequisitos necesarios para la correcta instalaci\u00f3n de Leshan (pueden variar en funci\u00f3n de tu distribuci\u00f3n Linux): sudo apt-get update sudo apt-get install openjdk-14-jdk maven git-core Clona el repositorio oficial de Leshan desde la siguiente direcci\u00f3n: git clone https://github.com/eclipse/leshan.git Por \u00faltimo, compila el proyecto: cd leshan mvn clean install Tras la fase de instalaci\u00f3n, podr\u00e1s lanzar tanto el servidor LWM2M: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. Como el servidor de bootstrapping : java -jar leshan-bsserver-demo/target/leshan-bsserver-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. En ambos casos, la salida asociada a la ejecuci\u00f3n de los servidores nos indicar\u00e1n la URL que podremos consultar desde cualquier navegador para obtener informaci\u00f3n del mismo, as\u00ed como la URL y puerto de escucha de cada uno, que deberemos indicar en los clientes correspondientes. Tarea Instala Eclipse Leshan y arranca el servidor LWM2M. Accede a la p\u00e1gina web de gesti\u00f3n y comprueba que efectivamente funciona. A continucaci\u00f3n, detenlo y haz lo propio con el servidor de bootstrapping . Eclipse Wakaama. Cliente y servidor LWM2M El objetivo principal de esta parte de la pr\u00e1ctica ser\u00e1 disponer de un sistema completo LWM2M basado en un cliente y dos servidores (uno LWM2M, otro de bootstrapping ), todos funcionando bajo Eclipse Wakaama. Para ello, en primer lugar, arrancaremos el servidor Wakaama en una de las terminales. Observa que el servidor, tras arrancar, expone una sencilla l\u00ednea de comandos que podemos aprovechar para interactuar con \u00e9l: ./lwm2mserver > help help Type 'help [COMMAND]' for more details on a command. list List registered clients. read Read from a client. disc Discover resources of a client. write Write to a client. time Write time-related attributes to a client. attr Write value-related attributes to a client. clear Clear attributes of a client. exec Execute a client resource. del Delete a client Object instance. create Create an Object instance. observe Observe from a client. cancel Cancel an observe. q Quit the server. La orden help muestra la ayuda global, pudi\u00e9ndose especializar para cada comando concreto: > help read read CLIENT# URI CLIENT#: client number as returned by command 'list' URI: uri to read such as /3, /3/0/2, /1024/11, /1024/0/1 Result will be displayed asynchronously. Si en este instante listamos un los clientes registrados, veremos que no hay ninguno: > list No client. En segundo lugar, vamos a arrancar el cliente Wakaama. Por defecto, este cliente intentar\u00e1 conectar con un servidor LWM2M existente en localhost , puerto 5683. En cualquier caso, estos valores pueden modificarse en la propia invocaci\u00f3n (consulta la opci\u00f3n -h para m\u00e1s informaci\u00f3n sobre par\u00e1metros disponibles): ./lwm2mclient Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > Opening connection to server at ::1:5683 -> State: STATE_REGISTERING 13 bytes received from [::1]:5683 64 41 69 06 06 69 E8 86 82 72 64 01 30 dAi..i...rd.0 -> State: STATE_READY > help help Type 'help [COMMAND]' for more details on a command. list List known servers. change Change the value of resource. update Trigger a registration update bootstrap Initiate a DI bootstrap process dispb Display current backup of objects/instances/resources (only security and server objects are backupped) ls List Objects and Instances disp Display current objects/instances/resources dump Dump an Object add Add support of object 31024 rm Remove support of object 31024 quit Quit the client gracefully. ^C Quit the client abruptly (without sending a de-register message). > -> State: STATE_READY Al igual que el servidor, el cliente soporta la introducci\u00f3n de comandos por parte del usuario. Observa que hemos ejecutado el comando help para mostrar los comandos disponibles. Adem\u00e1s, el cliente ha pasado desde un estado STATE_REGISTERING a un estado STATE_READY , lo que significa que se ha registrado correctamente en el servidor con el nombre testlwm2mclient . Observa ahora la salida del servidor, y ver\u00e1s que \u00e9ste ha realizado un proceso de descubrimiento de recursos en el cliente conectado. Concretamente, el servidor reporta la informaci\u00f3n relativa al nuevo cliente conectado: New client #0 registered. Client #0: name: \"testlwm2mclient\" version: \"1.1\" binding: \"UDP\" lifetime: 300 sec objects: /1/0, /2/0, /3/0, /4/0, /5/0, /6/0, /7/0, /31024/10, /31024/11, /31024/12, Concretamente, el n\u00famero asociado al cliente es el 0 . Podemos recuperar esta informaci\u00f3n en todo momento con el comando list en el servidor. En el cliente, puedes seleccionar el nombre que se utilizar\u00e1 en el proceso de registro con la opci\u00f3n -n . Tarea entregable Observa, utilizando Wireshark, el proceso de registro de un cliente en un servidor, y analiza el contenido del mensaje o mensajes intercambiados entre ambos. \u00bfQu\u00e9 protocolos se utilizan? El cliente con el que estamos trabajando es suficientemente complejo en su funcionamiento, y permite observar c\u00f3mo se implementa el soporte tanto para objetos predefinidos por la OMA como para objetos propios. Concretamente, el cliente implementa nueve objetos distintos: Security Object ( id=0 ). Server Object ( id=1 ). Access Control Object ( id=2 ), como un simple esqueleto, sin funcionalidad asociada. Device Object ( id=3 ), que contiene (y devuelve) valores espec\u00edficos codificados en base al ap\u00e9ndice E de la especificaci\u00f3n t\u00e9cnica de LWM2M. Connectivity Monitoring Object ( id=4 ), como un simple esqueleto, sin funcionalidad. Firmware Update Object ( id=5 ), como un simple esqueleto, sin funcionalidad. Location Object ( id=6 ), como un simple esqueleto, sin funcionalidad. Connectivity Statistics Object ( id=7 ), como un simple esqueleto, sin funcionalidad. Test Object ( id=31024 ), con la siguiente descripci\u00f3n: Objetos: Objeto ID Multiples Instancias Obligatorio Test 31024 S\u00ed No Recurso: Nombre ID Operaciones M\u00faltiples Instancias Obligatorio Tipo Rango test 1 R/W No Yes Integer 0-255 exec 2 E No Yes dec 3 R/W No Yes Float En el cliente, el comando dump nos permitir\u00e1 observar el contenido de una instancia determinada de un objeto, o de todas ellas. En el servidor, el comando read nos permitir\u00e1 hacer lo propio. Tarea entregable Analiza el valor actual de los objetos /3 y el objeto de test, tanto desde el cliente (comando dump ) como desde el servidor (comando read ). En \u00faltimo caso, realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos. Para escribir en un determinado recurso desde el servidor, podemos hacer uso del comando write de la siguiente forma: write 0 /31024/10/1 91 As\u00ed, estar\u00edamos escribiendo en el recurso 1 de la instancia 10 del objeto 31024 el valor entero 91. Tarea entregable Realiza escrituras en objetos del cliente y analiza el nuevo valor, comprobando que efectivamente se han llevado a cabo. Realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos en el caso de una escritura. Observa tambi\u00e9n que el servidor permite la observaci\u00f3n de recursos espec\u00edficos (comando observe ). Experimenta con esta opci\u00f3n y observa el tr\u00e1fico generado (puedes modificar el valor de un recurso desde el propio cliente y ver qu\u00e9 ocurre en el servidor). Por \u00faltimo, con la orden quit desconectamos del servidor. Observa tambi\u00e9n los mensajes CoAP que se generan en este caso. Definici\u00f3n de un objeto en Eclipse Wakaama Como has podido observar, el ejemplo de cliente define una serie de objetos, algunos especificados por la OMA, y otros personalizados. En este \u00faltimo caso, al que nos referiremos como test_object , se utilizan e ilustran algunas de las funcionalidades b\u00e1sicas de Wakaama como infraestructura para el desarrollo de Smart Objects v\u00eda LWM2M. Observa tanto el c\u00f3digo del cliente LWM2M (fichero fuente lwm2mclient.c del ejemplo client ) como la definici\u00f3n del objeto de test (fichero fuente test_object.c ). El primer fichero implementa la l\u00f3gica principal del cliente, incluyendo gesti\u00f3n de la conexi\u00f3n, l\u00f3gica de an\u00e1lisis de comandos introducidos por el usuario, gesti\u00f3n de bootstrapping , etc. Concretamente, nos interesa analizar las l\u00edneas relativas a la invocaci\u00f3n de la funci\u00f3n get_test_object , en cuyo interior se definen tanto los recursos como el comportamiento de nuestro cliente ante distintos tipos de operaciones sobre ellos. Observa que, al igual que para nuestro objeto de test, existen funciones similares para el resto de objetos definidos (obviamente podr\u00edan existir m\u00e1s), con un fichero fuente donde se define el comportamiento de cada uno de ellos. Uno de estos objetos es test_object.c . La principal funci\u00f3n de entrada a este m\u00f3dulo es precisamente get_test_object() . Observa que, en ella, se define el identificador del objeto, as\u00ed como cada uno de los recursos que expone (en este caso, tres), sus valores iniciales, y las funciones que se utilizar\u00e1n como callbacks asociados a cada posible operaci\u00f3n: lwm2m_object_t * testObj; testObj = (lwm2m_object_t *)lwm2m_malloc(sizeof(lwm2m_object_t)); if (NULL != testObj) { int i; prv_instance_t * targetP; memset(testObj, 0, sizeof(lwm2m_object_t)); testObj->objID = TEST_OBJECT_ID; for (i=0 ; i < 3 ; i++) { targetP = (prv_instance_t *)lwm2m_malloc(sizeof(prv_instance_t)); if (NULL == targetP) return NULL; memset(targetP, 0, sizeof(prv_instance_t)); targetP->shortID = 10 + i; targetP->test = 20 + i; targetP->dec = -30 + i + (double)i/100.0; testObj->instanceList = LWM2M_LIST_ADD(testObj->instanceList, targetP); } /* * From a single instance object, two more functions are available. * - The first one (createFunc) create a new instance and filled it with the provided informations. If an ID is * provided a check is done for verifying his disponibility, or a new one is generated. * - The other one (deleteFunc) delete an instance by removing it from the instance list (and freeing the memory * allocated to it) */ testObj->readFunc = prv_read; testObj->discoverFunc = prv_discover; testObj->writeFunc = prv_write; testObj->executeFunc = prv_exec; testObj->createFunc = prv_create; testObj->deleteFunc = prv_delete; } return testObj; Estas funciones de callback est\u00e1n definidas en el propio fichero, y su contenido es personalizable en funci\u00f3n del dise\u00f1o del objeto. Observemos, por ejemplo, el contenido de la funci\u00f3n asociada a la lectura, prv_read : static uint8_t prv_read(uint16_t instanceId, int * numDataP, lwm2m_data_t ** dataArrayP, lwm2m_object_t * objectP) { prv_instance_t * targetP; int i; targetP = (prv_instance_t *)lwm2m_list_find(objectP->instanceList, instanceId); if (NULL == targetP) return COAP_404_NOT_FOUND; if (*numDataP == 0) { *dataArrayP = lwm2m_data_new(2); if (*dataArrayP == NULL) return COAP_500_INTERNAL_SERVER_ERROR; *numDataP = 2; (*dataArrayP)[0].id = 1; (*dataArrayP)[1].id = 3; } for (i = 0 ; i < *numDataP ; i++) { switch ((*dataArrayP)[i].id) { case 1: lwm2m_data_encode_int(targetP->test, *dataArrayP + i); break; case 2: return COAP_405_METHOD_NOT_ALLOWED; case 3: lwm2m_data_encode_float(targetP->dec, *dataArrayP + i); break; default: return COAP_404_NOT_FOUND; } } return COAP_205_CONTENT; } Observa que en primer lugar se busca la instancia del objeto solicitada, devolvi\u00e9ndose el error correspondiente en caso de no existir (puedes comprobar esta funcionalidad solicitando desde el servidor la lectura de una instancia inexistente). El par\u00e1metro numDataP nos indica el recurso concreto que se desea leer, o todos si dicho valor es 0. Tras tomar el valor actual a servir, \u00e9ste se codifica en funci\u00f3n del tipo de datos predefinido para el recurso espec\u00edfico solicitado. En caso de no estar soportado el m\u00e9todo para un recurso espec\u00edfico, se devuelve el error correspondiente (en este caso 405 ). En caso de solicitar un recurso inexistente, se devuelve el error 404 . Tarea Comprueba que el comportamiento del objeto de test es el esperado, interactuando con \u00e9l desde el servidor utilizando todos los m\u00e9todos disponibles. Puedes modificar su comportamiento, a\u00f1adir invocaciones a rutinas de log , o lo que consideres de utilidad. Eclipse Wakaama. Bootstrapping En este punto, el cliente Wakaama se conecta directamente con el servidor que hemos lanzado, y cuya direcci\u00f3n IP y puerto son los proporcionados por defecto en el c\u00f3digo. Llevado el cliente a un sensor, esto har\u00eda que nunca pudiese variar, durante el ciclo de vida del mismo, el servidor (o servidores) a los que conecta. Esto hace tambi\u00e9n que un cliente pueda \u00fanicamente conectar con un servidor LWM2M, cuando en algunas ocasiones es deseable replicar los mensajes enviados a m\u00faltiples servidores, bien por razones de tolerancia a fallos, o bien por necesidades de la aplicaci\u00f3n. Para solucionar este problema, los firmwares de f\u00e1brica suelen conocer \u00fanicamente la direcci\u00f3n o direcciones fijas de uno o varios servidores de bootstrap que, ante peticiones de provisionamiento, proporcionan al cliente las credenciales de seguridad y las direcciones de los servidores LWM2M en los que deben registrarse. As\u00ed, resulta sencillo manejar din\u00e1micamente ambos aspectos sin necesitar reflashear el firmware del sensor. En nuestro caso, utilizaremos un sencillo servidor de bootstrap proporcionado por Wakaama, aunque Leshan ofrece mecanismos mucho m\u00e1s sofisticados para realizar este mismo proceso, con su propio esqueleto de servidor bootstrap e interfaces REST (con monitores web) para gestionar el proceso. En primer lugar, dir\u00edgete al directorio que contiene el servidor bootstrap de Wakaama. All\u00ed encontrar\u00e1s un fichero de configuraci\u00f3n ( bootstrap_server.ini ) para el proceso de bootstrapping , cuyo contenido es completamente estructurado. El servidor, ante una petici\u00f3n de bootstrapping por parte de un cliente, responde en funci\u00f3n del contenido del fichero, que sigue las siguientes directivas: Las secciones soportadas son [Server] y [Endpoint] . [Server] describe una cuenta en un servidor LWM2M: Las claves soportadas en esta secci\u00f3n son: id: Identificador del servidor. (OBLIGATORIO). uri: URI del servidor LWM2M (OBLIGATORIO). bootstrap: YES o NO. Determina si este servidor es un servidor de bootstrap. Su valor por defecto es NO. lifetime: tiempo de vida del registro (opcional). security: modo de seguridad. Valores soportados: NoSec, PSK, RPK and Certificate (OBLIGATORIO). public: clave p\u00fablica o identidad del cliente, definida por el recurso /0/x/3 . server: clave p\u00fablica del servidor, definida por el recurso /0/x/4 . secret: clave privada definida por el recurso /0/x/5 . [Endpoint] contiene las operaciones de bootstrapping Si no se especifica un nombre (Name) las operaciones se enviar\u00e1n a cualquier cliente desconocido que solicite bootstrapping Si se especifica, las operaciones se enviar\u00e1n s\u00f3lo al cliente con el correspondiente nombre. Las operaciones se env\u00edan en el orden definido en el fichero. Las claves soportadas en esta secci\u00f3n son: - Name: Nombre del cliente (OPCIONAL). - Delete: Debe ser una URI LWM2M v\u00e1lida, incluida / . Env\u00eda una operaci\u00f3n delete en la URI indicada. - Server: [Value] es un ID de servidor que debe existir en la secci\u00f3n correspondiente. Env\u00eda operaciones de escritura sobre el objeto correspondiente del cliente para definir el servidor sobre el que debe conectar. Tarea Analiza e intenta entender el contenido por defecto del fichero de bootstrapping proporcionado. Puedes de momento obviar los par\u00e1metros referentes a seguridad, ya que los trataremos en la pr\u00f3xima pr\u00e1ctica. Tarea entregable Modifica el fichero de configuraci\u00f3n para que, ante la petici\u00f3n de un cliente con nombre determinado, conecte, por este orden, a un servidor LWM2M en la m\u00e1quina local, y al servidor de pruebas de Leshan en Internet. Adem\u00e1s, elimina cualquier intento de borrado de recursos en la informaci\u00f3n de bootstrapping para dicho cliente. Para arrancar el servidor bootstrap , basta con ejecutar (puedes utilizar otro fichero de configuraci\u00f3n): ./build/bootstrap_server -f bootstrap_server.ini El servidor quedar\u00e1 a la espera de peticiones por parte del cualquier cliente en el puerto 5685, tal y como indica su salida. Se puede forzar un proceso de bootstrapping con el comando boot , pero en este punto no es necesario. A continuaci\u00f3n, lanzaremos un cliente indicando que deseamos un proceso de bootstrapping contra el servidor local. Aseg\u00farate de dar un nombre a tu dispositivo que te permita diferenciarlo de cualquier otro : Nota importante Antes de realizar este ejercicio, debes modificar una l\u00ednea del fichero lwm2mclient.c , reemplazando la l\u00ednea que contiene data.addressFamily = AF_INET6; por data.addressFamily = AF_INET; . ./lwm2mclient -h localhost -p 5685 -b -c -n midispositivo Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > New Battery Level: 38 value changed! Opening connection to server at localhost:5685 -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING Observa que las opciones de invocaci\u00f3n han cambiado, y hemos usado -b para indicar que deseamos un proceso de bootstrapping contra el servidor proporcionado. Como nota adicional, la opci\u00f3n -c simplemente actualiza de forma peri\u00f3dica la lectura del nivel de bater\u00eda (esto no es en absoluto obligatorio, pero as\u00ed podremos observar sus cambios desde el servidor). Si todo ha ido bien, el cliente estar\u00e1 ahora registrado en dos servidores: el local Wakaama (observa su salida) y el remoto Leshan, al que puedes acceder a trav\u00e9s de la direcci\u00f3n leshan.eclipseprojects.io . Eclipse Leshan. Despliegue de un servidor local En este punto, tu cliente deber\u00eda estar conectado tanto a tu servidor LWM2M Wakaama local, como a un servidor Leshan en la nube. Aprovecha esta situaci\u00f3n para observar las funcionalides del servidor Leshan. Deber\u00edas, para un dispositivo con nombre \"foo\" observar algo como esto: Observa que todos y cada uno de los objetos de los que hablamos anteriormente se muestran ahora en pantalla tras el proceso de registro. Adem\u00e1s, para aquellos que son bien conocidos (estandarizados por la OMA), se muestran nombres legibles, no s\u00f3lo URIs. Tarea Busca y observa el recurso que te indica el nivel de bater\u00eda del cliente, y observa c\u00f3mo se actualiza autom\u00e1ticamente cuando var\u00eda en el cliente (ver\u00e1s a la vez un cambio en el servidor y un mensaje en el cliente). Interact\u00faa con el objeto de test que se defini\u00f3 anteriormente. En todos los casos, observa que, efectivamente, el tr\u00e1fico generado corresponde al esperado. Para replicar dicha instalaci\u00f3n en tu m\u00e1quina local, rescata la instalaci\u00f3n de Leshan que realizaste en la primera parte de la pr\u00e1ctica, y arranca el servidor LWM2M usando la siguiente orden: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar Tarea entregable Arranca el servidor Leshan para que escuche en un puerto diferente al que est\u00e1 escuchando ya el servidor Wakaama, para que puedan convivir en la misma m\u00e1quina. Modifica tu proceso de provisionamiento para que el cliente o clientes se conecten a ambos servidores. Tarea entregable El principal objetivo de esta parte es que seas capaz de definir un objeto e instanciarlo, con una cantidad de recursos suficientemente rica como para observar y ejercitar las capacidades de LWM2M en general, y de Eclipse Wakaama en particular. Por ello, se pide que definas, en primer lugar, uno o m\u00faltiples objetos y sus recursos que podr\u00edan formar parte de un hipot\u00e9tico sensor IoT. En segundo lugar, se pide que, siguiendo las directivas del c\u00f3digo analizado, lo implementes en Eclipse Wakaama y seas capaz de interactuar con \u00e9l desde un servidor Leshan y/o Wakaama utilizando adem\u00e1s un proceso de provisionamiento o bootstrapping .","title":"Pr\u00e1ctica 8. El protocolo LWM2M"},{"location":"Subjects/NP2/P8/#practica-8-el-protocolo-lwm2m","text":"","title":"Pr\u00e1ctica 8. El protocolo LWM2M"},{"location":"Subjects/NP2/P8/#objetivos","text":"Familiarizarse con el protocolo LWM2M, tanto en la interacci\u00f3n con servidores como en la generaci\u00f3n y definici\u00f3n de objetos y recursos. Familiarizarse con el protocolo de bootstrapping LWM2M y entender su importancia en entornos reales. Conocer dos herramientas para el desarrollo de sistemas basados en LWM2M: Wakaama y Leshan. Experimentar con el proceso de definici\u00f3n de objetos en Wakaama. Observar y poner en marcha un proceso de provisionamiento ( bootstrapping ) usando Wakaama. Desplegar servidores locales LWM2M usando tanto Wakaama como Leshan.","title":"Objetivos"},{"location":"Subjects/NP2/P8/#el-protocolo-lwm2m","text":"OMA Lightweight M2M (LWM2M) es un protocolo impulsado por la Open Mobile Alliance para la comunicaci\u00f3n M2M entre dispositivos y su gesti\u00f3n en entornos IoT. LWM2M est\u00e1 construido sobre el protocolo CoAP, y soporta, a nivel de transporte, el protocolo UDP (tambi\u00e9n presenta soporte para SMS). Entre las funcionalidades b\u00e1sicas de LWM2M destacan la existencia de servidores LWM2M, bootstrapping , control de acceso, gesti\u00f3n de dispositivos, actualizaciones de firmware , localizaci\u00f3n o estad\u00edsticas de conectividad. Adem\u00e1s, soporta seguridad a trav\u00e9s de DTLS. Concretamente, la primera especificaci\u00f3n de LWM2M (versi\u00f3n 1.0) introdujo las siguientes caracter\u00edsticas b\u00e1sicas: Definici\u00f3n de un modelo simple para la definici\u00f3n de recursos, basado en objetos. Definici\u00f3n de operaciones de creaci\u00f3n, consulta, modificaci\u00f3n, borrado y configuraci\u00f3n de recursos. Observaci\u00f3n/notificaci\u00f3n sobre recursos. Soporte para formato de datos JSON, texto plano y TLV. Colas de mensajes para soportar modos de bajo consumo en dispositivos. Soporte para m\u00faltiples servidores LWM2M. Objetos b\u00e1sicos LWM2M: Seguridad, Servidor, Control de Acceso, Dispositivo, Conectividad, Actualizaci\u00f3n de Firmware, Localizaci\u00f3n, Estad\u00edsticas de Conectividad. Para m\u00e1s informaci\u00f3n sobre los objetos predefinidos, consulta el siguiente enlace . Versiones subsiguientes del protocolo (1.1 y 1.2) introdujeron caracter\u00edsticas adicionales, como por ejemplo: Mejora del proceso de bootstrapping . Mejora del soporte para PKI. Soporte para TCP/TLS. Soporte para CBOR. Soporte para MQTT y HTTP como protocolos subyacentes.","title":"El protocolo LWM2M"},{"location":"Subjects/NP2/P8/#implementaciones-lwm2m","text":"En la presente pr\u00e1ctica, utilizaremos dos paquetes de software pertenecientes al proyecto Eclipse IoT, ambos con soporte completo para LWM2M. Cada uno de ellos presenta ventajas e inconvenientes que es necesario conocer.","title":"Implementaciones LWM2M"},{"location":"Subjects/NP2/P8/#eclipse-wakaama","text":"Eclipse Wakaama es un conjunto de ficheros fuente escritos en C que permiten ser integrados en cualquier proyecto para proporcionar funcionalidad de cliente , servidor y servidor de bootstrap LWM2M hasta su versi\u00f3n 1.1. En el lado cliente, Wakaama permite la definici\u00f3n de objetos conforme al est\u00e1ndar, as\u00ed como la recepci\u00f3n de comandos desde servidores y su enrutado hacia el objeto u objetos correspondientes. Desde el punto de vista servidor, Wakaama proporciona APIs para enviar comandos a clientes LWM2M registrados. Todo el proyecto es compatible con POSIX, y en esta pr\u00e1ctica experimentaremos con su funcionalidad trabajando desde Linux (modo cliente, servidor y servidor de bootstrap ) y desde el ESP32 (modo cliente).","title":"Eclipse Wakaama"},{"location":"Subjects/NP2/P8/#instalacion","text":"Utilizaremos una versi\u00f3n espec\u00edfica que permitir\u00e1 ser ejecutada tanto en Linux como en el ESP32. Para ello, clonamos en primer lugar la versi\u00f3n correspondiente del proyecto (es importante que utilices este commit espec\u00edfico): git clone https://github.com/eclipse/wakaama.git cd wakaama git reset --hard 31d64c0c41fae9653c1fa53ef58d1a44e49017fa El proyecto Wakaama proporciona cuatro componentes que utilizaremos durante la pr\u00e1ctica, todos dentro del directorio examples : bootstrap_server : implementa un servidor de bootstrap con l\u00ednea de comandos propia. client : implementa un cliente complejo, con definici\u00f3n de nueve objetos que siguen las especificaciones de la OMA m\u00e1s uno propio, y soporte para bootstrapping . lightclient : implementa un cliente sencillo, con definici\u00f3n de tres objetos seg\u00fan especificaciones OMA y un cuarto objeto propio. server : implementa un servidor LWM2M que ofrece l\u00ednea de comandos para la interacci\u00f3n con clientes registrados. El modo de compilar cada uno de los ejemplos es exactamente el mismo: Dir\u00edgete al directorio del ejemplo. Crea un directorio build y accede a \u00e9l. Configura el proyecto con la orden cmake .. . Compila el ejemplo con la orden make . Si todo ha ido bien, deber\u00edas tener un binario distinto en el directorio build correspondiente, con los que trabajar\u00e1s el resto de la pr\u00e1ctica. Tarea Compila cada uno de los ejemplos anteriormente mencionados en tu m\u00e1quina virtual, utilizando los par\u00e1metros por defecto para cada uno de ellos.","title":"Instalaci\u00f3n"},{"location":"Subjects/NP2/P8/#eclipse-leshan","text":"Eclipse Leshan es un proyecto alternativo que proporciona implementaciones en Java de clientes, servidores y servidores de bootstrap LWM2M, y est\u00e1 especialmente dise\u00f1ado para ser adaptable y extensible, permitiendo a los desarrolladores implementar sus propias versiones de cada uno de los tres anteriores elmentos adaptados a sus necesidades espec\u00edficas. Al igual que Wakaama, Leshan proporciona la definici\u00f3n e interacci\u00f3n con objetos IPSO, construcci\u00f3n sobre DTLS y utilizaci\u00f3n de CoAP como protocolo subyacente. Adem\u00e1s, el proyecto proporciona dos servidores de test que resultan muy \u00fatiles a la hora de desarrollar, v\u00e9ase: Servidor LWM2M en leshan.eclipseprojects.io , disponible en coap://leshan.eclipseprojects.io:5683 y coaps://leshan.eclipseprojects.io:5684 . Servidor de bootstrap en leshan.eclipseprojects.io/bs , disponible en coap://leshan.eclipseprojects.io:5783 y coaps://leshan.eclipseprojects.io:5784 .","title":"Eclipse Leshan"},{"location":"Subjects/NP2/P8/#instalacion_1","text":"Instala en primer lugar los prerequisitos necesarios para la correcta instalaci\u00f3n de Leshan (pueden variar en funci\u00f3n de tu distribuci\u00f3n Linux): sudo apt-get update sudo apt-get install openjdk-14-jdk maven git-core Clona el repositorio oficial de Leshan desde la siguiente direcci\u00f3n: git clone https://github.com/eclipse/leshan.git Por \u00faltimo, compila el proyecto: cd leshan mvn clean install Tras la fase de instalaci\u00f3n, podr\u00e1s lanzar tanto el servidor LWM2M: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. Como el servidor de bootstrapping : java -jar leshan-bsserver-demo/target/leshan-bsserver-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. En ambos casos, la salida asociada a la ejecuci\u00f3n de los servidores nos indicar\u00e1n la URL que podremos consultar desde cualquier navegador para obtener informaci\u00f3n del mismo, as\u00ed como la URL y puerto de escucha de cada uno, que deberemos indicar en los clientes correspondientes. Tarea Instala Eclipse Leshan y arranca el servidor LWM2M. Accede a la p\u00e1gina web de gesti\u00f3n y comprueba que efectivamente funciona. A continucaci\u00f3n, detenlo y haz lo propio con el servidor de bootstrapping .","title":"Instalaci\u00f3n"},{"location":"Subjects/NP2/P8/#eclipse-wakaama-cliente-y-servidor-lwm2m","text":"El objetivo principal de esta parte de la pr\u00e1ctica ser\u00e1 disponer de un sistema completo LWM2M basado en un cliente y dos servidores (uno LWM2M, otro de bootstrapping ), todos funcionando bajo Eclipse Wakaama. Para ello, en primer lugar, arrancaremos el servidor Wakaama en una de las terminales. Observa que el servidor, tras arrancar, expone una sencilla l\u00ednea de comandos que podemos aprovechar para interactuar con \u00e9l: ./lwm2mserver > help help Type 'help [COMMAND]' for more details on a command. list List registered clients. read Read from a client. disc Discover resources of a client. write Write to a client. time Write time-related attributes to a client. attr Write value-related attributes to a client. clear Clear attributes of a client. exec Execute a client resource. del Delete a client Object instance. create Create an Object instance. observe Observe from a client. cancel Cancel an observe. q Quit the server. La orden help muestra la ayuda global, pudi\u00e9ndose especializar para cada comando concreto: > help read read CLIENT# URI CLIENT#: client number as returned by command 'list' URI: uri to read such as /3, /3/0/2, /1024/11, /1024/0/1 Result will be displayed asynchronously. Si en este instante listamos un los clientes registrados, veremos que no hay ninguno: > list No client. En segundo lugar, vamos a arrancar el cliente Wakaama. Por defecto, este cliente intentar\u00e1 conectar con un servidor LWM2M existente en localhost , puerto 5683. En cualquier caso, estos valores pueden modificarse en la propia invocaci\u00f3n (consulta la opci\u00f3n -h para m\u00e1s informaci\u00f3n sobre par\u00e1metros disponibles): ./lwm2mclient Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > Opening connection to server at ::1:5683 -> State: STATE_REGISTERING 13 bytes received from [::1]:5683 64 41 69 06 06 69 E8 86 82 72 64 01 30 dAi..i...rd.0 -> State: STATE_READY > help help Type 'help [COMMAND]' for more details on a command. list List known servers. change Change the value of resource. update Trigger a registration update bootstrap Initiate a DI bootstrap process dispb Display current backup of objects/instances/resources (only security and server objects are backupped) ls List Objects and Instances disp Display current objects/instances/resources dump Dump an Object add Add support of object 31024 rm Remove support of object 31024 quit Quit the client gracefully. ^C Quit the client abruptly (without sending a de-register message). > -> State: STATE_READY Al igual que el servidor, el cliente soporta la introducci\u00f3n de comandos por parte del usuario. Observa que hemos ejecutado el comando help para mostrar los comandos disponibles. Adem\u00e1s, el cliente ha pasado desde un estado STATE_REGISTERING a un estado STATE_READY , lo que significa que se ha registrado correctamente en el servidor con el nombre testlwm2mclient . Observa ahora la salida del servidor, y ver\u00e1s que \u00e9ste ha realizado un proceso de descubrimiento de recursos en el cliente conectado. Concretamente, el servidor reporta la informaci\u00f3n relativa al nuevo cliente conectado: New client #0 registered. Client #0: name: \"testlwm2mclient\" version: \"1.1\" binding: \"UDP\" lifetime: 300 sec objects: /1/0, /2/0, /3/0, /4/0, /5/0, /6/0, /7/0, /31024/10, /31024/11, /31024/12, Concretamente, el n\u00famero asociado al cliente es el 0 . Podemos recuperar esta informaci\u00f3n en todo momento con el comando list en el servidor. En el cliente, puedes seleccionar el nombre que se utilizar\u00e1 en el proceso de registro con la opci\u00f3n -n . Tarea entregable Observa, utilizando Wireshark, el proceso de registro de un cliente en un servidor, y analiza el contenido del mensaje o mensajes intercambiados entre ambos. \u00bfQu\u00e9 protocolos se utilizan? El cliente con el que estamos trabajando es suficientemente complejo en su funcionamiento, y permite observar c\u00f3mo se implementa el soporte tanto para objetos predefinidos por la OMA como para objetos propios. Concretamente, el cliente implementa nueve objetos distintos: Security Object ( id=0 ). Server Object ( id=1 ). Access Control Object ( id=2 ), como un simple esqueleto, sin funcionalidad asociada. Device Object ( id=3 ), que contiene (y devuelve) valores espec\u00edficos codificados en base al ap\u00e9ndice E de la especificaci\u00f3n t\u00e9cnica de LWM2M. Connectivity Monitoring Object ( id=4 ), como un simple esqueleto, sin funcionalidad. Firmware Update Object ( id=5 ), como un simple esqueleto, sin funcionalidad. Location Object ( id=6 ), como un simple esqueleto, sin funcionalidad. Connectivity Statistics Object ( id=7 ), como un simple esqueleto, sin funcionalidad. Test Object ( id=31024 ), con la siguiente descripci\u00f3n: Objetos: Objeto ID Multiples Instancias Obligatorio Test 31024 S\u00ed No Recurso: Nombre ID Operaciones M\u00faltiples Instancias Obligatorio Tipo Rango test 1 R/W No Yes Integer 0-255 exec 2 E No Yes dec 3 R/W No Yes Float En el cliente, el comando dump nos permitir\u00e1 observar el contenido de una instancia determinada de un objeto, o de todas ellas. En el servidor, el comando read nos permitir\u00e1 hacer lo propio. Tarea entregable Analiza el valor actual de los objetos /3 y el objeto de test, tanto desde el cliente (comando dump ) como desde el servidor (comando read ). En \u00faltimo caso, realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos. Para escribir en un determinado recurso desde el servidor, podemos hacer uso del comando write de la siguiente forma: write 0 /31024/10/1 91 As\u00ed, estar\u00edamos escribiendo en el recurso 1 de la instancia 10 del objeto 31024 el valor entero 91. Tarea entregable Realiza escrituras en objetos del cliente y analiza el nuevo valor, comprobando que efectivamente se han llevado a cabo. Realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos en el caso de una escritura. Observa tambi\u00e9n que el servidor permite la observaci\u00f3n de recursos espec\u00edficos (comando observe ). Experimenta con esta opci\u00f3n y observa el tr\u00e1fico generado (puedes modificar el valor de un recurso desde el propio cliente y ver qu\u00e9 ocurre en el servidor). Por \u00faltimo, con la orden quit desconectamos del servidor. Observa tambi\u00e9n los mensajes CoAP que se generan en este caso.","title":"Eclipse Wakaama. Cliente y servidor LWM2M"},{"location":"Subjects/NP2/P8/#definicion-de-un-objeto-en-eclipse-wakaama","text":"Como has podido observar, el ejemplo de cliente define una serie de objetos, algunos especificados por la OMA, y otros personalizados. En este \u00faltimo caso, al que nos referiremos como test_object , se utilizan e ilustran algunas de las funcionalidades b\u00e1sicas de Wakaama como infraestructura para el desarrollo de Smart Objects v\u00eda LWM2M. Observa tanto el c\u00f3digo del cliente LWM2M (fichero fuente lwm2mclient.c del ejemplo client ) como la definici\u00f3n del objeto de test (fichero fuente test_object.c ). El primer fichero implementa la l\u00f3gica principal del cliente, incluyendo gesti\u00f3n de la conexi\u00f3n, l\u00f3gica de an\u00e1lisis de comandos introducidos por el usuario, gesti\u00f3n de bootstrapping , etc. Concretamente, nos interesa analizar las l\u00edneas relativas a la invocaci\u00f3n de la funci\u00f3n get_test_object , en cuyo interior se definen tanto los recursos como el comportamiento de nuestro cliente ante distintos tipos de operaciones sobre ellos. Observa que, al igual que para nuestro objeto de test, existen funciones similares para el resto de objetos definidos (obviamente podr\u00edan existir m\u00e1s), con un fichero fuente donde se define el comportamiento de cada uno de ellos. Uno de estos objetos es test_object.c . La principal funci\u00f3n de entrada a este m\u00f3dulo es precisamente get_test_object() . Observa que, en ella, se define el identificador del objeto, as\u00ed como cada uno de los recursos que expone (en este caso, tres), sus valores iniciales, y las funciones que se utilizar\u00e1n como callbacks asociados a cada posible operaci\u00f3n: lwm2m_object_t * testObj; testObj = (lwm2m_object_t *)lwm2m_malloc(sizeof(lwm2m_object_t)); if (NULL != testObj) { int i; prv_instance_t * targetP; memset(testObj, 0, sizeof(lwm2m_object_t)); testObj->objID = TEST_OBJECT_ID; for (i=0 ; i < 3 ; i++) { targetP = (prv_instance_t *)lwm2m_malloc(sizeof(prv_instance_t)); if (NULL == targetP) return NULL; memset(targetP, 0, sizeof(prv_instance_t)); targetP->shortID = 10 + i; targetP->test = 20 + i; targetP->dec = -30 + i + (double)i/100.0; testObj->instanceList = LWM2M_LIST_ADD(testObj->instanceList, targetP); } /* * From a single instance object, two more functions are available. * - The first one (createFunc) create a new instance and filled it with the provided informations. If an ID is * provided a check is done for verifying his disponibility, or a new one is generated. * - The other one (deleteFunc) delete an instance by removing it from the instance list (and freeing the memory * allocated to it) */ testObj->readFunc = prv_read; testObj->discoverFunc = prv_discover; testObj->writeFunc = prv_write; testObj->executeFunc = prv_exec; testObj->createFunc = prv_create; testObj->deleteFunc = prv_delete; } return testObj; Estas funciones de callback est\u00e1n definidas en el propio fichero, y su contenido es personalizable en funci\u00f3n del dise\u00f1o del objeto. Observemos, por ejemplo, el contenido de la funci\u00f3n asociada a la lectura, prv_read : static uint8_t prv_read(uint16_t instanceId, int * numDataP, lwm2m_data_t ** dataArrayP, lwm2m_object_t * objectP) { prv_instance_t * targetP; int i; targetP = (prv_instance_t *)lwm2m_list_find(objectP->instanceList, instanceId); if (NULL == targetP) return COAP_404_NOT_FOUND; if (*numDataP == 0) { *dataArrayP = lwm2m_data_new(2); if (*dataArrayP == NULL) return COAP_500_INTERNAL_SERVER_ERROR; *numDataP = 2; (*dataArrayP)[0].id = 1; (*dataArrayP)[1].id = 3; } for (i = 0 ; i < *numDataP ; i++) { switch ((*dataArrayP)[i].id) { case 1: lwm2m_data_encode_int(targetP->test, *dataArrayP + i); break; case 2: return COAP_405_METHOD_NOT_ALLOWED; case 3: lwm2m_data_encode_float(targetP->dec, *dataArrayP + i); break; default: return COAP_404_NOT_FOUND; } } return COAP_205_CONTENT; } Observa que en primer lugar se busca la instancia del objeto solicitada, devolvi\u00e9ndose el error correspondiente en caso de no existir (puedes comprobar esta funcionalidad solicitando desde el servidor la lectura de una instancia inexistente). El par\u00e1metro numDataP nos indica el recurso concreto que se desea leer, o todos si dicho valor es 0. Tras tomar el valor actual a servir, \u00e9ste se codifica en funci\u00f3n del tipo de datos predefinido para el recurso espec\u00edfico solicitado. En caso de no estar soportado el m\u00e9todo para un recurso espec\u00edfico, se devuelve el error correspondiente (en este caso 405 ). En caso de solicitar un recurso inexistente, se devuelve el error 404 . Tarea Comprueba que el comportamiento del objeto de test es el esperado, interactuando con \u00e9l desde el servidor utilizando todos los m\u00e9todos disponibles. Puedes modificar su comportamiento, a\u00f1adir invocaciones a rutinas de log , o lo que consideres de utilidad.","title":"Definici\u00f3n de un objeto en Eclipse Wakaama"},{"location":"Subjects/NP2/P8/#eclipse-wakaama-bootstrapping","text":"En este punto, el cliente Wakaama se conecta directamente con el servidor que hemos lanzado, y cuya direcci\u00f3n IP y puerto son los proporcionados por defecto en el c\u00f3digo. Llevado el cliente a un sensor, esto har\u00eda que nunca pudiese variar, durante el ciclo de vida del mismo, el servidor (o servidores) a los que conecta. Esto hace tambi\u00e9n que un cliente pueda \u00fanicamente conectar con un servidor LWM2M, cuando en algunas ocasiones es deseable replicar los mensajes enviados a m\u00faltiples servidores, bien por razones de tolerancia a fallos, o bien por necesidades de la aplicaci\u00f3n. Para solucionar este problema, los firmwares de f\u00e1brica suelen conocer \u00fanicamente la direcci\u00f3n o direcciones fijas de uno o varios servidores de bootstrap que, ante peticiones de provisionamiento, proporcionan al cliente las credenciales de seguridad y las direcciones de los servidores LWM2M en los que deben registrarse. As\u00ed, resulta sencillo manejar din\u00e1micamente ambos aspectos sin necesitar reflashear el firmware del sensor. En nuestro caso, utilizaremos un sencillo servidor de bootstrap proporcionado por Wakaama, aunque Leshan ofrece mecanismos mucho m\u00e1s sofisticados para realizar este mismo proceso, con su propio esqueleto de servidor bootstrap e interfaces REST (con monitores web) para gestionar el proceso. En primer lugar, dir\u00edgete al directorio que contiene el servidor bootstrap de Wakaama. All\u00ed encontrar\u00e1s un fichero de configuraci\u00f3n ( bootstrap_server.ini ) para el proceso de bootstrapping , cuyo contenido es completamente estructurado. El servidor, ante una petici\u00f3n de bootstrapping por parte de un cliente, responde en funci\u00f3n del contenido del fichero, que sigue las siguientes directivas: Las secciones soportadas son [Server] y [Endpoint] . [Server] describe una cuenta en un servidor LWM2M: Las claves soportadas en esta secci\u00f3n son: id: Identificador del servidor. (OBLIGATORIO). uri: URI del servidor LWM2M (OBLIGATORIO). bootstrap: YES o NO. Determina si este servidor es un servidor de bootstrap. Su valor por defecto es NO. lifetime: tiempo de vida del registro (opcional). security: modo de seguridad. Valores soportados: NoSec, PSK, RPK and Certificate (OBLIGATORIO). public: clave p\u00fablica o identidad del cliente, definida por el recurso /0/x/3 . server: clave p\u00fablica del servidor, definida por el recurso /0/x/4 . secret: clave privada definida por el recurso /0/x/5 . [Endpoint] contiene las operaciones de bootstrapping Si no se especifica un nombre (Name) las operaciones se enviar\u00e1n a cualquier cliente desconocido que solicite bootstrapping Si se especifica, las operaciones se enviar\u00e1n s\u00f3lo al cliente con el correspondiente nombre. Las operaciones se env\u00edan en el orden definido en el fichero. Las claves soportadas en esta secci\u00f3n son: - Name: Nombre del cliente (OPCIONAL). - Delete: Debe ser una URI LWM2M v\u00e1lida, incluida / . Env\u00eda una operaci\u00f3n delete en la URI indicada. - Server: [Value] es un ID de servidor que debe existir en la secci\u00f3n correspondiente. Env\u00eda operaciones de escritura sobre el objeto correspondiente del cliente para definir el servidor sobre el que debe conectar. Tarea Analiza e intenta entender el contenido por defecto del fichero de bootstrapping proporcionado. Puedes de momento obviar los par\u00e1metros referentes a seguridad, ya que los trataremos en la pr\u00f3xima pr\u00e1ctica. Tarea entregable Modifica el fichero de configuraci\u00f3n para que, ante la petici\u00f3n de un cliente con nombre determinado, conecte, por este orden, a un servidor LWM2M en la m\u00e1quina local, y al servidor de pruebas de Leshan en Internet. Adem\u00e1s, elimina cualquier intento de borrado de recursos en la informaci\u00f3n de bootstrapping para dicho cliente. Para arrancar el servidor bootstrap , basta con ejecutar (puedes utilizar otro fichero de configuraci\u00f3n): ./build/bootstrap_server -f bootstrap_server.ini El servidor quedar\u00e1 a la espera de peticiones por parte del cualquier cliente en el puerto 5685, tal y como indica su salida. Se puede forzar un proceso de bootstrapping con el comando boot , pero en este punto no es necesario. A continuaci\u00f3n, lanzaremos un cliente indicando que deseamos un proceso de bootstrapping contra el servidor local. Aseg\u00farate de dar un nombre a tu dispositivo que te permita diferenciarlo de cualquier otro : Nota importante Antes de realizar este ejercicio, debes modificar una l\u00ednea del fichero lwm2mclient.c , reemplazando la l\u00ednea que contiene data.addressFamily = AF_INET6; por data.addressFamily = AF_INET; . ./lwm2mclient -h localhost -p 5685 -b -c -n midispositivo Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > New Battery Level: 38 value changed! Opening connection to server at localhost:5685 -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING Observa que las opciones de invocaci\u00f3n han cambiado, y hemos usado -b para indicar que deseamos un proceso de bootstrapping contra el servidor proporcionado. Como nota adicional, la opci\u00f3n -c simplemente actualiza de forma peri\u00f3dica la lectura del nivel de bater\u00eda (esto no es en absoluto obligatorio, pero as\u00ed podremos observar sus cambios desde el servidor). Si todo ha ido bien, el cliente estar\u00e1 ahora registrado en dos servidores: el local Wakaama (observa su salida) y el remoto Leshan, al que puedes acceder a trav\u00e9s de la direcci\u00f3n leshan.eclipseprojects.io .","title":"Eclipse Wakaama. Bootstrapping"},{"location":"Subjects/NP2/P8/#eclipse-leshan-despliegue-de-un-servidor-local","text":"En este punto, tu cliente deber\u00eda estar conectado tanto a tu servidor LWM2M Wakaama local, como a un servidor Leshan en la nube. Aprovecha esta situaci\u00f3n para observar las funcionalides del servidor Leshan. Deber\u00edas, para un dispositivo con nombre \"foo\" observar algo como esto: Observa que todos y cada uno de los objetos de los que hablamos anteriormente se muestran ahora en pantalla tras el proceso de registro. Adem\u00e1s, para aquellos que son bien conocidos (estandarizados por la OMA), se muestran nombres legibles, no s\u00f3lo URIs. Tarea Busca y observa el recurso que te indica el nivel de bater\u00eda del cliente, y observa c\u00f3mo se actualiza autom\u00e1ticamente cuando var\u00eda en el cliente (ver\u00e1s a la vez un cambio en el servidor y un mensaje en el cliente). Interact\u00faa con el objeto de test que se defini\u00f3 anteriormente. En todos los casos, observa que, efectivamente, el tr\u00e1fico generado corresponde al esperado. Para replicar dicha instalaci\u00f3n en tu m\u00e1quina local, rescata la instalaci\u00f3n de Leshan que realizaste en la primera parte de la pr\u00e1ctica, y arranca el servidor LWM2M usando la siguiente orden: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar Tarea entregable Arranca el servidor Leshan para que escuche en un puerto diferente al que est\u00e1 escuchando ya el servidor Wakaama, para que puedan convivir en la misma m\u00e1quina. Modifica tu proceso de provisionamiento para que el cliente o clientes se conecten a ambos servidores. Tarea entregable El principal objetivo de esta parte es que seas capaz de definir un objeto e instanciarlo, con una cantidad de recursos suficientemente rica como para observar y ejercitar las capacidades de LWM2M en general, y de Eclipse Wakaama en particular. Por ello, se pide que definas, en primer lugar, uno o m\u00faltiples objetos y sus recursos que podr\u00edan formar parte de un hipot\u00e9tico sensor IoT. En segundo lugar, se pide que, siguiendo las directivas del c\u00f3digo analizado, lo implementes en Eclipse Wakaama y seas capaz de interactuar con \u00e9l desde un servidor Leshan y/o Wakaama utilizando adem\u00e1s un proceso de provisionamiento o bootstrapping .","title":"Eclipse Leshan. Despliegue de un servidor local"},{"location":"Subjects/NP2/P9/","text":"Pr\u00e1ctica 9. Node-RED Introducci\u00f3n y objetivos Node-RED es una herramienta de c\u00f3digo abierto desarrollada inicialmente por IBM y que, estando orientada a flujos de datos, proporciona mecanismos para asociar dispositivos hardware, APIs y servicios online dentro de un ecosistema IoT. Node-RED es una herramienta gr\u00e1fica, utilizable desde cualquier navegador web, que permite la craci\u00f3n y edici\u00f3n de flujos de datos que tomen datos de entrada (mediante nodos de entrada), los procesen (mediante nodos de procesamiento) y proporcionen salidas (mediante nodos de salida). Todos los elementos, incluyendo flujos complejos definidos por el usuario, pueden almacenarse en formato JSON para ser importados a continuaci\u00f3n en otras instalaciones. Node-RED permite la interconexi\u00f3n de elementos software y hardware mediante virtualmente cualquier protocolo conocido, facilitando el despliegue de infraestructuras IoT. El desarrollo de la pr\u00e1ctica difiere sobre el utilizado en pr\u00e1cticas anteriores. En este caso, el presente bolet\u00edn \u00fanicamente incluye informaci\u00f3n e instrucciones para la instalaci\u00f3n de la herramienta Node-RED en la m\u00e1quina virtual del curso (alternativamente, es posible instalar Node-RED en cualquier m\u00e1quina f\u00edsica), as\u00ed como la propuesta de ejercicio entregable a dise\u00f1ar e implementar. Se proporcionar\u00e1n las explicaciones y demostraciones necesarias durante la sesi\u00f3n de laboratorio para entender los conceptos b\u00e1sicos relativos a la instalaci\u00f3n y uso b\u00e1sico de la herramienta Node-RED. Instalaci\u00f3n y puesta en marcha Para instalar Node-RED en la m\u00e1quina virtual del curso, es suficiente con utilizar el gestor npm : sudo npm install -g --unsafe-perm node-red Al finalzar, si todo ha ido bien, deber\u00edas observar una salida similar a la siguiente: + node-red@1.1.0 added 332 packages from 341 contributors in 18.494s found 0 vulnerabilities Para ejecutar Node-RED, una vez instalado, es posible utilizar la orden node-red desde cualquier terminal. Para detener el proceso, es suficiente con utilizar Ctrl-C : $ node-red Welcome to Node-RED =================== 30 Jun 23:43:39 - [info] Node-RED version: v1.1.0 30 Jun 23:43:39 - [info] Node.js version: v10.21.0 30 Jun 23:43:39 - [info] Darwin 18.7.0 x64 LE 30 Jun 23:43:39 - [info] Loading palette nodes 30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive 30 Jun 23:43:44 - [info] Settings file : /Users/nol/.node-red/settings.js 30 Jun 23:43:44 - [info] HTTP Static : /Users/nol/node-red/web 30 Jun 23:43:44 - [info] Context store : 'default' [module=localfilesystem] 30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red 30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable 30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json 30 Jun 23:43:44 - [info] Starting flows 30 Jun 23:43:44 - [info] Started flows 30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/ Con el software arrancado, es posible acceder al editor Node-RED a trav\u00e9s de la direcci\u00f3n http://localhost:1880 en cualquier navegador. Tras arrancarlo, observar\u00e1s cuatro \u00e1reas en el editor: Barra principal , en la parte superior, con los botones Deploy y de Men\u00fa principal . Panel de nodos , en la parte izquierda, que proporciona acceso directo a todos los nodos disponibles en Node-RED. Es posible instalar nuevos nodos a trav\u00e9s de la Paleta de Nodos, disponible a trav\u00e9s del men\u00fa principal ( Manage Palette ). Estos nodos pueden ser arrastrados al editor para conformar nuevos flujos de datos. Panel de edici\u00f3n o espacio de trabajo , en la parte central de la pantalla, donde podr\u00e1s arrastrar y unir nuevos nodos. Es posible crear nuevos flujos en pesta\u00f1as independientes. Panel de informaci\u00f3n , en la parte derecha de la pantalla, donde destaca el bot\u00f3n Debug , mediante el cual veremos la salida de los nodos de tipo Debug en nuestros flujos. Ejemplo 1 Se muestra a continuaci\u00f3n un breve ejemplo b\u00e1sico de utilizaci\u00f3n del editor Node-RED, que incluye el uso de nodos Inject , Debug y Function . Nodo Inject El nodo Inject permite inyectar mensajes en un flujo, bien pulsando en el bot\u00f3n asociado al nodo, o estableciendo un intervalo de tiempo entre inyecciones. Busca en el panel izquierdo un nodo de tipo Inject y arr\u00e1stralo al espacio de trabajo. En el panel de informaci\u00f3n podr\u00e1s consultar los datos asociados al nodo, as\u00ed como informaci\u00f3n de ayuda para utilizarlo. Nodo Debug El nodo Debug permite que cualquier mensaje entrante se muestre en el panel de depuraci\u00f3n, en la parte derecha de la pantalla. Por defecto, \u00fanicamente muestra el payload del mensaje, aunque puede configurarse para mostrar el objeto completo. Arrastra un nodo de tipo Debug al espacio de trabajo. Uni\u00f3n y despliegue ( Deploy ) Conecta los nodos Inject y Debug estableciendo un enlace ( Wire ) entre ambos. Despliega el flujo usando el bot\u00f3n Deploy en la barra principal de Node-RED. Esto desplegar\u00e1 el fujo en el servidor. Selecciona la opci\u00f3n Debug en el panel de informaci\u00f3n, y presiona el bot\u00f3n del nodo Inject . Deber\u00edas ver n\u00fameros aparecer en el panel. Por defecto, el nodo Inject emite el n\u00famero de milisegundos desde el 1 de enero de 1970 como payload . Modifica (temporalmente) el nodo Debug para que muestre todo el mensaje en lugar del payload . Despliega de nuevo el flujo y observa las diferencias. Vuelve a configurar el nodo Debug tal y como estaba cuando lo insertaste. Nodo Function El nodo Function permite procesar el mensaje de entrada mediante una funci\u00f3n JavaScript. Borra el Wire existente y a\u00f1ade un nodo Function entre los nodos Inject y Debug . Haz doble clic en el nuevo nodo para abrir el di\u00e1logo de edici\u00f3n. Copia el siguiente c\u00f3digo en el campo Function : // Create a Date object from the payload var date = new Date(msg.payload); // Change the payload to be a formatted Date string msg.payload = date.toString(); // Return the message so it can be sent on return msg; Clica en Done y despliega el flujo. Observa que, ahora, los mensajes de depuraci\u00f3n muestran marcas de tiempo en formato visible. Ten en cuenta que un nodo siempre recibe un mensaje ( msg ) de entrada y devuelve un mensaje ( msg ) de salida. Ambos objetos contienen, por convenio, un campo payload . Para m\u00e1s informaci\u00f3n sobre el uso de funciones y trabajo con mensajes, incluyendo m\u00faltiples valores de retorno y trabajo con valores globales a todo el entorno, se recomienda estudiar la siguiente documentaci\u00f3n: Trabajo con mensajes : enlace a documentaci\u00f3n . Trabajo con funciones : enlace a documentaci\u00f3n . Ejemplo 2 Nodo Inject En el anterior ejemplo, vimos c\u00f3mo crear un nodo Inject para activar el flujo cuando se pulsaba su bot\u00f3n asociado. En este ejemplo, vamos a configurar el nodo Inject para que active el flujo en intervalos regulares. Arrastra un nuevo nodo Inject en el espacio de trabajo. Clica en \u00e9l dos veces y, en el di\u00e1logo de edici\u00f3n, usala opci\u00f3n Repeat interval , fij\u00e1ndolo en un intervalo regular. Cierra el di\u00e1logo de edici\u00f3n. Nodo HTTP Request El nodo de tipo HTTP Request puede utilizarse para descargar una p\u00e1gina web o recurso HTTP. A\u00f1ade uno al espacio de trabajo, y ed\u00edtalo para que su propiedad URL apunte a https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv . Esta URL es un repositorio de terremotos en el \u00faltimo mes, pulicado por el organismo oficial correspondiente, devueltos en formato CSV. Nodo CSV A\u00f1ade un nuevo nodo CSV y edita sus propiedades. Activa la opci\u00f3n First row contains column names y finaliza la edici\u00f3n. Nodo Debug y cableado A\u00f1ade un nodo Debug y une los nodos creados: Conecta la salida del nodo Inject a la entrada del nodo HTTP Request . Conecta la salida del nodo HTTP Request a la entrada del nodo CSV . Conecta la salida del nodo CSV a la entrada del nodo Debug . Nodo Switch A\u00f1ade un nodo Switch al espacio de trabajo. Edita sus propiedades y configuralo para comprobar la propiedad msg.payload.mag , usando la operaci\u00f3n >= sobre un valor num\u00e9rico y el valor 6.2 , por ejemplo. A\u00f1ade un segundo Wire entre el nodo CSV y el nodo Switch . Nodo Change A\u00f1ade un nodo Change , conectado a la salida del nodo Switch . Configuralo para establecer el valor de msg.payload a ALARMA . Nodo Debug A\u00f1ade un nodo Debug y despliega el flujo. En el panel de Debug , deber\u00e1s obsevar, para cada activaci\u00f3n del nodo Inject , una salida similar a esta: msg.payload : Object {\"time\":\"2017-11-19T15:09:03.120Z\",\"latitude\":-21.5167,\"longitude\":168.5426,\"depth\":14.19,\"mag\":6.6,\"magType\":\"mww\",\"gap\":21,\"dmin\":0.478,\"rms\":0.86,\"net\":\"us\",\"id\":\"us2000brgk\",\"updated\":\"2017-11-19T17:10:58.449Z\",\"place\":\"68km E of Tadine, New Caledonia\",\"type\":\"earthquake\",\"horizontalError\":6.2,\"depthError\":2.8,\"magError\":0.037,\"magNst\":72,\"status\":\"reviewed\",\"locationSource\":\"us\",\"magSource\":\"us\"} Puedes clicar en la peque\u00f1a flecha a la izquierda de cada propiedad para expandirla y examinar sus contenidos. Si existe cualquier terremoto de magnitud mayor a 6.2 , observar\u00e1s una salida adicional: msg.payload : string(6) \"ALARMA\" Para m\u00e1s informaci\u00f3n sobre los nodos b\u00e1sicos en Node-RED, puedes consultar: The Core Nodes : enlace a documentaci\u00f3n . Cliente MQTT y despliegue de un panel de control El nodo MQTT in permite realizar suscripciones a topics determinados en brokers MQTT. Arrastra un nuevo nodo MQTT in en tu espacio de trabajo y configura el broker asociado a localhost , puerto por defecto. Establece un topic de inter\u00e9s. Conecta un nodo Debug y despliega el flujo. Desde tu consola, publica mensajes v\u00eda mosquitto_pub y comprueba que, efectivamente, son visibles en Node-RED. A continuaci\u00f3n, crearemos un peque\u00f1o panel de control para la representaci\u00f3n gr\u00e1fica del valor publicado. En primer lugar, deber\u00e1s instalar el nodo node-red-dashboard desde el men\u00fa principal, opci\u00f3n Manage palette . Tras su instalaci\u00f3n, ver\u00e1s que aparecen nuevos nodos en el panel de nodos; \u00e9stos nos permitir\u00e1n dise\u00f1ar e implementar un panel de control b\u00e1sico basado en Widgets . Arrastra un nodo de tipo Gauge al espacio de trabajo, y configura sus valores por defecto. Conecta la salida de tu nodo MQTT in a la entrada del nuevo nodo Gauge . Despliega el flujo, y navega hasta http://localhost:1880/ui , donde deber\u00e1s observar el panel de control con el widget que has creado. Interact\u00faa con \u00e9l publicando mensajes v\u00eda MQTT. Para m\u00e1s informaci\u00f3n sobre el despliegue de paneles de control, puedes consultar: Node-Red-Dashboard : enlace a documentaci\u00f3n . Documentaci\u00f3n adicional Las gu\u00edas de usuario oficiales de Node-RED son un buen punto de partida para profundizar en el uso de la infraestructura. De entre ellas, la parte m\u00e1s importante para comenzar es la que introduce los conceptos b\u00e1sicos de Node-RED, incluyendo el trabajo con nodos, flujos, contexto (importante para trabajar con valores globales y compartidos por todos los nodos en un flujo, por ejemplo), mensajes, wires , etc.: Node-RED Concepts : enlace a documentaci\u00f3n . La gu\u00eda Node-RED Guide contiene interesante documentaci\u00f3n adicional/avanzada tanto en el despliegue de flujos como en el uso de paneles de control locales o usando servicios remotos (por ejemplo, Freeboard ): Node-RED Guide : enlace a documentaci\u00f3n . Ejercicio entregable Se pide estudiar la documentaci\u00f3n asociada a Node-RED, tanto en su web oficial como en la gu\u00eda de programaci\u00f3n Node-RED Guide (espec\u00edficamente sus cuatro primeras partes. Junto con la explicaci\u00f3n proporcionada por el profesor y los anteriores ejemplos, este estudio permitir\u00e1 el desarrollo de la pr\u00e1ctica. Tarea entregable La pr\u00e1ctica consiste en el dise\u00f1o y desarrollo de un sistema basado en flujos de datos construido sobre Node-RED, que implemente un mecanismo de monitorizaci\u00f3n de par\u00e1metros ambientales (por ejemplo, temperatura) y notificaci\u00f3n (alarmas) ante ciertas circunstancias (por ejemplo, superar una determinada temperatura fijada como umbral). Los alumnos dise\u00f1ar\u00e1n el sistema y lo implementar\u00e1n, cumpliendo las siguientes premisas: (2 puntos) . El sistema utilizar\u00e1, al menos , un dispositivo externo (ESP32, SensorTag, Tel\u00e9fono M\u00f3vil, ...) para la recolecci\u00f3n de datos. Se valorar\u00e1 el uso de m\u00e1s de un dispositivo. (2 puntos) . El sistema depositar\u00e1 o interactuar\u00e1 con, al menos , un sistema externo (servidor de correo, Twitter, Telegram, IBM Bluemix, ...). (2 puntos) . El sistema depositar\u00e1 los datos observados en alg\u00fan medio persistente (Base de Datos no relacional, ficheros, ...) para permitir su posterior an\u00e1lisis y en un panel de control. (2 puntos) . El sistema actuar\u00e1 como un sistema de alarma \u00fanicamente ante ciertas condiciones de entrada (por ejemplo, al recibir un valor desde un sensor superior a un umbral establecido; dicho valor podr\u00eda, por ejemplo, configurarse v\u00eda MQTT o a trav\u00e9s de un panel de control). (2 puntos) . El sistema utilizar\u00e1, al menos, un tipo de nodo no instalado por defecto en la instalaci\u00f3n b\u00e1sica de Node-RED. Se entregar\u00e1 el fichero o ficheros JSON que describen los nodos, as\u00ed como una breve memoria que describa el sistema dise\u00f1ado y el trabajo realizado, haciendo hincapi\u00e9 en las dificultades encontradas y aquellos aspectos que se consideren de inter\u00e9s por parte del alumno/a.","title":"Pr\u00e1ctica 9. Node-RED"},{"location":"Subjects/NP2/P9/#practica-9-node-red","text":"","title":"Pr\u00e1ctica 9. Node-RED"},{"location":"Subjects/NP2/P9/#introduccion-y-objetivos","text":"Node-RED es una herramienta de c\u00f3digo abierto desarrollada inicialmente por IBM y que, estando orientada a flujos de datos, proporciona mecanismos para asociar dispositivos hardware, APIs y servicios online dentro de un ecosistema IoT. Node-RED es una herramienta gr\u00e1fica, utilizable desde cualquier navegador web, que permite la craci\u00f3n y edici\u00f3n de flujos de datos que tomen datos de entrada (mediante nodos de entrada), los procesen (mediante nodos de procesamiento) y proporcionen salidas (mediante nodos de salida). Todos los elementos, incluyendo flujos complejos definidos por el usuario, pueden almacenarse en formato JSON para ser importados a continuaci\u00f3n en otras instalaciones. Node-RED permite la interconexi\u00f3n de elementos software y hardware mediante virtualmente cualquier protocolo conocido, facilitando el despliegue de infraestructuras IoT. El desarrollo de la pr\u00e1ctica difiere sobre el utilizado en pr\u00e1cticas anteriores. En este caso, el presente bolet\u00edn \u00fanicamente incluye informaci\u00f3n e instrucciones para la instalaci\u00f3n de la herramienta Node-RED en la m\u00e1quina virtual del curso (alternativamente, es posible instalar Node-RED en cualquier m\u00e1quina f\u00edsica), as\u00ed como la propuesta de ejercicio entregable a dise\u00f1ar e implementar. Se proporcionar\u00e1n las explicaciones y demostraciones necesarias durante la sesi\u00f3n de laboratorio para entender los conceptos b\u00e1sicos relativos a la instalaci\u00f3n y uso b\u00e1sico de la herramienta Node-RED.","title":"Introducci\u00f3n y objetivos"},{"location":"Subjects/NP2/P9/#instalacion-y-puesta-en-marcha","text":"Para instalar Node-RED en la m\u00e1quina virtual del curso, es suficiente con utilizar el gestor npm : sudo npm install -g --unsafe-perm node-red Al finalzar, si todo ha ido bien, deber\u00edas observar una salida similar a la siguiente: + node-red@1.1.0 added 332 packages from 341 contributors in 18.494s found 0 vulnerabilities Para ejecutar Node-RED, una vez instalado, es posible utilizar la orden node-red desde cualquier terminal. Para detener el proceso, es suficiente con utilizar Ctrl-C : $ node-red Welcome to Node-RED =================== 30 Jun 23:43:39 - [info] Node-RED version: v1.1.0 30 Jun 23:43:39 - [info] Node.js version: v10.21.0 30 Jun 23:43:39 - [info] Darwin 18.7.0 x64 LE 30 Jun 23:43:39 - [info] Loading palette nodes 30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive 30 Jun 23:43:44 - [info] Settings file : /Users/nol/.node-red/settings.js 30 Jun 23:43:44 - [info] HTTP Static : /Users/nol/node-red/web 30 Jun 23:43:44 - [info] Context store : 'default' [module=localfilesystem] 30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red 30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable 30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json 30 Jun 23:43:44 - [info] Starting flows 30 Jun 23:43:44 - [info] Started flows 30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/ Con el software arrancado, es posible acceder al editor Node-RED a trav\u00e9s de la direcci\u00f3n http://localhost:1880 en cualquier navegador. Tras arrancarlo, observar\u00e1s cuatro \u00e1reas en el editor: Barra principal , en la parte superior, con los botones Deploy y de Men\u00fa principal . Panel de nodos , en la parte izquierda, que proporciona acceso directo a todos los nodos disponibles en Node-RED. Es posible instalar nuevos nodos a trav\u00e9s de la Paleta de Nodos, disponible a trav\u00e9s del men\u00fa principal ( Manage Palette ). Estos nodos pueden ser arrastrados al editor para conformar nuevos flujos de datos. Panel de edici\u00f3n o espacio de trabajo , en la parte central de la pantalla, donde podr\u00e1s arrastrar y unir nuevos nodos. Es posible crear nuevos flujos en pesta\u00f1as independientes. Panel de informaci\u00f3n , en la parte derecha de la pantalla, donde destaca el bot\u00f3n Debug , mediante el cual veremos la salida de los nodos de tipo Debug en nuestros flujos.","title":"Instalaci\u00f3n y puesta en marcha"},{"location":"Subjects/NP2/P9/#ejemplo-1","text":"Se muestra a continuaci\u00f3n un breve ejemplo b\u00e1sico de utilizaci\u00f3n del editor Node-RED, que incluye el uso de nodos Inject , Debug y Function .","title":"Ejemplo 1"},{"location":"Subjects/NP2/P9/#nodo-inject","text":"El nodo Inject permite inyectar mensajes en un flujo, bien pulsando en el bot\u00f3n asociado al nodo, o estableciendo un intervalo de tiempo entre inyecciones. Busca en el panel izquierdo un nodo de tipo Inject y arr\u00e1stralo al espacio de trabajo. En el panel de informaci\u00f3n podr\u00e1s consultar los datos asociados al nodo, as\u00ed como informaci\u00f3n de ayuda para utilizarlo.","title":"Nodo Inject"},{"location":"Subjects/NP2/P9/#nodo-debug","text":"El nodo Debug permite que cualquier mensaje entrante se muestre en el panel de depuraci\u00f3n, en la parte derecha de la pantalla. Por defecto, \u00fanicamente muestra el payload del mensaje, aunque puede configurarse para mostrar el objeto completo. Arrastra un nodo de tipo Debug al espacio de trabajo.","title":"Nodo Debug"},{"location":"Subjects/NP2/P9/#union-y-despliegue-deploy","text":"Conecta los nodos Inject y Debug estableciendo un enlace ( Wire ) entre ambos. Despliega el flujo usando el bot\u00f3n Deploy en la barra principal de Node-RED. Esto desplegar\u00e1 el fujo en el servidor. Selecciona la opci\u00f3n Debug en el panel de informaci\u00f3n, y presiona el bot\u00f3n del nodo Inject . Deber\u00edas ver n\u00fameros aparecer en el panel. Por defecto, el nodo Inject emite el n\u00famero de milisegundos desde el 1 de enero de 1970 como payload . Modifica (temporalmente) el nodo Debug para que muestre todo el mensaje en lugar del payload . Despliega de nuevo el flujo y observa las diferencias. Vuelve a configurar el nodo Debug tal y como estaba cuando lo insertaste.","title":"Uni\u00f3n y despliegue (Deploy)"},{"location":"Subjects/NP2/P9/#nodo-function","text":"El nodo Function permite procesar el mensaje de entrada mediante una funci\u00f3n JavaScript. Borra el Wire existente y a\u00f1ade un nodo Function entre los nodos Inject y Debug . Haz doble clic en el nuevo nodo para abrir el di\u00e1logo de edici\u00f3n. Copia el siguiente c\u00f3digo en el campo Function : // Create a Date object from the payload var date = new Date(msg.payload); // Change the payload to be a formatted Date string msg.payload = date.toString(); // Return the message so it can be sent on return msg; Clica en Done y despliega el flujo. Observa que, ahora, los mensajes de depuraci\u00f3n muestran marcas de tiempo en formato visible. Ten en cuenta que un nodo siempre recibe un mensaje ( msg ) de entrada y devuelve un mensaje ( msg ) de salida. Ambos objetos contienen, por convenio, un campo payload . Para m\u00e1s informaci\u00f3n sobre el uso de funciones y trabajo con mensajes, incluyendo m\u00faltiples valores de retorno y trabajo con valores globales a todo el entorno, se recomienda estudiar la siguiente documentaci\u00f3n: Trabajo con mensajes : enlace a documentaci\u00f3n . Trabajo con funciones : enlace a documentaci\u00f3n .","title":"Nodo Function"},{"location":"Subjects/NP2/P9/#ejemplo-2","text":"","title":"Ejemplo 2"},{"location":"Subjects/NP2/P9/#nodo-inject_1","text":"En el anterior ejemplo, vimos c\u00f3mo crear un nodo Inject para activar el flujo cuando se pulsaba su bot\u00f3n asociado. En este ejemplo, vamos a configurar el nodo Inject para que active el flujo en intervalos regulares. Arrastra un nuevo nodo Inject en el espacio de trabajo. Clica en \u00e9l dos veces y, en el di\u00e1logo de edici\u00f3n, usala opci\u00f3n Repeat interval , fij\u00e1ndolo en un intervalo regular. Cierra el di\u00e1logo de edici\u00f3n.","title":"Nodo Inject"},{"location":"Subjects/NP2/P9/#nodo-http-request","text":"El nodo de tipo HTTP Request puede utilizarse para descargar una p\u00e1gina web o recurso HTTP. A\u00f1ade uno al espacio de trabajo, y ed\u00edtalo para que su propiedad URL apunte a https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv . Esta URL es un repositorio de terremotos en el \u00faltimo mes, pulicado por el organismo oficial correspondiente, devueltos en formato CSV.","title":"Nodo HTTP Request"},{"location":"Subjects/NP2/P9/#nodo-csv","text":"A\u00f1ade un nuevo nodo CSV y edita sus propiedades. Activa la opci\u00f3n First row contains column names y finaliza la edici\u00f3n.","title":"Nodo CSV"},{"location":"Subjects/NP2/P9/#nodo-debug-y-cableado","text":"A\u00f1ade un nodo Debug y une los nodos creados: Conecta la salida del nodo Inject a la entrada del nodo HTTP Request . Conecta la salida del nodo HTTP Request a la entrada del nodo CSV . Conecta la salida del nodo CSV a la entrada del nodo Debug .","title":"Nodo Debug y cableado"},{"location":"Subjects/NP2/P9/#nodo-switch","text":"A\u00f1ade un nodo Switch al espacio de trabajo. Edita sus propiedades y configuralo para comprobar la propiedad msg.payload.mag , usando la operaci\u00f3n >= sobre un valor num\u00e9rico y el valor 6.2 , por ejemplo. A\u00f1ade un segundo Wire entre el nodo CSV y el nodo Switch .","title":"Nodo Switch"},{"location":"Subjects/NP2/P9/#nodo-change","text":"A\u00f1ade un nodo Change , conectado a la salida del nodo Switch . Configuralo para establecer el valor de msg.payload a ALARMA .","title":"Nodo Change"},{"location":"Subjects/NP2/P9/#nodo-debug_1","text":"A\u00f1ade un nodo Debug y despliega el flujo. En el panel de Debug , deber\u00e1s obsevar, para cada activaci\u00f3n del nodo Inject , una salida similar a esta: msg.payload : Object {\"time\":\"2017-11-19T15:09:03.120Z\",\"latitude\":-21.5167,\"longitude\":168.5426,\"depth\":14.19,\"mag\":6.6,\"magType\":\"mww\",\"gap\":21,\"dmin\":0.478,\"rms\":0.86,\"net\":\"us\",\"id\":\"us2000brgk\",\"updated\":\"2017-11-19T17:10:58.449Z\",\"place\":\"68km E of Tadine, New Caledonia\",\"type\":\"earthquake\",\"horizontalError\":6.2,\"depthError\":2.8,\"magError\":0.037,\"magNst\":72,\"status\":\"reviewed\",\"locationSource\":\"us\",\"magSource\":\"us\"} Puedes clicar en la peque\u00f1a flecha a la izquierda de cada propiedad para expandirla y examinar sus contenidos. Si existe cualquier terremoto de magnitud mayor a 6.2 , observar\u00e1s una salida adicional: msg.payload : string(6) \"ALARMA\" Para m\u00e1s informaci\u00f3n sobre los nodos b\u00e1sicos en Node-RED, puedes consultar: The Core Nodes : enlace a documentaci\u00f3n .","title":"Nodo Debug"},{"location":"Subjects/NP2/P9/#cliente-mqtt-y-despliegue-de-un-panel-de-control","text":"El nodo MQTT in permite realizar suscripciones a topics determinados en brokers MQTT. Arrastra un nuevo nodo MQTT in en tu espacio de trabajo y configura el broker asociado a localhost , puerto por defecto. Establece un topic de inter\u00e9s. Conecta un nodo Debug y despliega el flujo. Desde tu consola, publica mensajes v\u00eda mosquitto_pub y comprueba que, efectivamente, son visibles en Node-RED. A continuaci\u00f3n, crearemos un peque\u00f1o panel de control para la representaci\u00f3n gr\u00e1fica del valor publicado. En primer lugar, deber\u00e1s instalar el nodo node-red-dashboard desde el men\u00fa principal, opci\u00f3n Manage palette . Tras su instalaci\u00f3n, ver\u00e1s que aparecen nuevos nodos en el panel de nodos; \u00e9stos nos permitir\u00e1n dise\u00f1ar e implementar un panel de control b\u00e1sico basado en Widgets . Arrastra un nodo de tipo Gauge al espacio de trabajo, y configura sus valores por defecto. Conecta la salida de tu nodo MQTT in a la entrada del nuevo nodo Gauge . Despliega el flujo, y navega hasta http://localhost:1880/ui , donde deber\u00e1s observar el panel de control con el widget que has creado. Interact\u00faa con \u00e9l publicando mensajes v\u00eda MQTT. Para m\u00e1s informaci\u00f3n sobre el despliegue de paneles de control, puedes consultar: Node-Red-Dashboard : enlace a documentaci\u00f3n .","title":"Cliente MQTT y despliegue de un panel de control"},{"location":"Subjects/NP2/P9/#documentacion-adicional","text":"Las gu\u00edas de usuario oficiales de Node-RED son un buen punto de partida para profundizar en el uso de la infraestructura. De entre ellas, la parte m\u00e1s importante para comenzar es la que introduce los conceptos b\u00e1sicos de Node-RED, incluyendo el trabajo con nodos, flujos, contexto (importante para trabajar con valores globales y compartidos por todos los nodos en un flujo, por ejemplo), mensajes, wires , etc.: Node-RED Concepts : enlace a documentaci\u00f3n . La gu\u00eda Node-RED Guide contiene interesante documentaci\u00f3n adicional/avanzada tanto en el despliegue de flujos como en el uso de paneles de control locales o usando servicios remotos (por ejemplo, Freeboard ): Node-RED Guide : enlace a documentaci\u00f3n .","title":"Documentaci\u00f3n adicional"},{"location":"Subjects/NP2/P9/#ejercicio-entregable","text":"Se pide estudiar la documentaci\u00f3n asociada a Node-RED, tanto en su web oficial como en la gu\u00eda de programaci\u00f3n Node-RED Guide (espec\u00edficamente sus cuatro primeras partes. Junto con la explicaci\u00f3n proporcionada por el profesor y los anteriores ejemplos, este estudio permitir\u00e1 el desarrollo de la pr\u00e1ctica. Tarea entregable La pr\u00e1ctica consiste en el dise\u00f1o y desarrollo de un sistema basado en flujos de datos construido sobre Node-RED, que implemente un mecanismo de monitorizaci\u00f3n de par\u00e1metros ambientales (por ejemplo, temperatura) y notificaci\u00f3n (alarmas) ante ciertas circunstancias (por ejemplo, superar una determinada temperatura fijada como umbral). Los alumnos dise\u00f1ar\u00e1n el sistema y lo implementar\u00e1n, cumpliendo las siguientes premisas: (2 puntos) . El sistema utilizar\u00e1, al menos , un dispositivo externo (ESP32, SensorTag, Tel\u00e9fono M\u00f3vil, ...) para la recolecci\u00f3n de datos. Se valorar\u00e1 el uso de m\u00e1s de un dispositivo. (2 puntos) . El sistema depositar\u00e1 o interactuar\u00e1 con, al menos , un sistema externo (servidor de correo, Twitter, Telegram, IBM Bluemix, ...). (2 puntos) . El sistema depositar\u00e1 los datos observados en alg\u00fan medio persistente (Base de Datos no relacional, ficheros, ...) para permitir su posterior an\u00e1lisis y en un panel de control. (2 puntos) . El sistema actuar\u00e1 como un sistema de alarma \u00fanicamente ante ciertas condiciones de entrada (por ejemplo, al recibir un valor desde un sensor superior a un umbral establecido; dicho valor podr\u00eda, por ejemplo, configurarse v\u00eda MQTT o a trav\u00e9s de un panel de control). (2 puntos) . El sistema utilizar\u00e1, al menos, un tipo de nodo no instalado por defecto en la instalaci\u00f3n b\u00e1sica de Node-RED. Se entregar\u00e1 el fichero o ficheros JSON que describen los nodos, as\u00ed como una breve memoria que describa el sistema dise\u00f1ado y el trabajo realizado, haciendo hincapi\u00e9 en las dificultades encontradas y aquellos aspectos que se consideren de inter\u00e9s por parte del alumno/a.","title":"Ejercicio entregable"},{"location":"Subjects/SEC/","text":"SEC","title":"SEC"},{"location":"Subjects/SID/","text":"Smart Infrastructure Design All the information and documentation about Smart Infrastructure Design (SID) can be found in this link","title":"SID"},{"location":"Subjects/SID/#smart-infrastructure-design","text":"All the information and documentation about Smart Infrastructure Design (SID) can be found in this link","title":"Smart Infrastructure Design"}]}