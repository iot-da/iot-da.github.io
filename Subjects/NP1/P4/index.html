<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="None">
        
        <link rel="canonical" href="https://iot-da.github.io/Subjects/NP1/P4/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Internet of Things and Data Analytics</title>
        <link href="../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body class="homepage">

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../../..">Internet of Things and Data Analytics</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../../..">Home</a>
                            </li>
                            <li >
                                <a href="../../../General/">General info.</a>
                            </li>
                            <li >
                                <a href="../../../News/">News</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Subjects <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../IOTNA/">IOTNA</a>
</li>
                                    
<li >
    <a href="../../MDM/">MDM</a>
</li>
                                    
<li >
    <a href="../../SID/">SID</a>
</li>
                                    
<li >
    <a href="../../IA/">IA</a>
</li>
                                    
<li >
    <a href="../">NP1</a>
</li>
                                    
<li >
    <a href="../../NP2/">NP2</a>
</li>
                                    
<li >
    <a href="../../SEC/">SEC</a>
</li>
                                    
<li >
    <a href="../../EDGE/">EDGE</a>
</li>
                                </ul>
                            </li>
                            <li >
                                <a href="../../../Contact/">Contact</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#lab-4-bluetooth-low-energy-ble">Lab 4. Bluetooth Low Energy (BLE)</a></li>
        <li class="main "><a href="#goals">Goals</a></li>
        <li class="main "><a href="#gatt-sever-implementation">GATT Sever Implementation</a></li>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#includes">Includes</a></li>
            <li><a href="#service-table">Service Table</a></li>
            <li><a href="#main-entry-point">Main Entry Point</a></li>
            <li><a href="#bt-controller-and-stack-initialization">BT Controller and Stack Initialization</a></li>
            <li><a href="#application-profiles">Application Profiles</a></li>
            <li><a href="#setting-gap-parameters">Setting GAP Parameters</a></li>
            <li><a href="#gap-event-handler">GAP Event Handler</a></li>
            <li><a href="#gatt-event-handlers">GATT Event Handlers</a></li>
            <li><a href="#creating-services-and-characteristics-with-the-attribute-table">Creating Services and Characteristics with the Attribute Table</a></li>
            <li><a href="#starting-the-service">Starting the Service</a></li>
        <li class="main "><a href="#interaction-with-the-gatt-server">Interaction with the GATT Server</a></li>
            <li><a href="#using-hcitool-and-gatttool-in-client-mode">Using hcitool and gatttool in client mode</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="lab-4-bluetooth-low-energy-ble">Lab 4. Bluetooth Low Energy (BLE)</h1>
<h1 id="goals">Goals</h1>
<ul>
<li>Dissect in detail a GATT table construction <em>firmware</em> (GATT server) using the
  ESP-IDF API.</li>
<li>Learn to use <code>gatttool</code> to interact with the GATT server.</li>
<li>Modify the GATT server to accept notification requests from the client,
  and to publish updated values for a certain characteristic on demand.</li>
</ul>
<h1 id="gatt-sever-implementation">GATT Sever Implementation</h1>
<h2 id="introduction">Introduction</h2>
<p>In this lab assignmet, we will deploy a GATT server using the ESP-IDF API. This
API exposes the functionalities of Bluedroid, the Bluetooth stack (including
BLE) that provides ESP-IDF for the development of Bluetooth applications.</p>
<p>We will use the example from <code>examples/bluetooth/bluedroid/ble/gatt_server_service_table</code>,
which example implements a Bluetooth Low Energy (BLE) Generic
Attribute (GATT) Server using a table-like data structure to define the server
services and characteristics such as the one shown in the figure below
Therefore, it demonstrates a practical way to define the server functionality in
one place instead of adding services and characteristics one by one.</p>
<p>This example implements the <em>Heart Rate Profile</em> as defined by the <a href="https://www.bluetooth.com/specifications/profiles-overview">Traditional
Profile Specifications</a>.</p>
<div align="center"><img src="img/Heart_Rate_Service.png" width = "450" alt="Table-like data structure representing the Heart Rate Service" align=center /> </div>

<p>We will therefore display three characteristics. Of them, the most important for
us will be the heart rate measurement value, with its value (<em>Heart Rate
Measurement Value</em>) and its notification settings (<em>Heart Rate Measurement
Notification Configuration</em>).</p>
<p>Due to the complexity of the code (at least in its initial part), this document
follows the program workflow and breaks down the code in order to make sense of
every section and reasoning behind the implementation.</p>
<h2 id="includes">Includes</h2>
<p>Letâ€™s start by taking a look at the included headers:</p>
<pre><code class="c">#include &quot;freertos/FreeRTOS.h&quot;
#include &quot;freertos/task.h&quot;
#include &quot;freertos/event_groups.h&quot;
#include &quot;esp_system.h&quot;
#include &quot;esp_log.h&quot;
#include &quot;nvs_flash.h&quot;
#include &quot;esp_bt.h&quot;
#include &quot;esp_gap_ble_api.h&quot;
#include &quot;esp_gatts_api.h&quot;
#include &quot;esp_bt_main.h&quot;
#include &quot;gatts_table_creat_demo.h&quot;
#include &quot;esp_gatt_common_api.h&quot;
</code></pre>

<p>These includes are required for the <em>FreeRTOS</em> and underlaying system components
to run, including logging functionality and a library to store data in
non-volatile flash memory. We are interested in <code>bt.h</code>, <code>esp_bt_main.h</code>,
<code>esp_gap_ble_api.h</code> and <code>esp_gatts_api.h</code> which expose the BLE APIs required
to implement this example.</p>
<ul>
<li><code>esp_bt.h</code>: implements BT controller and VHCI configuration procedures from the host side.</li>
<li><code>esp_bt_main.h</code>: implements initialization and enabling of the Bluedroid stack.</li>
<li><code>esp_gap_ble_api.h</code>: implements GAP configuration such as advertising and connection parameters.</li>
<li><code>esp_gatts_api.h</code>: implements GATT Server configuration such as creating services and characteristics.</li>
</ul>
<h2 id="service-table">Service Table</h2>
<p>The header file <code>gatts_table_creat_demo.h</code> is where an enumeration of the
services and characteristics is created:</p>
<pre><code class="c">enum
{
    IDX_SVC,
    IDX_CHAR_A,
    IDX_CHAR_VAL_A,
    IDX_CHAR_CFG_A,

    IDX_CHAR_B,
    IDX_CHAR_VAL_B,

    IDX_CHAR_C,
    IDX_CHAR_VAL_C,

    HRS_IDX_NB,
};
</code></pre>

<p>The enumeration elements are set up in the same order as the Heart Rate Profile
attributes, starting with the service followed by the characteristics of that
service. In addition, the Heart Rate Measurement characteristic has a Client
Characteristic Configuration (CCC) descriptor which is an additional attribute
that describes if the characteristic has notifications enabled. The enumeration
index can be used to identify each element later when creating the actual
attributes table. In summary, the elements are described as follows:</p>
<ul>
<li><code>IDX_SVC</code>: Heart Rate Service index</li>
<li><code>IDX_CHAR_A</code>: Heart Rate Measurement characteristic index</li>
<li><code>IDX_CHAR_VAL_A</code>: Heart Rate Measurement characteristic value index</li>
<li><code>IDX_CHAR_CFG_A</code>: Heart Rate Measurement notifications configuration (CCC) index</li>
<li><code>IDX_CHAR_B</code>: Heart Rate Body Sensor Location characteristic index</li>
<li><code>IDX_CHAR_VAL_B</code>: Heart Rate Body Sensor Location characteristic value index</li>
<li><code>IDX_CHAR_C</code>: Heart Rate Control Point characteristic index</li>
<li><code>IDX_CHAR_VAL_C</code>: Heart Rate Control Point characteristic value index</li>
<li><code>IDX_NB</code>: Number of table elements.</li>
</ul>
<h2 id="main-entry-point">Main Entry Point</h2>
<p>The entry point to this example is the <code>app_main()</code> function:</p>
<pre><code class="c">void app_main(void)
{
    esp_err_t ret;

    /* Initialize NVS. */
    ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK( ret );

    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));

    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ret = esp_bt_controller_init(&amp;bt_cfg);
    if (ret) {
        ESP_LOGE(GATTS_TABLE_TAG, &quot;%s enable controller failed: %s&quot;, __func__, esp_err_to_name(ret));
        return;
    }

    ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
    if (ret) {
        ESP_LOGE(GATTS_TABLE_TAG, &quot;%s enable controller failed: %s&quot;, __func__, esp_err_to_name(ret));
        return;
    }

    ret = esp_bluedroid_init();
    if (ret) {
        ESP_LOGE(GATTS_TABLE_TAG, &quot;%s init bluetooth failed: %s&quot;, __func__, esp_err_to_name(ret));
        return;
    }

    ret = esp_bluedroid_enable();
    if (ret) {
        ESP_LOGE(GATTS_TABLE_TAG, &quot;%s enable bluetooth failed: %s&quot;, __func__, esp_err_to_name(ret));
        return;
    }

    ret = esp_ble_gatts_register_callback(gatts_event_handler);
    if (ret){
        ESP_LOGE(GATTS_TABLE_TAG, &quot;gatts register error, error code = %x&quot;, ret);
        return;
    }

    ret = esp_ble_gap_register_callback(gap_event_handler);
    if (ret){
        ESP_LOGE(GATTS_TABLE_TAG, &quot;gap register error, error code = %x&quot;, ret);
        return;
    }

    ret = esp_ble_gatts_app_register(ESP_APP_ID);
    if (ret){
        ESP_LOGE(GATTS_TABLE_TAG, &quot;gatts app register error, error code = %x&quot;, ret);
        return;
    }

    esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500);
    if (local_mtu_ret){
        ESP_LOGE(GATTS_TABLE_TAG, &quot;set local  MTU failed, error code = %x&quot;, local_mtu_ret);
    }
}
</code></pre>

<p>The main function starts by initializing the non-volatile storage library in
order to be able to save parameters in flash memory.</p>
<pre><code class="c">ret = nvs_flash_init();
</code></pre>

<h2 id="bt-controller-and-stack-initialization">BT Controller and Stack Initialization</h2>
<p>The main function also initializes the BT controller by first creating a BT
controller configuration structure named <code>esp_bt_controller_config_t</code> with
default settings generated by the <code>BT_CONTROLLER_INIT_CONFIG_DEFAULT()</code> macro.</p>
<p>The BT controller implements the Host Controller Interface (HCI) on the
controller side, the Link Layer (LL) and the Physical Layer (PHY). The BT
Controller is invisible to the user applications and deals with the lower layers
of the BLE stack. The controller configuration includes setting the BT
controller stack size, priority and HCI baud rate. With the settings created,
the BT controller is initialized and enabled with the <code>esp_bt_controller_init()</code>
function:</p>
<pre><code class="c">esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
ret = esp_bt_controller_init(&amp;bt_cfg);
</code></pre>

<p>Next, the controller is enabled in BLE Mode.</p>
<pre><code class="c">ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
</code></pre>

<p>There are four Bluetooth modes supported:</p>
<ol>
<li><code>ESP_BT_MODE_IDLE</code>: Bluetooth not running</li>
<li><code>ESP_BT_MODE_BLE</code>: BLE mode</li>
<li><code>ESP_BT_MODE_CLASSIC_BT</code>: BT Classic mode</li>
<li><code>ESP_BT_MODE_BTDM</code>: Dual mode (BLE + BT Classic)</li>
</ol>
<p>After the initialization of the BT controller, the Bluedroid stack, which
includes the common definitions and APIs for both BT Classic and BLE, is
initialized and enabled by using:</p>
<pre><code class="c">ret = esp_bluedroid_init();
ret = esp_bluedroid_enable();
</code></pre>

<p>The Bluetooth stack is up and running at this point in the program flow, however
the functionality of the application has not been defined yet. The functionality
is defined by reacting to events such as what happens when another device tries
to read or write parameters and establish a connection.</p>
<p>The two main managers of events are the GAP and GATT event handlers. The
application needs to register a callback function for each event handler in
order to let the application know which functions are going to handle the GAP
and GATT events:</p>
<pre><code class="c">esp_ble_gatts_register_callback(gatts_event_handler);
esp_ble_gap_register_callback(gap_event_handler);
</code></pre>

<p>The functions <code>gatts_event_handler()</code> and <code>gap_event_handler()</code> handle all the
events that are pushed to the application from the BLE stack.</p>
<h2 id="application-profiles">Application Profiles</h2>
<p>This example implements one Application Profile for the Heart Rate Service. An
Application Profile is a way to group functionality which is designed to be used
by one client application, for example one smartphone mobile app. In this way,
different types of profiles can be accommodated in one server.</p>
<p>The Application Profile ID, which is an user-assigned number to identify each
profile, is used to register the profile in the stack, in this example the ID is
0x55.</p>
<pre><code class="c">#define PROFILE_NUM                 1
#define PROFILE_APP_IDX             0
#define ESP_APP_ID                  0x55
</code></pre>

<p>The profiles are stored in the <code>heart_rate_profile_tab</code> array. Since there is
only one profile in this example, one element is stored in the array with index
zero as defined by the <code>PROFILE_APP_IDX</code>. Additionally, the profile event
handler callback function is initialized. Each application on the GATT server
uses a different interface, represented by the <code>gatts_if</code> parameter. For
initialization, this parameter is set to <code>ESP_GATT_IF_NONE</code>, later when the
application is registered, the <code>gatts_if</code> parameter is updated with the
corresponding interface generated by the stack.</p>
<pre><code class="c">/* One gatt-based profile one app_id and one gatts_if, this array will store the gatts_if returned by ESP_GATTS_REG_EVT */
static struct gatts_profile_inst heart_rate_profile_tab[PROFILE_NUM] = {
    [PROFILE_APP_IDX] = {
        .gatts_cb = gatts_profile_event_handler,
        .gatts_if = ESP_GATT_IF_NONE,       /* Not get the gatt_if, so initial is ESP_GATT_IF_NONE */
    },
};
</code></pre>

<p>The application registration takes place inside <code>app_main()</code> using the
<code>esp_ble_gatts_app_register()</code> function:</p>
<pre><code class="c">esp_ble_gatts_app_register(ESP_HEART_RATE_APP_ID);
</code></pre>

<h2 id="setting-gap-parameters">Setting GAP Parameters</h2>
<p>The register application event is the first one that is triggered during the lifetime of the program. This example uses this event to configure advertising parameters upon registration in the profile event handler. The functions used to achieve this are:</p>
<ul>
<li><code>esp_ble_gap_set_device_name()</code>: used to set the advertised device name.</li>
<li><code>esp_ble_gap_config_adv_data()</code>: used to configure standard advertising data.</li>
</ul>
<p>The function used to configure standard Bluetooth Specification advertisement parameters is <code>esp_ble_gap_config_adv_data()</code> which takes a pointer to an <code>esp_ble_adv_data_t</code> structure. The <code>esp_ble_adv_data_t</code> data structure for advertising data has the following definition:</p>
<pre><code class="c">typedef struct {
    bool set_scan_rsp;    /*!&lt; Set this advertising data as scan response or not*/
    bool include_name;    /*!&lt; Advertising data include device name or not */
    bool include_txpower; /*!&lt; Advertising data include TX power */
    int min_interval;     /*!&lt; Advertising data show slave preferred connection min interval */
    int max_interval;     /*!&lt; Advertising data show slave preferred connection max interval */
    int appearance;       /*!&lt; External appearance of device */
    uint16_t manufacturer_len; /*!&lt; Manufacturer data length */
    uint8_t *p_manufacturer_data; /*!&lt; Manufacturer data point */
    uint16_t service_data_len;    /*!&lt; Service data length */
    uint8_t *p_service_data;      /*!&lt; Service data point */
    uint16_t service_uuid_len;    /*!&lt; Service uuid length */
    uint8_t *p_service_uuid;      /*!&lt; Service uuid array point */
    uint8_t flag;         /*!&lt; Advertising flag of discovery mode, see BLE_ADV_DATA_FLAG detail */
} esp_ble_adv_data_t;
</code></pre>

<p>In this example, the structure is initialized as follows:</p>
<pre><code class="c">static esp_ble_adv_data_t heart_rate_adv_config = {
    .set_scan_rsp = false,
    .include_name = true,
    .include_txpower = true,
    .min_interval = 0x0006,
    .max_interval = 0x0010,
    .appearance = 0x00,
    .manufacturer_len = 0, //TEST_MANUFACTURER_DATA_LEN,
    .p_manufacturer_data =  NULL, //&amp;test_manufacturer[0],
    .service_data_len = 0,
    .p_service_data = NULL,
    .service_uuid_len = sizeof(heart_rate_service_uuid),
    .p_service_uuid = heart_rate_service_uuid,
    .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),
};
</code></pre>

<p>The minimum and maximum slave preferred connection intervals are set in units of
1.25 ms. In this example, the minimum slave preferred connection interval is
defined as 0x0006 * 1.25 ms = 7.5 ms and the maximum slave preferred connection
interval is initialized as 0x0010 * 1.25 ms = 20 ms.</p>
<p>An advertising payload can be up to 31 bytes of data. It is possible that some
of the parameters surpass the 31-byte advertisement packet limit which causes
the stack to cut the message and leave some of the parameters out. To solve
this, usually the longer parameters are stored in the scan response, which can
be configured using the same <code>esp_ble_gap_config_adv_data()</code> function and an
additional esp_ble_adv_data_t type structure with the .set_scan_rsp parameter is
set to true. Finally, to set the device name the
<code>esp_ble_gap_set_device_name()</code> function is used. The registering event
handler is shown as follows:</p>
<pre><code class="c">static void gatts_profile_event_handler(esp_gatts_cb_event_t event,
esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    ESP_LOGE(GATTS_TABLE_TAG, &quot;event = %x\n&quot;,event);
    switch (event) {
        case ESP_GATTS_REG_EVT:
            ESP_LOGI(GATTS_TABLE_TAG, &quot;%s %d\n&quot;, __func__, __LINE__);
            esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME);
            ESP_LOGI(GATTS_TABLE_TAG, &quot;%s %d\n&quot;, __func__, __LINE__);
            esp_ble_gap_config_adv_data(&amp;heart_rate_adv_config);
            ESP_LOGI(GATTS_TABLE_TAG, &quot;%s %d\n&quot;, __func__, __LINE__);
...
</code></pre>

<h2 id="gap-event-handler">GAP Event Handler</h2>
<p>Once the advertising data have been set, the
<code>ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT</code> is triggered and managed by the GAP
event handler. Moreover, an <code>ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT</code> is
triggered as well if the scan response is also set. Once the configuration of
the advertising and scan response data has been set, the handler can use any of
these events to start advertising, which is done using the
<code>esp_ble_gap_start_advertising()</code> function:</p>
<pre><code class="c">static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
{
    ESP_LOGE(GATTS_TABLE_TAG, &quot;GAP_EVT, event %d\n&quot;, event);

    switch (event) {
    case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:
        esp_ble_gap_start_advertising(&amp;heart_rate_adv_params);
        break;
    case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
        //advertising start complete event to indicate advertising start successfully or failed
        if (param-&gt;adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTS_TABLE_TAG, &quot;Advertising start failed\n&quot;);
        }
        break;
    default:
        break;
    }
}
</code></pre>

<p>The function to start advertising takes a structure of type
<code>esp_ble_adv_params_t</code> with the advertising parameters required.</p>
<pre><code class="c">/// Advertising parameters
typedef struct {
    uint16_t adv_int_min; /*!&lt; Minimum advertising interval for undirected and low duty cycle directed advertising.
    Range: 0x0020 to 0x4000
    Default: N = 0x0800 (1.28 second)
    Time = N * 0.625 msec
    Time Range: 20 ms to 10.24 sec */
    uint16_t adv_int_max; /*!&lt; Maximum advertising interval for undirected and low duty cycle directed advertising.
    Range: 0x0020 to 0x4000
    Default: N = 0x0800 (1.28 second)
    Time = N * 0.625 msec
    Time Range: 20 ms to 10.24 sec */
    esp_ble_adv_type_t adv_type;            /*!&lt; Advertising type */
    esp_ble_addr_type_t own_addr_type;      /*!&lt; Owner bluetooth device address type */
    esp_bd_addr_t peer_addr;                /*!&lt; Peer device bluetooth device address */
    esp_ble_addr_type_t peer_addr_type;     /*!&lt; Peer device bluetooth device address type */
    esp_ble_adv_channel_t channel_map;      /*!&lt; Advertising channel map */
    esp_ble_adv_filter_t adv_filter_policy; /*!&lt; Advertising filter policy */
} esp_ble_adv_params_t;
</code></pre>

<p>Note that <code>esp_ble_gap_config_adv_data()</code> configures the data that is
advertised to the client and takes an <code>esp_ble_adv_data_t structure</code>, while
<code>esp_ble_gap_start_advertising()</code> makes the server to actually start
advertising and takes an <code>esp_ble_adv_params_t</code> structure. The advertising
data is the information that is shown to the client, while the advertising
parameters are the configuration required by the BLE stack to execute.</p>
<p>For this example, the advertisement parameters are initialized as follows:</p>
<pre><code class="c">static esp_ble_adv_params_t heart_rate_adv_params = {
    .adv_int_min        = 0x20,
    .adv_int_max        = 0x40,
    .adv_type           = ADV_TYPE_IND,
    .own_addr_type      = BLE_ADDR_TYPE_PUBLIC,
    //.peer_addr            =
    //.peer_addr_type       =
    .channel_map        = ADV_CHNL_ALL,
    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
};
</code></pre>

<p>These parameters configure the advertising interval between 20 ms to 40 ms. The
advertisement is of type ADV_IND, which is generic, not directed to a particular
central device and advertises the server as connectable. The address type is
public, uses all channels and allows both scan and connection requests from any
central.</p>
<p>If the advertising started successfully, an
<code>ESP_GAP_BLE_ADV_START_COMPLETE_EVT</code> event is generated which in this example
is used to check if the advertising status is indeed advertising or otherwise
print an error message.</p>
<pre><code class="c">...
    case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
        //advertising start complete event to indicate advertising start successfully or failed
        if (param-&gt;adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTS_TABLE_TAG, &quot;Advertising start failed\n&quot;);
        }
        break;
...
</code></pre>

<h2 id="gatt-event-handlers">GATT Event Handlers</h2>
<p>When an Application Profile is registered, an <code>ESP_GATTS_REG_EVT</code> event is
triggered. The parameters of the <code>ESP_GATTS_REG_EVT</code> are:</p>
<pre><code class="c">esp_gatt_status_t status;    /*!&lt; Operation status */
uint16_t app_id;             /*!&lt; Application id which input in register API */
</code></pre>

<p>In addition to the previous parameters, the event also contains the GATT
interface assigned by the BLE stack. The event is captured by the
<code>gatts_event_handler()</code> which stores the generated interface in the profile
table and then forwards it to the corresponding profile event handler.</p>
<pre><code class="c">static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    ESP_LOGI(GATTS_TABLE_TAG, &quot;EVT %d, gatts if %d\n&quot;, event, gatts_if);

    /* If event is register event, store the gatts_if for each profile */
    if (event == ESP_GATTS_REG_EVT) {
        if (param-&gt;reg.status == ESP_GATT_OK) {
            heart_rate_profile_tab[HEART_PROFILE_APP_IDX].gatts_if = gatts_if;
        } else {
            ESP_LOGI(GATTS_TABLE_TAG, &quot;Reg app failed, app_id %04x, status %d\n&quot;,
                    param-&gt;reg.app_id,
                    param-&gt;reg.status);
            return;
        }
    }

    do {
        int idx;
        for (idx = 0; idx &lt; HEART_PROFILE_NUM; idx++) {
            if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */
            gatts_if == heart_rate_profile_tab[idx].gatts_if) {
                if (heart_rate_profile_tab[idx].gatts_cb) {
                    heart_rate_profile_tab[idx].gatts_cb(event, gatts_if, param);
                }
            }
        }
    } while (0);
}
</code></pre>

<h2 id="creating-services-and-characteristics-with-the-attribute-table">Creating Services and Characteristics with the Attribute Table</h2>
<p>The register event is used to create a table of profile attributes by employing
the <code>esp_ble_gatts_create_attr_tab()</code> function. This function takes an
argument of type <code>esp_gatts_attr_db_t</code> which corresponds to a look up table
keyed by the enumeration values defined in the header file.</p>
<p>The <code>esp_gatts_attr_db_t</code> structure has two members:</p>
<pre><code class="c">esp_attr_control_t    attr_control;       /*!&lt; The attribute control type*/
esp_attr_desc_t       att_desc;           /*!&lt; The attribute type*/
</code></pre>

<p>The attr_control is the auto-respond parameter which can be set as
<code>ESP_GATT_AUTO_RSP</code> to allow the BLE stack to take care of responding messages
when read or write events arrive. The other option is <code>ESP_GATT_RSP_BY_APP</code>
which allows to manually respond to messages using the
<code>esp_ble_gatts_send_response()</code> function.</p>
<p>The <code>att_desc</code> is the attribute description which is made of:</p>
<pre><code class="c">uint16_t uuid_length;      /*!&lt; UUID length */
uint8_t  *uuid_p;          /*!&lt; UUID value */
uint16_t perm;             /*!&lt; Attribute permission */
uint16_t max_length;       /*!&lt; Maximum length of the element*/
uint16_t length;           /*!&lt; Current length of the element*/
uint8_t  *value;           /*!&lt; Element value array*/
</code></pre>

<p>For example, the first element of the table in this example is the service
attribute:</p>
<pre><code class="c">[HRS_IDX_SVC]                       =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;primary_service_uuid, ESP_GATT_PERM_READ,
      sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&amp;heart_rate_svc}},
</code></pre>

<p>The initialization values are:</p>
<ul>
<li><code>[HRS_IDX_SVC]</code>: Named or designated initializer in the enum table.</li>
<li><code>ESP_GATT_AUTO_RSP</code>: Auto respond configuration, set to respond automatically by the stack.</li>
<li><code>ESP_UUID_LEN_16</code>: UUID length set to 16 bits.</li>
<li><code>(uint8_t *)&amp;primary_service_uuid</code>: UUID to identify the service as a primary one (0x2800).</li>
<li><code>ESP_GATT_PERM_READ</code>: Read Permission for the service.</li>
<li><code>sizeof(uint16_t)</code>: Maximum length of the service UUID (16 bits).</li>
<li><code>sizeof(heart_rate_svc)</code>: Current service length set to the size of the variable <em>heart_rate_svc</em>, which is 16 bits.</li>
<li><code>(uint8_t *)&amp;heart_rate_svc</code>: Service attribute value set to the variable <em>heart_rate_svc</em> which contains the Heart Rate Service UUID (0x180D).</li>
</ul>
<p>The rest of the attributes is initialized in the same way. Some attributes also
have the <em>NOTIFY</em> property which is set by <code>&amp;char_prop_notify</code>. The complete
table structure is initialized as follows:</p>
<pre><code class="c">/// Full HRS Database Description - Used to add attributes into the database
static const esp_gatts_attr_db_t heart_rate_gatt_db[HRS_IDX_NB] =
{
    // Heart Rate Service Declaration
    [HRS_IDX_SVC]                       =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;primary_service_uuid, ESP_GATT_PERM_READ,
      sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&amp;heart_rate_svc}},

    // Heart Rate Measurement Characteristic Declaration
    [HRS_IDX_HR_MEAS_CHAR]            =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;character_declaration_uuid, ESP_GATT_PERM_READ,
      CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&amp;char_prop_notify}},

    // Heart Rate Measurement Characteristic Value
    [HRS_IDX_HR_MEAS_VAL]               =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;heart_rate_meas_uuid, ESP_GATT_PERM_READ,
      HRPS_HT_MEAS_MAX_LEN,0, NULL}},

    // Heart Rate Measurement Characteristic - Client Characteristic Configuration Descriptor
    [HRS_IDX_HR_MEAS_NTF_CFG]           =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
      sizeof(uint16_t),sizeof(heart_measurement_ccc), (uint8_t *)heart_measurement_ccc}},

    // Body Sensor Location Characteristic Declaration
    [HRS_IDX_BOBY_SENSOR_LOC_CHAR]  =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;character_declaration_uuid, ESP_GATT_PERM_READ,
      CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&amp;char_prop_read}},

    // Body Sensor Location Characteristic Value
    [HRS_IDX_BOBY_SENSOR_LOC_VAL]   =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;body_sensor_location_uuid, ESP_GATT_PERM_READ,
      sizeof(uint8_t), sizeof(body_sensor_loc_val), (uint8_t *)body_sensor_loc_val}},

    // Heart Rate Control Point Characteristic Declaration
    [HRS_IDX_HR_CTNL_PT_CHAR]          =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;character_declaration_uuid, ESP_GATT_PERM_READ,
      CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&amp;char_prop_read_write}},

    // Heart Rate Control Point Characteristic Value
    [HRS_IDX_HR_CTNL_PT_VAL]             =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;heart_rate_ctrl_point, ESP_GATT_PERM_WRITE|ESP_GATT_PERM_READ,
      sizeof(uint8_t), sizeof(heart_ctrl_point), (uint8_t *)heart_ctrl_point}},
};
</code></pre>

<h2 id="starting-the-service">Starting the Service</h2>
<p>When the attribute table is created, an <code>ESP_GATTS_CREAT_ATTR_TAB_EVT</code> event is triggered. This event has the following parameters:</p>
<pre><code class="c">esp_gatt_status_t status;    /*!&lt; Operation status */
esp_bt_uuid_t svc_uuid;      /*!&lt; Service uuid type */
uint16_t num_handle;         /*!&lt; The number of the attribute handle to be added to the gatts database */
uint16_t *handles;           /*!&lt; The number to the handles */
</code></pre>

<p>This example uses this event to print information and to check that the size of the created table equals the number of elements in the enumeration HRS_IDX_NB. If the table is correctly created, the attribute handles are copied into the handle table heart_rate_handle_table and the service is started using the <code>esp_ble_gatts_start_service()</code> function:</p>
<pre><code class="c">case ESP_GATTS_CREAT_ATTR_TAB_EVT:{
        ESP_LOGI(GATTS_TABLE_TAG, &quot;The number handle =%x\n&quot;,param-&gt;add_attr_tab.num_handle);
        if (param-&gt;add_attr_tab.status != ESP_GATT_OK){
            ESP_LOGE(GATTS_TABLE_TAG, &quot;Create attribute table failed, error code=0x%x&quot;, param-&gt;add_attr_tab.status);
        }
        else if (param-&gt;add_attr_tab.num_handle != HRS_IDX_NB){
            ESP_LOGE(GATTS_TABLE_TAG, &quot;Create attribute table abnormally, num_handle (%d) \
                    doesn't equal to HRS_IDX_NB(%d)&quot;, param-&gt;add_attr_tab.num_handle, HRS_IDX_NB);
        }
        else {
            memcpy(heart_rate_handle_table, param-&gt;add_attr_tab.handles, sizeof(heart_rate_handle_table));
            esp_ble_gatts_start_service(heart_rate_handle_table[HRS_IDX_SVC]);
        }
        break;
</code></pre>

<p>The handles stored in the handles pointer of the event parameters are numbers
that identify each attribute. The handles can be used to know which
characteristic is being read or written to, therefore they can be passed around
and to upper layers of the application to handle different actions.</p>
<p>Finally, the heart_rate_handle_table contains the Application Profile in the
form of a structure with information about the attribute parameters as well as
GATT interface, connection ID, permissions and application ID. The profile
structure is shown as follows, note that not all members are used in this
example:</p>
<pre><code class="c">struct gatts_profile_inst {
    esp_gatts_cb_t gatts_cb;
    uint16_t gatts_if;
    uint16_t app_id;
    uint16_t conn_id;
    uint16_t service_handle;
    esp_gatt_srvc_id_t service_id;
    uint16_t char_handle;
    esp_bt_uuid_t char_uuid;
    esp_gatt_perm_t perm;
    esp_gatt_char_prop_t property;
    uint16_t descr_handle;
    esp_bt_uuid_t descr_uuid;
};
</code></pre>

<h1 id="interaction-with-the-gatt-server">Interaction with the GATT Server</h1>
<p>There are many tools that allow you to manage the connection to the GATT server.
On Linux, we will use <code>hcitool</code> and<code>gatttool</code>. In Windows, you can use a tool
called <code>Bluetooth LE Explorer</code>, that implements, albeit graphically, the same
functionality.</p>
<p>For this part of the lab assignment, you have to make visible the bluetooth
controller of your host machine (laptop/pc) to the virtual machine used for the
course.</p>
<h2 id="using-hcitool-and-gatttool-in-client-mode">Using <code>hcitool</code> and <code>gatttool</code> in client mode</h2>
<h3 id="scanning-available-devices-hcitool">Scanning available devices: <code>hcitool</code></h3>
<p><code>hcitool</code> is a command line tool that allows you to manage the Bluetooth
interface of the computer on which it is running. In our case, We will need to
determine the Bluetooth MAC address of our server.  To do this, first of all, we
will perform a scan of the devices BLE available in the environment using the
command:</p>
<pre><code class="sh">sudo hcitool lescan
</code></pre>

<div class="admonition danger">
<p class="admonition-title">Note</p>
<p>This command will not work if you did not make the bluetooth controller
available to the virtual machine.</p>
</div>
<p>If all went well, one line per available BLE device in the announcement phase
will be displayed. Among them, we must find our device, and annotate its MAC
address.</p>
<div class="admonition note">
<p class="admonition-title">Task</p>
<p>Edit the file <code>main/gatts_table_creat_demo.c</code> and modify the name of your
device, which will be announced in each emmited advertisment packet in the
<code>advertising</code> phase. You can achieve this by modifying the corresponding
field of the structure <code>raw_adv_data</code>. Next, compile and flash the example,
and start a session of scanning of BLE devices using the command:</p>
<p><code>sudo hcitool lescan</code></p>
<p>You should see your device on one of the output lines. Write down or
remember its MAC address.</p>
</div>
<h3 id="interacting-with-the-gatt-server-gatttool">Interacting with the GATT server: <code>gatttool</code>.</h3>
<div class="admonition danger">
<p class="admonition-title">Task 4.1</p>
<p>Write a small pdf report documenting all the steps and Tasks in this
section.</p>
</div>
<p>Once the Bluetooth MAC address of the device is obtained, we must proceed in two
phases. The first one is to pair it to the ESP device. The second, the
interaction with the GATT table. In both cases, you will use the <code>gatttool</code> tool
from the command line.</p>
<p>To start a <code>gatttool</code> session, we'll invoke the tool in interactive mode, using
the command:</p>
<pre><code class="sh">gatttool -b MAC -I
</code></pre>

<p>This will open an interactive console, waiting for the corresponding commands.</p>
<p>To perform the pairing, and considering that the Bluetooth MAC is already known,
we will use the <code>connect</code> command. If everything went well, we should observe a
change in the color of the prompt, and the <em>Connection successful</em> message. At
this point, see how the debugging output of ESP32 shows the messages
corresponding to the pairing process.</p>
<p>From the <code>gatttool</code> terminal, you can run the command <code>help</code> to get help (in the
form of a list of available commands):</p>
<pre><code class="sh">gatttool -b 24:6F:28:36:60:B2 -I
[24:6F:28:36:60:B2][LE]&gt; connect
Attempting to connect to 24:6F:28:36:60:B2
Connection successful
[24:6F:28:36:60:B2][LE]&gt; help
help                                           Show this help
exit                                           Exit interactive mode
quit                                           Exit interactive mode
connect         [address [address type]]       Connect to a remote device
disconnect                                     Disconnect from a remote device
primary         [UUID]                         Primary Service Discovery
included        [start hnd [end hnd]]          Find Included Services
characteristics [start hnd [end hnd [UUID]]]   Characteristics Discovery
char-desc       [start hnd] [end hnd]          Characteristics Descriptor Discovery
char-read-hnd   &lt;handle&gt;                       Characteristics Value/Descriptor Read by handle
char-read-uuid  &lt;UUID&gt; [start hnd] [end hnd]   Characteristics Value/Descriptor Read by UUID
char-write-req  &lt;handle&gt; &lt;new value&gt;           Characteristic Value Write (Write Request)
char-write-cmd  &lt;handle&gt; &lt;new value&gt;           Characteristic Value Write (No response)
sec-level       [low | medium | high]          Set security level. Default: low
mtu             &lt;value&gt;                        Exchange MTU for GATT/ATT
</code></pre>

<p>We'll start by looking at the list of GATT server features.</p>
<div class="admonition note">
<p class="admonition-title">Task</p>
<p>Using the corresponding command (<code>characteristics</code>), consult and write down
the features available on your GATT server.</p>
</div>
<p>One of these characteristics will be of crucial interest, since it will allow us
access, through its UUID, the instant heart rate measurement value, as well as
as well as the notification settings on that value. To determine which of the
lines is the one that interests us, look at the returned UUID value for each of
them, and determine, based on the macro <code>GATTS_CHAR_UUID_TEST_A</code> which one is
it.</p>
<p>To interact with this feature, we will need to know its handler, to use it as a
parameter in the <code>gatttool</code> commands. This handler is shown, for each line,
after the string <em>char value handle</em>.</p>
<div class="admonition note">
<p class="admonition-title">Task</p>
<p>The handler that allows reading the <em>Heart Rate Value</em> has associated a
handler of type character. Write its value down.</p>
</div>
<p>To read the value of the characteristic we can use the read command, using the
annotated handler as argument (<code>char-read-hnd handler</code>).</p>
<div class="admonition note">
<p class="admonition-title">Task</p>
<p>Read the heart rate monitoring value characteristic. What do you obtain? You
should observe a four-byte return value with value 0x00. These values
correspond to those of the <code>char_value</code> variable in your code. Modify them,
rebuild the project and <em>flash</em> it on the ESP32. Repeat the read. Did you
read the new value?</p>
</div>
<div class="admonition note">
<p class="admonition-title">Task</p>
<p>Now try to write to the characteristic. Use the command <code>char-write-cmd
handler value</code>, where value is, for example, <code>11223344</code>. It's possible?
Why?</p>
</div>
<p>We will now write to its client configuration characteristic descriptor. Its hancler
is the handler of the characteristic's value plus one. For instance, if the
handle for the value is <code>0x0001</code>, its cliente configuration characteristic
would have the handle <code>0x0002</code>.</p>
<div class="admonition note">
<p class="admonition-title">Task</p>
<p>Try now to write to the client configuration characteristic. Use the command
<code>char-write-cmd handler value</code>, where value is, for example, <code>0100</code>. It's
possible? Why?</p>
</div>
<h3 id="task-42">Task 4.2</h3>
<p>As you may have noticed, it is possible to read from the monitoring value,
and write to config value. We will use this last feature to configure
notifications about the monitoring value. This way, each time the value
changes, the clients that have activated the notifications will receive the
new value.</p>
<p>To achieve this we need to modify some parts of our code. Specifically, we
will need:</p>
<ol>
<li>Create a new task that periodically modifies the heart rate value (in our
   case generating a new random value). This task will consist of an
   infinite loop that, generates a new value for the characteristic and
   correctly updates the gatt table. Then, if notifications have been
   activated, it sends the new value to the clients:</li>
</ol>
<pre><code class="c">static void publish_data_task(void *pvParameters)
{
    while (1) {
        ESP_LOGI(&quot;APP&quot;, &quot;Sending data...&quot;);

        // Step 1: Update characteristic value ...

        // Step 2: If indications are active send the indication...

        // Step 3: Sleep for one second...
        vTaskDelay( 1000. / portTICK_PERIOD_MS);
    }
}
</code></pre>

<p>This routine should be created in response to the connection event by a
client, using, for example, the invocation to:</p>
<pre><code class="c">xTaskCreate(&amp;publish_data_task, &quot;publish_data_task&quot;, 4096, NULL, 5, NULL);
</code></pre>

<ol>
<li>
<p>The update of the value, carried out periodically and randomly, will modify
byte 1 of the heart rate value, taking a random value between 0 and 255 (as an
additional note, current heart rate monitors support values higher for heart
rate, although the configuration of this functionality is outside the scope of
practice), and then update the internal gatt table using the
<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/bluetooth/esp_gatts.html?highlight=esp_ble_gatts_set_attr_value#_CPPv428esp_ble_gatts_set_attr_value8uint16_t8uint16_tPK7uint8_t"><code>esp_ble_gatts_set_attr_value</code></a>
function.</p>
</li>
<li>
<p>The verification of the activation or not of the notification is done by
consulting the two bytes of the corresponding client configuration
characteristic. If these values are <code>0x01</code> and<code>0x00</code> (positions 0 and 1,
respectively), the notifications are active, and therefore, the notification
shall be sent. You will need to use the function
<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/bluetooth/esp_gatts.html?highlight=esp_ble_gatts_get_attr_value#_CPPv428esp_ble_gatts_get_attr_value8uint16_tP8uint16_tPPK7uint8_t"><code>esp_ble_gatts_get_attr_value</code></a>
to read this descriptor.</p>
</li>
<li>
<p>To send the notification, we will use the following function:</p>
</li>
</ol>
<pre><code class="c">esp_ble_gatts_send_indicate(heart_rate_profile_tab[0].gatts_if,
                                      heart_rate_profile_tab[0].conn_id,
                                      heart_rate_handle_table[IDX_CHAR_VAL_A],
                                      sizeof(char_value), char_value, false);
</code></pre>

<p>The activation of notifications from <code>gatttool</code> will be done by writing the
value <code>0x0100</code> in the client configuration characteristic, this is:</p>
<pre><code class="sh">char-write-cmd HANDLER 0100
</code></pre>

<p>If you also modify the UUIDs by those provided in the specification of Bluetooth
for the <em>Heart Rate Service</em>, and everything has been configured correctly, your
ESP32 should be able to interface with any heart rate monitor to, for example,
Android. To do this, use the following UUIDs:</p>
<ul>
<li>static const uint16_t GATTS_SERVICE_UUID_TEST      = 0x180D; //0x00FF;</li>
<li>static const uint16_t GATTS_CHAR_UUID_TEST_A       = 0x2A37; //0xFF01;</li>
<li>static const uint16_t GATTS_CHAR_UUID_TEST_B       = 0x2A38; //0xFF02;</li>
<li>static const uint16_t GATTS_CHAR_UUID_TEST_C       = 0x2A39; //0xFF03;</li>
</ul>
<p>Deliver the modified code with a small pdf report showing how you activate the
notifications with gatttool, and how the node then sends a new value every
second.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>

<!--
MkDocs version : 1.0.4
Build Date UTC : 2022-07-06 15:50:19
-->
