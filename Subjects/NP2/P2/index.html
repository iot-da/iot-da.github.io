<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="None">
        
        <link rel="canonical" href="https://iot-da.github.io/Subjects/NP2/P2/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Internet of Things and Data Analytics</title>
        <link href="../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body class="homepage">

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../../..">Internet of Things and Data Analytics</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../../..">Home</a>
                            </li>
                            <li >
                                <a href="../../../General/">General info.</a>
                            </li>
                            <li >
                                <a href="../../../News/">News</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Subjects <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../IOTNA/">IOTNA</a>
</li>
                                    
<li >
    <a href="../../MDM/">MDM</a>
</li>
                                    
<li >
    <a href="../../SID/">SID</a>
</li>
                                    
<li >
    <a href="../../IA/">IA</a>
</li>
                                    
<li >
    <a href="../../NP1/">NP1</a>
</li>
                                    
<li >
    <a href="../">NP2</a>
</li>
                                    
<li >
    <a href="../../SEC/">SEC</a>
</li>
                                    
<li >
    <a href="../../EDGE/">EDGE</a>
</li>
                                </ul>
                            </li>
                            <li >
                                <a href="../../../Contact/">Contact</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#laboratory-2-tcp-and-udp-sockets-in-esp-idf">Laboratory 2. TCP and UDP Sockets in ESP-IDF</a></li>
            <li><a href="#goals">Goals</a></li>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#the-c-sockets-api">The C sockets API</a></li>
            <li><a href="#examples">Examples</a></li>
            <li><a href="#clientserver-systems-on-the-esp32">Client/server systems on the ESP32</a></li>
            <li><a href="#udp-clientserver-on-the-esp32">UDP client/server on the ESP32</a></li>
            <li><a href="#tcp-clientserver-on-the-esp32">TCP client/server on the ESP32</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="laboratory-2-tcp-and-udp-sockets-in-esp-idf">Laboratory 2. TCP and UDP Sockets in ESP-IDF</h1>
<h2 id="goals">Goals</h2>
<ul>
<li>To familiarize with the sockets API in C.   </li>
<li>To develop basic schemas for client/server systems based con TCP and UDP using C.</li>
<li>To be ablo to analyze generated traffic in a TCP and UDP connection via Wireshark.</li>
<li>To design a an application-layer protocol to simulate an application based on
  the client/server paradigm using TCP and UDP to interact between a host and the
  ESP32 board.</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the previous laboratory, we studied how to develop simple client/server
systems using Python, both for TCP and for UDP.
In this lab, we will study and develop network components (TCP and UDP 
clients and servers) that can execute on the ESP32 leveraging the facilities
offered by ESP-IDF. Also, we will demonstrate that it is possible to interact
clients and servers executing on the virtual machine (programmed via Python) and
on the board (using the C sockets API).</p>
<h2 id="the-c-sockets-api">The C sockets API</h2>
<h3 id="funtions-for-byte-ordering">Funtions for byte ordering</h3>
<p>As TCP/IP is a universal standard, and it allows for communicating across virtually
any platform and architecture, it is necessary to get a byte ordering method so that
big-endian and little-endian machines can communicate in a transparent and correct way.
To accomplish this requirement, routines are usually provided to reorder and adapt
byte ordering. In platforms in which data are already correctly ordered, these functions 
do not present any special functionality, but anyway, its usage is necessary so that the 
communication among pairs is correct.</p>
<p>Typical functions for data reordering are:
<code>htons</code>, <code>htonl</code>, <code>ntohs</code> y <code>ntohl</code>. 
Their name explains their semantics: 
<em>host to network (short)</em>
<em>host to network (long)</em>, 
<em>network to host (short)</em> and 
<em>network to host (long)</em>,
converting datatypes <em>short</em> and <em>long</em> from the format used in network
transmissions (<em>network</em>) to a <em>host</em> representation. 
Hence, when we send binary data over the network, it will need to be transformed using 
<code>hton*</code> and upon receiving it, using <code>ntoh*</code>.</p>
<h3 id="data-structures">Data structures</h3>
<p>Before studyin the sockets API, it is necessary to show the goal of a set of data 
structures used in all of them. The most important is 
<code>sockaddr_in</code>, defined as follows:</p>
<pre><code class="c">struct sockaddr_in
{
    short          sin_family;
    u_short        sin_port;
    struct in_addr sin_addr;
    char           sin_zero[8];
};
</code></pre>

<p>The structure <code>in_addr</code> used in <code>sockaddr_in</code> is defined as:</p>
<pre><code class="c">struct in_addr
{
    u_long s_addr;
};
</code></pre>

<p>This one consists on a field of type <code>unsigned long int</code> that contains the 
IP address associated with the socket.</p>
<p>The structure <code>sockaddr_in</code> contains two important fields:</p>
<ul>
<li><code>sin_family</code>: indicating that the socket belongs to a specific family of protocols
  (we will use the constant <code>AF_INET</code> for IPv4).</li>
<li><code>sin_port</code>: the port associated to the socket.</li>
</ul>
<h3 id="basic-api">Basic API</h3>
<h4 id="socket"><code>socket()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int socket(int family, int type, int protocol);
</code></pre>

<ul>
<li>
<p>Description: Creates a communication <em>endpoint</em> and returs a file descriptor to handle it. </p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>family</code>:  <code>AF_INET</code> (IPv4), <code>AF_INET6</code> (IPv6).</li>
<li><code>type</code>: <code>SOCK_DGRAM</code> (UDP), <code>SOCK_STREAM</code> (TCP), <code>SOCK_RAW</code>.</li>
<li><code>protocol</code>: Typically 0 (not used in Internet sorckets).</li>
</ul>
</li>
<li>
<p>Return value: On success, returns a socket descriptor. 
                    Returns <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man socket</code>.</p>
</li>
</ul>
<h4 id="bind"><code>bind()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>

<ul>
<li>
<p>Description: Binds a <em>socket</em> to an address specified by <code>addr</code>.
  Usually, it is necessary to assign a local addres via this function before
  a TCP socket can receive connections.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>:  <em>socket</em> descriptor (returned by <code>socket</code>).</li>
<li><code>addr</code>: address to bind (see structure in previous section).</li>
<li><code>addrlen</code>: length (in bytes) of the previous structure.</li>
</ul>
</li>
<li>
<p>Return value: On success, returns 0.  Returns <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man bind</code>.</p>
</li>
</ul>
<h4 id="listen"><code>listen()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int listen(int sockfd, int backlog);
</code></pre>

<ul>
<li>
<p>Description: Marks the <em>socket</em> as <em>passive</em>, that is, 
  a <em>socket</em> that will be used to accept incoming connections using <code>accept</code>.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>:  <em>socket</em> descriptor (returned by <code>socket</code>).</li>
<li><code>backlog</code>: maximum length for the pending connections queue for the socket.</li>
</ul>
</li>
<li>
<p>Return value: On success, returns 0.  Returns <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man listen</code>.</p>
</li>
</ul>
<h4 id="accept"><code>accept()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre>

<ul>
<li>
<p>Description: In connection-oriented <em>sockets</em>, extracts the first request for connection 
  from the pending connection queue for the <em>socket</em>,
  creates a new <em>connected socket</em> and returns its descriptor. </p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>: <em>socket</em> descriptor (returned by <code>socket</code>).</li>
<li><code>addr</code>:  pointer to a structure of type <code>sockaddr</code>, whose fields
  will be filled with the date of the remote socket address.</li>
<li><code>addrlen</code>: size fo the <code>addr</code> structure.</li>
</ul>
</li>
<li>
<p>Return value: On success, returns 0.  Returns <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man accept</code>.</p>
</li>
</ul>
<h4 id="connect"><code>connect()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>

<ul>
<li>
<p>Description: Connects the <em>socket</em> to the address specified by 
  <code>addr</code>. If the <em>socket</em> is UDP, <code>addr</code> will be the only addres to which data will be sent
  by default, and the only one from which datagrams will be received.
  For TCP, this call intiates the connection procedure to the specified address.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>:  <em>socket</em> descriptor (returned by <code>socket</code>).</li>
<li><code>addr</code>:  pointer to a <code>sockaddr</code> structure, whose fields
  indicate the address of the destination connection.</li>
<li><code>addrlen</code>: size of the <code>addr</code> structure.</li>
</ul>
</li>
<li>
<p>Return value: On success, returns 0.  Returns <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man connect</code>.</p>
</li>
</ul>
<h4 id="send"><code>send()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">ssize_t send(int sockfd, const void *buf, size_t len, int flags);
</code></pre>

<ul>
<li>
<p>Description: In a connected <em>socket</em> (that is, with a known recepient)
  transmits messages to a remote socket.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>:  sending socket descriptor.</li>
<li><code>buf</code>:  sending <em>buffer</em> where message is stored.</li>
<li><code>len</code>: number of bytes to send.</li>
</ul>
</li>
<li>
<p>Return value: On success, returns the amount of bytes sent. <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man send</code>.</p>
</li>
</ul>
<h4 id="recvrecvfrom"><code>recv()</code>/<code>recvfrom()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">ssize_t recv(int sockfd, void *buf, size_t len, int flags);

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);

</code></pre>

<ul>
<li>
<p>Description: Receive messages from a <em>socket</em>, both in connection-oriented and 
  connectionless sockets. <code>recvfrom</code> receives output parameters that store information 
  about the origin of the message.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>:  socket descriptor.</li>
<li><code>buf</code>:  reception <em>buffer</em> where the received message will be stored.</li>
<li><code>len</code>: number of bytes to receive.</li>
<li><code>src_addr</code>: address of the remote end of th socket (communication origin).</li>
<li><code>addrlen</code>: <code>src_addr</code> structure size.</li>
</ul>
</li>
<li>
<p>Valor de retorno: If success, number of received bytes. <code>-1</code> if error.</p>
</li>
<li>
<p>Details: (<code>man recv</code> and <code>man recv_from</code>).</p>
</li>
</ul>
<h4 id="close"><code>close()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int close(int fd);
</code></pre>

<ul>
<li>
<p>Description: Closes a socket.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>fd</code>:  <em>socket</em> descriptor.</li>
</ul>
</li>
<li>
<p>Details: <code>man close</code>.</p>
</li>
</ul>
<h2 id="examples">Examples</h2>
<p>In the following, we propose a number of complete examples that illustrate the
use of the sockets API in C for the development of client/server systems. For each
one, check that, effectively, the use and sequence of application of each call follows
the directives in the figure:</p>
<p><img alt="flow" src="img/flow.png" /></p>
<div class="admonition note">
<p class="admonition-title">Task 1.1</p>
<p>Compile (<code>gcc example.c -o example.x</code>) and execute (<code>./example.x</code>) each pair
of codes and check its correct functionality. Study carefully the use of each
routine and how the previous directives are followed.</p>
</div>
<h3 id="example-a-tcp-client">Example: a TCP client</h3>
<pre><code class="c">#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;


int main() {
        const int server_port = 9000;

        struct sockaddr_in server_address;
        memset(&amp;server_address, 0, sizeof(server_address));
        server_address.sin_family = AF_INET;

        server_address.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
        server_address.sin_port = htons(server_port);

        int sock;
        if ((sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
                printf(&quot;Error in socket\n&quot;);
                return 1;
        }

        if (connect(sock, (struct sockaddr*)&amp;server_address,
                    sizeof(server_address)) &lt; 0) {
                printf(&quot;Error in connect\n&quot;);
                return 1;
        }

        const char* data_to_send = &quot;Hello, NP2!!&quot;;
        send(sock, data_to_send, strlen(data_to_send), 0);

        int n = 0;
        int len = 0, maxlen = 100;
        char buffer[maxlen];
        char* pbuffer = buffer;

        while ((n = recv(sock, pbuffer, maxlen, 0)) &gt; 0) {
                pbuffer += n;
                maxlen -= n;
                len += n;

                buffer[len] = '\0';
                printf(&quot;Received: '%s'\n&quot;, buffer);
        }

        close(sock);
        return 0;
}
</code></pre>

<h3 id="example-a-tcp-server">Example: a TCP server</h3>
<pre><code class="c">#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]) {
        int SERVER_PORT = 9000;

        struct sockaddr_in server_address;
        memset(&amp;server_address, 0, sizeof(server_address));
        server_address.sin_family = AF_INET;

        server_address.sin_port = htons(SERVER_PORT);

        server_address.sin_addr.s_addr = htonl(INADDR_ANY);

        int listen_sock;
        if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
                printf(&quot;Error in socket\n&quot;);
                return 1;
        }

        if ((bind(listen_sock, (struct sockaddr *)&amp;server_address,
                  sizeof(server_address))) &lt; 0) {
                printf(&quot;Error in bind\n&quot;);
                return 1;
        }

        int wait_size = 16;  

        if (listen(listen_sock, wait_size) &lt; 0) {
                printf(&quot;Error in listen\n&quot;);
                return 1;
        }

        struct sockaddr_in client_address;
        int client_address_len = 0;

        while (true) {
                int sock;
                if ((sock =
                         accept(listen_sock, (struct sockaddr *)&amp;client_address,
                                &amp;client_address_len)) &lt; 0) {
                        printf(&quot;Error in accept\n&quot;);
                        return 1;
                }

                int n = 0;
                int len = 0, maxlen = 100;
                char buffer[maxlen];
                char *pbuffer = buffer;

                printf(&quot;Cliente conectado con IP: %s\n&quot;,
                       inet_ntoa(client_address.sin_addr));

                while ((n = recv(sock, pbuffer, maxlen, 0)) &gt; 0) {
                        pbuffer += n;
                        maxlen -= n;
                        len += n;

                        printf(&quot;Received: '%s'\n&quot;, buffer);

                        send(sock, buffer, len, 0);
                }

                close(sock);
        }

        close(listen_sock);
        return 0;
}
</code></pre>

<div class="admonition note">
<p class="admonition-title">Task 1.2</p>
<p>Reproduce the logic of the previous client/server <em>echo</em> system using UDP.</p>
</div>
<h3 id="message-construction">Message construction</h3>
<p>In order to send messages that encapsulate different types of data in 
one invocation, you can define a message as follows:</p>
<pre><code class="c">typedef struct {
  int x;
  int y;
} message;
</code></pre>

<p>Giving value to each field and sending the structure offering the address of the
structure:</p>
<pre><code class="c">message.x = x; message.y = y;
send( socketfd, &amp;message, sizeof( message ), 0 );
</code></pre>

<div class="admonition note">
<p class="admonition-title">Task 1.3</p>
<p>Modify the UDP client to encapsulate and send a structure with different
fields (for example, two integers), that will be received by a Python server 
following the directives of Lab 1. In this case, do not use fields of 
floating point type (we will see how to do it in the future). The goal of the
Task is to demonstrate that a client programmed in C and a server programmed
in Python can communicate transparently. Hence, it is not expected from you to
develop a complex system.</p>
</div>
<h2 id="clientserver-systems-on-the-esp32">Client/server systems on the ESP32</h2>
<p>The reason behind the previous exercises lies on the fact that the TCP/IP
stack implemented in ESP-IDF (<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/lwip.html">Lightweight TCP/IP (lwIP)</a>) 
implements almost at 100% that API. Hence, the basic
firmware structure for a client/server and its API remains unmodified.</p>
<p>In this last section, we will work with two basic examples of implementation of 
client/server systems TCP and UDP on the ESP32, with the goal of studying its functionality,
check its interoperability and perform modifications to adapt them to a hypothetical IoT application.</p>
<h2 id="udp-clientserver-on-the-esp32">UDP client/server on the ESP32</h2>
<p>In this part, you will work with two examples provided within the examples collection
from ESP-IDF. Hence, copy in your workspace (out of the main ESP-IDF tree) both examples:</p>
<ul>
<li><strong>Server UDP</strong>: <code>examples/protocols/sockets/udp_server/</code></li>
<li><strong>Cient UDP</strong>: <code>examples/protocols/sockets/udp_client/</code></li>
</ul>
<h3 id="general-structure">General structure</h3>
<p>Observe the codes (<code>udp_server.c</code> for the server, and <code>udp_client.c</code> for the client). 
Check that both the basic structure of both components and the invocations
to the sockets API match with those seen for the <em>echo</em> system programmed in C.</p>
<p>Regarding the main task (function <code>app_main</code>) observe that it performs a series
of invoations to configuration APIs of some subsystems from FreeRTOS, mainly:</p>
<pre><code class="c">// Initializes the NVS (Non-volatile storage) by default.
ESP_ERROR_CHECK(nvs_flash_init());
// Initializes the ESP-NETIF infrastructure.
ESP_ERROR_CHECK(esp_netif_init());
// Creates the main default event loop.
ESP_ERROR_CHECK(esp_event_loop_create_default());

/* This funtion configures WiFi or Ethernet, as selected via menunconfig.
*/
ESP_ERROR_CHECK(example_connect());

xTaskCreate(udp_server_task, &quot;udp_server&quot;, 4096, NULL, 5, NULL);
</code></pre>

<ul>
<li>
<p><code>example_connect()</code>, function outside ESP-IDF, that establishes a WiFi or Ethernet connection. The function is blocking, and returns when a connection has been established.</p>
</li>
<li>
<p>The features of the WiFi connection (SSID and password) must be provided via <code>menuconfig</code>.</p>
</li>
<li>
<p>The goal of ESP-NETIF is to provide an abstraction layer on top of the TCP/IP stack, so that it can be migrated without modifications on user codes. You can check the documentation in the 
  <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/network/esp_netif.html">oficial webpage</a>.</p>
</li>
<li>
<p>Last, a task is created that executes the server logic (same for the client).</p>
</li>
<li>
<p>Observe that, in the code, the error messages are annotated using the macro
  <code>ESP_LOGE</code> and the informative ones with <code>ESP_LOGI</code>; try to follow this mechanism in your codes.</p>
</li>
</ul>
<h3 id="deployment-option-1">Deployment. Option 1</h3>
<p>In this case, you will deploy a client on an ESP32 and a server in the other.
Obviously, both ESP32s must be part of the same wireless network,
so they will be connected to the same access point (at home or at class, you can
use a mobile phone for that). Configure the following point in the infrastructure:</p>
<ul>
<li>
<p>Configure the SSID and password of the access point via <code>menuconfig</code> before compiling
and flashing the code both in the client and in the server.</p>
</li>
<li>
<p>In the server, configure via <code>menuconfig</code> the listen port.</p>
</li>
<li>
<p>Boot first the server node and take note of the proposed IP by the access point; use it in the client to configure the destintation IP of the communication. Do not forget to also configure the destination port using that configured for the server.</p>
</li>
</ul>
<p>At this point, you can boot the client and you should be communicating two ESP32 nodes via UDP.</p>
<h3 id="deployment-option-2">Deployment. Option 2</h3>
<p>If you only have one node, or just want to test other way of communication
between a PC node and an ESP32, you can use any of the system tools:</p>
<div class="admonition danger">
<p class="admonition-title">Note</p>
<p>Take into account that your PC (that is, the virtual machine) and the ESP32
must be part of the same network. To accomplish it, stop your virtual machine and
add a new network interface of type <em>bridge</em> connected to the WiFi interface of your PC.
Proceeding this way, you will have an interface with IP within the network, granted 
directly by your access point.</p>
</div>
<ul>
<li>To receive a UDP packge via a port /that is, emulate a UDP server):</li>
</ul>
<pre><code class="sh">nc -ul -p 3333
</code></pre>

<ul>
<li>To send a UDP package to a remote IP/port (that is, emulate a client):</li>
</ul>
<pre><code class="sh">nc -u IP_REMOTE 3333
</code></pre>

<p>In the <code>scripts</code> folder of the examples folder, you can find small client/server UDP 
Pythhon exmaples that you can also use.</p>
<h2 id="tcp-clientserver-on-the-esp32">TCP client/server on the ESP32</h2>
<p>The deployment of the client and server in their TCP version is equivalent to UDP.</p>
<ul>
<li>To receive a TCP package via a port (that is, to emulate a TCP server):</li>
</ul>
<pre><code class="sh">nc -l IP -p 3333
</code></pre>

<ul>
<li>To send a TCP package to a remote IP/port (that is, emulate a client):</li>
</ul>
<pre><code class="sh">nc IP 3333
</code></pre>

<p>Again, you can find TCP Python scripts to use on the <code>scripts</code> folder.</p>
<div class="admonition note">
<p class="admonition-title">Task</p>
<p>Experiment with the examples provide in ESP-IDF (client/server
TCP and UDP) and execute them on the ESP32.</p>
</div>
<div class="admonition danger">
<p class="admonition-title">Deliverable task</p>
<p>At this point, you will have a set of codes that implement client/server systems both
in a host (using Python and/or C) and on the ESP32 (using C and ESP-IDF), and you should
have checked their correct functioning.</p>
<p>Specifically, you should have developed:</p>
<ul>
<li>
<p>A client/server system developed for Lab1, written in Python and implementing a basic application-level protocol proposed by you.</p>
</li>
<li>
<p>Basic C code for the implementation of a client/server <em>echo</em> system, with codes given in this Lab.</p>
</li>
<li>
<p>Basic C/ESP-IDF codes to implement client/servers <em>echo</em> on the ESP32.</p>
</li>
</ul>
<p>As a deliverable task, you need to adapt your deliverable of Lab 1 so that both
client and server can work on the host (using Python or C) and on the ESP32. You will
deliver the developed codes and a short report with screen capture and explanations 
that demonstrate the correctness of the system.</p>
</div></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>

<!--
MkDocs version : 1.0.4
Build Date UTC : 2022-02-23 09:21:23
-->
