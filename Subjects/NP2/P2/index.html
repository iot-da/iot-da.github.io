<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="None">
        
        <link rel="canonical" href="https://iot-da.github.io/Subjects/NP2/P2/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Internet of Things and Data Analytics</title>
        <link href="../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body class="homepage">

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../../..">Internet of Things and Data Analytics</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../../..">Home</a>
                            </li>
                            <li >
                                <a href="../../../General/">General info.</a>
                            </li>
                            <li >
                                <a href="../../../News/">News</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Subjects <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../IOTNA/">IOTNA</a>
</li>
                                    
<li >
    <a href="../../MDM/">MDM</a>
</li>
                                    
<li >
    <a href="../../SID/">SID</a>
</li>
                                    
<li >
    <a href="../../IA/">IA</a>
</li>
                                    
<li >
    <a href="../../NP1/">NP1</a>
</li>
                                    
<li >
    <a href="../">NP2</a>
</li>
                                    
<li >
    <a href="../../SEC/">SEC</a>
</li>
                                    
<li >
    <a href="../../EDGE/">EDGE</a>
</li>
                                </ul>
                            </li>
                            <li >
                                <a href="../../../Contact/">Contact</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#laboratory-2-tcp-and-udp-sockets-in-esp-idf">Laboratory 2. TCP and UDP Sockets in ESP-IDF</a></li>
            <li><a href="#goals">Goals</a></li>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#the-c-sockets-api">The C sockets API</a></li>
            <li><a href="#ejemplos">Ejemplos</a></li>
            <li><a href="#sistemas-clienteservidor-en-el-esp32">Sistemas cliente/servidor en el ESP32</a></li>
            <li><a href="#clienteservidor-udp-en-el-esp32">Cliente/servidor UDP en el ESP32</a></li>
            <li><a href="#clienteservidor-tcp-en-el-esp32">Cliente/servidor TCP en el ESP32</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="laboratory-2-tcp-and-udp-sockets-in-esp-idf">Laboratory 2. TCP and UDP Sockets in ESP-IDF</h1>
<h2 id="goals">Goals</h2>
<ul>
<li>To familiarize with the sockets API in C.   </li>
<li>To develop basic schemas for client/server systems based con TCP and UDP using C.</li>
<li>To be ablo to analyze generated traffic in a TCP and UDP connection via Wireshark.</li>
<li>To design a an application-layer protocol to simulate an application based on
  the client/server paradigm using TCP and UDP to interact between a host and the
  ESP32 board.</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the previous laboratory, we studied how to develop simple client/server
systems using Python, both for TCP and for UDP.
In this lab, we will study and develop network components (TCP and UDP 
clients and servers) that can execute on the ESP32 leveraging the facilities
offered by ESP-IDF. Also, we will demonstrate that it is possible to interact
clients and servers executing on the virtual machine (programmed via Python) and
on the board (using the C sockets API).</p>
<h2 id="the-c-sockets-api">The C sockets API</h2>
<h3 id="funtions-for-byte-ordering">Funtions for byte ordering</h3>
<p>As TCP/IP is a universal standard, and it allows for communicating across virtually
any platform and architecture, it is necessary to get a byte ordering method so that
big-endian and little-endian machines can communicate in a transparent and correct way.
To accomplish this requirement, routines are usually provided to reorder and adapt
byte ordering. In platforms in which data are already correctly ordered, these functions 
do not present any special functionality, but anyway, its usage is necessary so that the 
communication among pairs is correct.</p>
<p>Typical functions for data reordering are:
<code>htons</code>, <code>htonl</code>, <code>ntohs</code> y <code>ntohl</code>. 
Their name explains their semantics: 
<em>host to network (short)</em>
<em>host to network (long)</em>, 
<em>network to host (short)</em> and 
<em>network to host (long)</em>,
converting datatypes <em>short</em> and <em>long</em> from the format used in network
transmissions (<em>network</em>) to a <em>host</em> representation. 
Hence, when we send binary data over the network, it will need to be transformed using 
<code>hton*</code> and upon receiving it, using <code>ntoh*</code>.</p>
<h3 id="data-structures">Data structures</h3>
<p>Before studyin the sockets API, it is necessary to show the goal of a set of data 
structures used in all of them. The most important is 
<code>sockaddr_in</code>, defined as follows:</p>
<pre><code class="c">struct sockaddr_in
{
    short          sin_family;
    u_short        sin_port;
    struct in_addr sin_addr;
    char           sin_zero[8];
};
</code></pre>

<p>The structure <code>in_addr</code> used in <code>sockaddr_in</code> is defined as:</p>
<pre><code class="c">struct in_addr
{
    u_long s_addr;
};
</code></pre>

<p>This one consists on a field of type <code>unsigned long int</code> that contains the 
IP address associated with the socket.</p>
<p>The structure <code>sockaddr_in</code> contains two important fields:</p>
<ul>
<li><code>sin_family</code>: indicating that the socket belongs to a specific family of protocols
  (we will use the constant <code>AF_INET</code> for IPv4).</li>
<li><code>sin_port</code>: the port associated to the socket.</li>
</ul>
<h3 id="basic-api">Basic API</h3>
<h4 id="socket"><code>socket()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int socket(int family, int type, int protocol);
</code></pre>

<ul>
<li>
<p>Description: Creates a communication <em>endpoint</em> and returs a file descriptor to handle it. </p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>family</code>:  <code>AF_INET</code> (IPv4), <code>AF_INET6</code> (IPv6).</li>
<li><code>type</code>: <code>SOCK_DGRAM</code> (UDP), <code>SOCK_STREAM</code> (TCP), <code>SOCK_RAW</code>.</li>
<li><code>protocol</code>: Typically 0 (not used in Internet sorckets).</li>
</ul>
</li>
<li>
<p>Return value: On success, returns a socket descriptor. 
                    Returns <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man socket</code>.</p>
</li>
</ul>
<h4 id="bind"><code>bind()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>

<ul>
<li>
<p>Description: Binds a <em>socket</em> to an address specified by <code>addr</code>.
  Usually, it is necessary to assign a local addres via this function before
  a TCP socket can receive connections.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>:  <em>socket</em> descriptor (returned by <code>socket</code>).</li>
<li><code>addr</code>: address to bind (see structure in previous section).</li>
<li><code>addrlen</code>: length (in bytes) of the previous structure.</li>
</ul>
</li>
<li>
<p>Return value: On success, returns 0.  Returns <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man bind</code>.</p>
</li>
</ul>
<h4 id="listen"><code>listen()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int listen(int sockfd, int backlog);
</code></pre>

<ul>
<li>
<p>Description: Marks the <em>socket</em> as <em>passive</em>, that is, 
  a <em>socket</em> that will be used to accept incoming connections using <code>accept</code>.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>:  <em>socket</em> descriptor (returned by <code>socket</code>).</li>
<li><code>backlog</code>: maximum length for the pending connections queue for the socket.</li>
</ul>
</li>
<li>
<p>Return value: On success, returns 0.  Returns <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man listen</code>.</p>
</li>
</ul>
<h4 id="accept"><code>accept()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre>

<ul>
<li>
<p>Description: In connection-oriented <em>sockets</em>, extracts the first request for connection 
  from the pending connection queue for the <em>socket</em>,
  creates a new <em>connected socket</em> and returns its descriptor. </p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>: <em>socket</em> descriptor (returned by <code>socket</code>).</li>
<li><code>addr</code>:  pointer to a structure of type <code>sockaddr</code>, whose fields
  will be filled with the date of the remote socket address.</li>
<li><code>addrlen</code>: size fo the <code>addr</code> structure.</li>
</ul>
</li>
<li>
<p>Return value: On success, returns 0.  Returns <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man accept</code>.</p>
</li>
</ul>
<h4 id="connect"><code>connect()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>

<ul>
<li>
<p>Description: Connects the <em>socket</em> to the address specified by 
  <code>addr</code>. If the <em>socket</em> is UDP, <code>addr</code> will be the only addres to which data will be sent
  by default, and the only one from which datagrams will be received.
  For TCP, this call intiates the connection procedure to the specified address.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>:  <em>socket</em> descriptor (returned by <code>socket</code>).</li>
<li><code>addr</code>:  pointer to a <code>sockaddr</code> structure, whose fields
  indicate the address of the destination connection.</li>
<li><code>addrlen</code>: size of the <code>addr</code> structure.</li>
</ul>
</li>
<li>
<p>Return value: On success, returns 0.  Returns <code>-1</code> if error.</p>
</li>
<li>
<p>Details: <code>man connect</code>.</p>
</li>
</ul>
<h4 id="send"><code>send()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">ssize_t send(int sockfd, const void *buf, size_t len, int flags);
</code></pre>

<ul>
<li>
<p>Description: En un <em>socket</em> en estado <em>conectado</em> (con receptor conocido)
  transmite mensajes a un socket remoto.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>:  descriptor de <em>socket</em> de envío.</li>
<li><code>buf</code>:  <em>buffer</em> de envío donde se almacena el mensaje a enviar.</li>
<li><code>len</code>: número de bytes a enviar.</li>
</ul>
</li>
<li>
<p>Valor de retorno: Si tiene éxito, devuelve el número de bytes enviados.
                    Devuelve <code>-1</code> si se produce un error.</p>
</li>
<li>
<p>Details: consultad la página de manual de <code>send</code> (<code>man send</code>).</p>
</li>
</ul>
<h4 id="recvrecvfrom"><code>recv()</code>/<code>recvfrom()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">ssize_t recv(int sockfd, void *buf, size_t len, int flags);

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);

</code></pre>

<ul>
<li>
<p>Description: Reciben mensajes desde un  <em>socket</em>, tanto en sockets orientados
  como no orientados a conexión. <code>recvfrom</code>, a diferencia de <code>recv</code>, recibe
  parámetrosd de salida adicionales que almacenan información sobre la dirección
  origen del mensaje.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>sockfd</code>:  descriptor de <em>socket</em> de recepción.</li>
<li><code>buf</code>:  <em>buffer</em> de recepción donde se almacena el mensaje a recibir.</li>
<li><code>len</code>: número de bytes a recibir.</li>
<li><code>src_addr</code>: dirección del extremo remoto del socket (origen de la comunicación).</li>
<li><code>addrlen</code>: tamaño de la estructura <code>src_addr</code>.</li>
</ul>
</li>
<li>
<p>Valor de retorno: Si tiene éxito, devuelve el número de bytes recibidos.
                    Devuelve <code>-1</code> si se produce un error.</p>
</li>
<li>
<p>Details: consultad las páginas de manual de <code>recv</code> y <code>recv_from</code> (<code>man recv</code> y 
  <code>man recv_from</code>).</p>
</li>
</ul>
<h4 id="close"><code>close()</code></h4>
<ul>
<li>Prototype:</li>
</ul>
<pre><code class="c">int close(int fd);
</code></pre>

<ul>
<li>
<p>Description: Cierra un socket.</p>
</li>
<li>
<p>Parameters: </p>
<ul>
<li><code>fd</code>:  descriptor de <em>socket</em>.</li>
</ul>
</li>
<li>
<p>Details: consultad la página de manual de <code>close</code> (<code>man close</code>).</p>
</li>
</ul>
<h2 id="ejemplos">Ejemplos</h2>
<p>Se proporcionan a continuación ejemplos completos de uso de la API de <em>sockets</em>
en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada 
uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicación
de cada llamada sigue las directivas de la figura:</p>
<p><img alt="flow" src="img/flow.png" /></p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Compila (<code>gcc ejemplo.c -o ejemplo.x</code>) y ejecuta (<code>./ejemplo.x</code>) cada par
de códigos y comprueba su funcionamiento. Estudia con detenimiento el uso
de cada rutina y como efectivamente siguen las directivas marcadas 
anteriormente.</p>
</div>
<h3 id="ejemplo-un-cliente-tcp">Ejemplo: un cliente TCP</h3>
<pre><code class="c">#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;


int main() {
        const int server_port = 9000;

        struct sockaddr_in server_address;
        memset(&amp;server_address, 0, sizeof(server_address));
        server_address.sin_family = AF_INET;

        server_address.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
        server_address.sin_port = htons(server_port);

        int sock;
        if ((sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
                printf(&quot;Error en socket\n&quot;);
                return 1;
        }

        if (connect(sock, (struct sockaddr*)&amp;server_address,
                    sizeof(server_address)) &lt; 0) {
                printf(&quot;Error en connect\n&quot;);
                return 1;
        }

        const char* data_to_send = &quot;Hola, RPI!!&quot;;
        send(sock, data_to_send, strlen(data_to_send), 0);

        int n = 0;
        int len = 0, maxlen = 100;
        char buffer[maxlen];
        char* pbuffer = buffer;

        while ((n = recv(sock, pbuffer, maxlen, 0)) &gt; 0) {
                pbuffer += n;
                maxlen -= n;
                len += n;

                buffer[len] = '\0';
                printf(&quot;Recibido: '%s'\n&quot;, buffer);
        }

        close(sock);
        return 0;
}
</code></pre>

<h3 id="ejemplo-un-servidor-tcp">Ejemplo: un servidor TCP</h3>
<pre><code class="c">#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]) {
        int SERVER_PORT = 9000;

        struct sockaddr_in server_address;
        memset(&amp;server_address, 0, sizeof(server_address));
        server_address.sin_family = AF_INET;

        server_address.sin_port = htons(SERVER_PORT);

        server_address.sin_addr.s_addr = htonl(INADDR_ANY);

        int listen_sock;
        if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
                printf(&quot;Error en socket\n&quot;);
                return 1;
        }

        if ((bind(listen_sock, (struct sockaddr *)&amp;server_address,
                  sizeof(server_address))) &lt; 0) {
                printf(&quot;Error en bind\n&quot;);
                return 1;
        }

        int wait_size = 16;  

        if (listen(listen_sock, wait_size) &lt; 0) {
                printf(&quot;Error en listen\n&quot;);
                return 1;
        }

        struct sockaddr_in client_address;
        int client_address_len = 0;

        while (true) {
                int sock;
                if ((sock =
                         accept(listen_sock, (struct sockaddr *)&amp;client_address,
                                &amp;client_address_len)) &lt; 0) {
                        printf(&quot;Error en accept\n&quot;);
                        return 1;
                }

                int n = 0;
                int len = 0, maxlen = 100;
                char buffer[maxlen];
                char *pbuffer = buffer;

                printf(&quot;Cliente conectado con IP: %s\n&quot;,
                       inet_ntoa(client_address.sin_addr));

                while ((n = recv(sock, pbuffer, maxlen, 0)) &gt; 0) {
                        pbuffer += n;
                        maxlen -= n;
                        len += n;

                        printf(&quot;Recibido: '%s'\n&quot;, buffer);

                        send(sock, buffer, len, 0);
                }

                close(sock);
        }

        close(listen_sock);
        return 0;
}
</code></pre>

<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Reproduce el funcionamiento del anterior sistema cliente/servidor <em>echo</em>
utilizando UDP.</p>
</div>
<h3 id="construccion-de-mensajes">Construcción de mensajes</h3>
<p>Para enviar mensajes que encapsulen distintos tipos de datos en una sola
invocación, puedes definir un mensaje como el siguiente:</p>
<pre><code class="c">typedef struct {
  int x;
  int y;
} mensaje;
</code></pre>

<p>Dando valor a cada campo y a continuación enviándolo proporcionando la dirección
de inicio de la estructura, del siguiente modo:</p>
<pre><code class="c">mensaje.x = x; mensaje.y = y;
send( socketfd, &amp;mensaje, sizeof( mensaje ), 0 );
</code></pre>

<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Modifica el cliente UDP para que encapsule y envíe una estructura con 
distintos campos (por ejemplo, dos enteros),
que sea recibida por un servidor Python siguiendo las
directivas de la anterior práctica. En este caso, no utilices campos
de tipo flotante (veremos cómo hacerlo más adelante). El objetivo del
ejercicio es simplemente comprobar que la comunicación entre un cliente
programado en C y un servidor programado en Python es posible. No se 
pretende que desarrolles un sistema complejo.</p>
</div>
<h2 id="sistemas-clienteservidor-en-el-esp32">Sistemas cliente/servidor en el ESP32</h2>
<p>La razón por la que hemos ejercitado el uso de la API de sockets desde C
en Linux es que la implementación de la pila TCP/IP en ESP-IDF 
(llamada <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/lwip.html">Lightweight TCP/IP (lwIP)</a>) implementa al 100% dicha API. Por tanto, tanto
la estructura básica de un <em>firmware</em> que implemente un cliente o servidor
como la API utilizada permanece inalterada. </p>
<p>En esta última sección, se pide trabajar con dos ejemplos básicos de implementación
de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar
su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para
adaptarlas a una hipotética aplicación IoT.</p>
<h2 id="clienteservidor-udp-en-el-esp32">Cliente/servidor UDP en el ESP32</h2>
<p>En esta parte, trabajarás con dos ejemplos proporcionados dentro de la colección
de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del
árbol principal de ESP-IDF) los ejemplos:</p>
<ul>
<li><strong>Servidor UDP</strong>: <code>examples/protocols/sockets/udp_server/</code></li>
<li><strong>Cliente UDP</strong>: <code>examples/protocols/sockets/udp_client/</code></li>
</ul>
<h3 id="estructura-general">Estructura general</h3>
<p>Observa sus códigos (<code>udp_server.c</code> para el servidor, y <code>udp_client.c</code> para el
cliente). Comprueba que, tanto la estructura básica de ambos componentes como
las invocaciones a la API de sockets concuerdan con las que vimos para el 
sistema <em>echo</em> programado en C. </p>
<p>Acerca de la tarea principal (funcion <code>app_main</code>) observa que realiza 
una serie de llamadas a APIs de configuración de algunos subsistemas de
FreeRTOS, principalmente:</p>
<pre><code class="c">// Inicializa la partición NVS (Non-volatile storage) por defecto. 
ESP_ERROR_CHECK(nvs_flash_init());
// Inicializa la infraestructura ESP-NETIF.
ESP_ERROR_CHECK(esp_netif_init());
// Crea un bucle de eventos por defecto.
ESP_ERROR_CHECK(esp_event_loop_create_default());

/* Esta función configura WiFi o Ethernet, tal y como seleccionemos via menuconfig.
*/
ESP_ERROR_CHECK(example_connect());

xTaskCreate(udp_server_task, &quot;udp_server&quot;, 4096, NULL, 5, NULL);
</code></pre>

<ul>
<li>
<p><code>example_connect()</code>, función que no forma parte de ESP-IDF, establece una 
conexión WiFi o Ethernet. La función es bloqueante, y retorna cuando se ha
conseguido establecer una conexión.</p>
</li>
<li>
<p>Las características de la conexión WiFi (SSID y contraseña) se deben proporcionar
a través de <code>menuconfig</code>.</p>
</li>
<li>
<p>El objetivo de ESP-NETIF es proporcionar una capa de abstracción por encima de 
  la pila TCP/IP, de modo que pueda migrarse la pila sin que los códigos del 
  usuario cambien. Puedes consultar su documentación en la 
  <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/network/esp_netif.html">página oficial</a>.</p>
</li>
<li>
<p>Por último, se cerea una tarea que ejecutará la lógica del servidor (lo mismo
  ocurre en el cliente).</p>
</li>
<li>
<p>Observa que, en todo el código, los mensajes de error se anotan utilizando
  la macro <code>ESP_LOGE</code> y los informativos con <code>ESP_LOGI</code>; intenta seguir este 
  convenio en tus códigos.</p>
</li>
</ul>
<h3 id="despliegue-opcion-1">Despliegue. Opción 1</h3>
<p>En este caso, desplegarás el cliente en un ESP32 y el servidor en otro. Si
no dispones de dos ESP32, puedes trabajar con un compañero.</p>
<p>En cualquier caso, ambos ESP32 deben pertenecer a la misma red inalámbrica,
por lo que deberán conectarse a un mismo punto de acceso (el profesor te
proporcionará los datos, o simplemente puedes utilizar tu punto de acceso
doméstico). Configura los siguientes puntos de la infraestructura:</p>
<ul>
<li>
<p>Configura el SSID y contraseña del punto de acceso vía <code>menuconfig</code> antes
de compilar y flashear el código tanto en el cliente como en el servidor. </p>
</li>
<li>
<p>En el servidor, configura vía <code>menuconfig</code> el puerto sobre el que escuchará.</p>
</li>
<li>
<p>Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de 
 acceso; utilízala en el cliente para
configurar la IP destino de la comunicación. No olvides configurar también
el puerto destino de acuerdo al configurado en el servidor vía <code>menuconfig</code>.</p>
</li>
</ul>
<p>Ên este punto, podrás arrancar el cliente y deberías estar comunicando dos
nodos ESP32 vía UDP.</p>
<h3 id="despliegue-opcion-2">Despliegue. Opción 2</h3>
<p>Si sólo dispones de un nodo, o si simplemente quieres probar otra forma de 
comunicación en la que uno de los equipos es un PC, puedes utilizar alguna
de las herramientas del sistema:</p>
<div class="admonition danger">
<p class="admonition-title">Nota</p>
<p>Ten en cuenta que portátil (es decir, máquina virtual) y ESP32 deben
pertenecera la misma red. Para conseguirlo, para tu máquina virtual y añade
una nueva interfaz de red de tipo <em>bridge</em> conectada a la interfaz Wifi
física de tu PC. Así, tendrás una interfaz con IP en la misma red, otorgada
directamente por tu punto de acceso.</p>
</div>
<ul>
<li>Para recibir un paquete UDP a través de un puerto (es decir, emular un
  servidor UDP):</li>
</ul>
<pre><code class="sh">nc -ul -p 3333
</code></pre>

<ul>
<li>Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente):</li>
</ul>
<pre><code class="sh">nc -u IP_REMOTA 3333
</code></pre>

<p>En el directorio <code>scripts</code> dispones también de pequeños ejemplos de clientes y
servidores UDP Python que puedes también utilizar.</p>
<h2 id="clienteservidor-tcp-en-el-esp32">Cliente/servidor TCP en el ESP32</h2>
<p>El despliegue de cliente y servidor TCP es equivalente al UDP.</p>
<ul>
<li>Para recibir un paquete TCP a través de un puerto (es decir, emular un
  servidor TCP):</li>
</ul>
<pre><code class="sh">nc -l IP -p 3333
</code></pre>

<ul>
<li>Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente):</li>
</ul>
<pre><code class="sh">nc IP 3333
</code></pre>

<p>En el directorio <code>scripts</code> dispones también de pequeños ejemplos de clientes y
servidores TCP Python que puedes también utilizar.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor
TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si sólo
dispones de una placa, utiliza la máquina virtual como cliente/servidor
para comprobar el correcto funcionamiento de cada código.</p>
</div>
<div class="admonition danger">
<p class="admonition-title">Tarea entregable</p>
<p>En este punto, deberías disponer de un conjunto de códigos que implementan
sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en
la placa ESP32 (utilizando C y ESP-IDF), y deberías haber comprobado su
correcto funcionamiento.</p>
<p>Específicamente, dispondrás de:</p>
<ul>
<li>
<p>Sistema cliente/servidor desarrollado en la Práctica 1, escrito en Python
e implementando un protocolo básico de aplicacion (tipo de mensaje) propuesto
por ti.</p>
</li>
<li>
<p>Código básico en C para implementación de un servidor/cliente <em>echo</em> 
programado en C, cuyos códigos se proporcionan en este boletín.</p>
</li>
<li>
<p>Códigos básicos en C/ESP-IDF para implementar servidores/clientes
<em>echo</em> sobre el ESP32.</p>
</li>
</ul>
<p>Como tarea entregable, se pide que adaptes tu entrega de la Práctica 1 para
que tanto cliente como servidor puedan funcionar en el host (bien usando
tu implementación Python, o bien utilizando una nueva implementación en 
C) o en el ESP32. Se entregarán los códigos y una breve memoria con capturas
de tráfico que demuestren el correcto funcionamiento del sistema.</p>
</div></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>

<!--
MkDocs version : 1.0.4
Build Date UTC : 2022-01-26 12:01:46
-->
